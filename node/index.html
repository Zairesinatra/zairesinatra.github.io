<!DOCTYPE html>
<html lang="en">
<head>

    <title>NodeJS</title>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="stylesheet" type="text/css" href="../assets/built/screen.css%3Fv=7d64696598.css" />

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.18.2/tocbot.css">
    <link rel="stylesheet" type="text/css" href="../assets/css/screen.css%3Fv=7d64696598.css" />
    <meta name="description" content="Atwood 定律：任何能够用 JavaScript 实现的应用系统，最终都必将用 JavaScript 实现。" />
    <link rel="icon" href="../content/images/size/w256h256/2021/07/ghost-orb.png" type="image/png" />
    <link rel="canonical" href="index.html" />
    <meta name="referrer" content="no-referrer-when-downgrade" />
    <link rel="amphtml" href="amp/index.html" />
    
    <meta property="og:site_name" content="zairesinatra" />
    <meta property="og:type" content="article" />
    <meta property="og:title" content="NodeJS" />
    <meta property="og:description" content="Atwood 定律：任何能够用 JavaScript 实现的应用系统，最终都必将用 JavaScript 实现。" />
    <meta property="og:url" content="https://zairesinatra.github.io//node/" />
    <meta property="og:image" content="https://zairesinatra.github.io//content/images/2022/08/NodeJS-1.jpg" />
    <meta property="article:published_time" content="2021-07-08T15:02:00.000Z" />
    <meta property="article:modified_time" content="2022-12-29T10:46:17.000Z" />
    <meta property="article:tag" content="Technology growth" />
    
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="NodeJS" />
    <meta name="twitter:description" content="Atwood 定律：任何能够用 JavaScript 实现的应用系统，最终都必将用 JavaScript 实现。" />
    <meta name="twitter:url" content="https://zairesinatra.github.io//node/" />
    <meta name="twitter:image" content="https://zairesinatra.github.io//content/images/2022/08/NodeJS-1.jpg" />
    <meta name="twitter:label1" content="Written by" />
    <meta name="twitter:data1" content="Ziyi Xie" />
    <meta name="twitter:label2" content="Filed under" />
    <meta name="twitter:data2" content="Technology growth" />
    <meta name="twitter:site" content="@xieziyi0422" />
    <meta property="og:image:width" content="1920" />
    <meta property="og:image:height" content="1080" />
    
    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "publisher": {
        "@type": "Organization",
        "name": "zairesinatra",
        "url": "https://zairesinatra.github.io//",
        "logo": {
            "@type": "ImageObject",
            "url": "https://zairesinatra.github.io//content/images/2021/07/zs-1.JPG",
            "width": 60,
            "height": 60
        }
    },
    "author": {
        "@type": "Person",
        "name": "Ziyi Xie",
        "image": {
            "@type": "ImageObject",
            "url": "https://zairesinatra.github.io//content/images/2021/07/zs-2.JPG",
            "width": 1079,
            "height": 1079
        },
        "url": "https://zairesinatra.github.io//author/ziyi/",
        "sameAs": []
    },
    "headline": "NodeJS",
    "url": "https://zairesinatra.github.io//node/",
    "datePublished": "2021-07-08T15:02:00.000Z",
    "dateModified": "2022-12-29T10:46:17.000Z",
    "image": {
        "@type": "ImageObject",
        "url": "https://zairesinatra.github.io//content/images/2022/08/NodeJS-1.jpg",
        "width": 1920,
        "height": 1080
    },
    "keywords": "Technology growth",
    "description": "Atwood 定律：任何能够用 JavaScript 实现的应用系统，最终都必将用 JavaScript 实现。",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://zairesinatra.github.io//"
    }
}
    </script>

    <meta name="generator" content="Ghost 5.33" />
    <link rel="alternate" type="application/rss+xml" title="zairesinatra" href="../rss/index.html" />
    <script defer src="https://cdn.jsdelivr.net/ghost/portal@~2.24/umd/portal.min.js" data-ghost="https://zairesinatra.github.io//" data-key="f5d74add11f1d16d3e59c12945" data-api="https://zairesinatra.github.io//ghost/api/content/" crossorigin="anonymous"></script><style id="gh-members-styles">.gh-post-upgrade-cta-content,
.gh-post-upgrade-cta {
    display: flex;
    flex-direction: column;
    align-items: center;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
    text-align: center;
    width: 100%;
    color: #ffffff;
    font-size: 16px;
}

.gh-post-upgrade-cta-content {
    border-radius: 8px;
    padding: 40px 4vw;
}

.gh-post-upgrade-cta h2 {
    color: #ffffff;
    font-size: 28px;
    letter-spacing: -0.2px;
    margin: 0;
    padding: 0;
}

.gh-post-upgrade-cta p {
    margin: 20px 0 0;
    padding: 0;
}

.gh-post-upgrade-cta small {
    font-size: 16px;
    letter-spacing: -0.2px;
}

.gh-post-upgrade-cta a {
    color: #ffffff;
    cursor: pointer;
    font-weight: 500;
    box-shadow: none;
    text-decoration: underline;
}

.gh-post-upgrade-cta a:hover {
    color: #ffffff;
    opacity: 0.8;
    box-shadow: none;
    text-decoration: underline;
}

.gh-post-upgrade-cta a.gh-btn {
    display: block;
    background: #ffffff;
    text-decoration: none;
    margin: 28px 0 0;
    padding: 8px 18px;
    border-radius: 4px;
    font-size: 16px;
    font-weight: 600;
}

.gh-post-upgrade-cta a.gh-btn:hover {
    opacity: 0.92;
}</style>
    <script defer src="https://cdn.jsdelivr.net/ghost/sodo-search@~1.1/umd/sodo-search.min.js" data-key="f5d74add11f1d16d3e59c12945" data-styles="https://cdn.jsdelivr.net/ghost/sodo-search@~1.1/umd/main.css" data-sodo-search="https://zairesinatra.github.io//" crossorigin="anonymous"></script>
    <link href="https://zairesinatra.github.io//webmentions/receive/" rel="webmention" />
    <script defer src="../public/cards.min.js%3Fv=7d64696598"></script>
    <link rel="stylesheet" type="text/css" href="../public/cards.min.css%3Fv=7d64696598.css">
    <script defer src="../public/member-attribution.min.js%3Fv=7d64696598"></script>
    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-NXZH6Q3K52"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-NXZH6Q3K52');
</script>
<!-- Ghost Init -->
<style>
.post-template .gh-head,
.page-template .gh-head {
  background: #000000 !important;
}
.site-footer {
  background: #000000 !important;
}
.post-card-tags {
  color: var(--color-secondary-text) !important;
}
.gh-portal-triggerbtn-container.with-label::before {
  display: none !important;
}
/* 需提前，否则闪烁 */
.footer-cta,
a.gh-head-button {
  display: none;
}
.algoliaouterwrapper i svg {
  width: 0;
}
/* 更多内容去除外边距 */
.footer-cta + .read-more-wrap {
  margin-top: unset;
}
</style>

<!-- 2023 => prismjs -->
<script src="https://res.cloudinary.com/dzb9ldnvl/raw/upload/v1679662056/Ghost/prism_i9a8up.js"></script>
<link rel="stylesheet" href="https://res.cloudinary.com/dzb9ldnvl/raw/upload/v1679662068/Ghost/prism_mdfwkg.css"/>
<!-- Patch: additional supported languages -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-vim.min.js" integrity="sha512-P1MRK1H11qw68MAfAYVyjumLuurOQKO4wwcx4S2Nbbae9CndG92dkIXq34lsOeMFlWZoT7nVPgsOy3gepk93Bg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<!-- Activate Line Numbers in PrismJS -->
<script>
	window.addEventListener('DOMContentLoaded', (event) => {      
		document.querySelectorAll('pre[class*=language-]').forEach(function(node) {
			node.classList.add('line-numbers');
            node.style.border = 'solid #FFFFFF 1px'
		});
		Prism.highlightAll();
	});
</script>
<!-- Resize Pre Area in PrismJS -->
<style>
    pre[class*="language-"].line-numbers{
		font-size: 0.8em;
        background-color: #202324;
    }
    code[class*="language-"] {
        background-color: transparent !important;
    }
</style>

<!-- TOC -->
<style>
    .toc > .toc-list li:first-child {
      margin-top: 8px;
    }
    .toc-list a {
      color: #000000 !important;
      text-decoration: none;
      word-break: break-word;
    }
    .toc > ol, .toc > li{
      font-size: 1.4rem;
    }
    
    .toc.active > .toc-list li:first-child {
      margin-top: 8px;
    }
    .toc.active .toc-list a {
      color: #FFFFFF !important;
      text-decoration: none;
      word-break: break-word;
    }
    .toc.active > ol, .toc.active > li{
      font-size: 1.4rem;
    }
</style>

<!-- ghost style by wkzs -->
<style>
.gh-content > [id] + * {
  margin-top: 2.5rem !important;
}
.gh-content > [id]:not(:first-child) {
  margin: 1.5em 0 0;
}
.gh-content > hr + *, .gh-content > blockquote + * {
  margin-top: max(1.1rem, 16px) !important;
}
.gh-content > [id]:not(:first-child) {
  margin: 1em 0 0;
}
.gh-content > * + * {
  margin-top: max(1.6vmin, 16px);
  margin-bottom: 0;
}
.gh-content > blockquote:not([class]), .gh-content > ol, .gh-content > ul, .gh-content > dl, .gh-content > p {
    font-family: var(--font-serif);
    font-weight: 400;
    font-size: 1.6rem;
    line-height: 1.6em;
    margin-top: 1.6rem;
}
</style>

<!-- Theme Change -->
<style>
@keyframes slideUp {
  from {
    bottom: 100px;
    opacity: 0;
  }
  to {
    bottom: 0;
    opacity: 1;
  }
}
.theme-switcher-wrap {
  width: 42px;
  height: 24px;
  text-align: right;
}
@media (max-width: 767px) {
  .gh-head-open .theme-switcher-wrap {
    width: 42px;
    height: 24px;
    text-align: right;
    animation: slideUp 1s ease-in-out forwards;
  }
}
.theme-switcher {
  display: inline-block;
  cursor: pointer;
}
.switch-path {
  width: 42px;
  height: 24px;
  border-radius: 10px;
  background-color: #f2f2f2;
  border: #dddfe6 1px solid;
}
.switch-path > .switch-handle {
  background-color: #ffffff;
  width: 20px;
  height: 20px;
  border-radius: 50%;
  transition: all 0.3s ease-in-out;
}
.switch-handle .dark-icon {
  visibility: hidden;
  display: none;
}
.theme-switcher.active .switch-path {
  background-color: #555;
}
.theme-switcher.active .switch-handle {
  transform: translateX(20px);
  background-color: #101115;
}
.theme-switcher.active .switch-handle .light-icon {
  visibility: hidden;
}
.theme-switcher.active .switch-handle .dark-icon {
  visibility: visible;
  display: block;
}
</style>

<!-- Arrow up -->
<style>
    .arrowup {
    	position: fixed;
        width: 50px;
        height: 50px;
        left: 35px;
        bottom: 3.1rem;
        z-index: 99;
        background-color: #15171A;
        display: flex;
        justify-content: center;
        align-items: center;
        border-radius: 10px;
        cursor: pointer;
        opacity: 1;
  		transition: opacity 0.3s ease-in-out;
    }
    .arrowup svg {
    	fill: #FFFFFF;
    }
    .arrowup:hover {
      opacity: 0.8;
    }
</style><style>:root {--ghost-accent-color: #15171A;}</style>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@docsearch/css@3"/></pre></li>
</head>
<body class="post-template tag-technology-growth is-head-left-logo has-cover">
<div class="viewport">
    <header id="gh-head" class="gh-head outer">
        <div class="gh-head-inner inner">
            <div class="gh-head-brand">
                <a class="gh-head-logo" href="../index.html">
                        <img src="../content/images/2021/07/zs-1.JPG" alt="zairesinatra">
                </a>
                <button class="gh-search gh-icon-btn" onclick="docSearchFuncMobile()"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" width="20" height="20"><path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path></svg></button>
                <button class="gh-burger"></button>
            </div>

            <nav class="gh-head-menu">
                <ul class="nav">
    <li class="nav-home"><a href="../index.html">Home</a></li>
    <li class="nav-welcome"><a href="../welcome/index.html">Welcome</a></li>
    <li class="nav-author"><a href="../selfintro/index.html">Author</a></li>
    <li class="nav-tags"><a href="../tags/index.html">Tags</a></li>
</ul>

            </nav>

            <div class="gh-head-actions">
                <div class="theme-switcher-wrap">
                    <div class="theme-switcher" onclick="switchTheme()">
                    <div class="switch-path">
                        <div class="switch-handle">
                        <svg viewBox="0 0 24 24" class="dark-icon">
                            <path
                            d="M11.01 3.05C6.51 3.54 3 7.36 3 12a9 9 0 0 0 9 9c4.63 0 8.45-3.5 8.95-8c.09-.79-.78-1.42-1.54-.95A5.403 5.403 0 0 1 11.1 7.5c0-1.06.31-2.06.84-2.89c.45-.67-.04-1.63-.93-1.56z"
                            fill="#CFD3DC"
                            ></path>
                        </svg>
                        <svg viewBox="0 0 24 24" class="light-icon">
                            <path
                            d="M6.05 4.14l-.39-.39a.993.993 0 0 0-1.4 0l-.01.01a.984.984 0 0 0 0 1.4l.39.39c.39.39 1.01.39 1.4 0l.01-.01a.984.984 0 0 0 0-1.4zM3.01 10.5H1.99c-.55 0-.99.44-.99.99v.01c0 .55.44.99.99.99H3c.56.01 1-.43 1-.98v-.01c0-.56-.44-1-.99-1zm9-9.95H12c-.56 0-1 .44-1 .99v.96c0 .55.44.99.99.99H12c.56.01 1-.43 1-.98v-.97c0-.55-.44-.99-.99-.99zm7.74 3.21c-.39-.39-1.02-.39-1.41-.01l-.39.39a.984.984 0 0 0 0 1.4l.01.01c.39.39 1.02.39 1.4 0l.39-.39a.984.984 0 0 0 0-1.4zm-1.81 15.1l.39.39a.996.996 0 1 0 1.41-1.41l-.39-.39a.993.993 0 0 0-1.4 0c-.4.4-.4 1.02-.01 1.41zM20 11.49v.01c0 .55.44.99.99.99H22c.55 0 .99-.44.99-.99v-.01c0-.55-.44-.99-.99-.99h-1.01c-.55 0-.99.44-.99.99zM12 5.5c-3.31 0-6 2.69-6 6s2.69 6 6 6s6-2.69 6-6s-2.69-6-6-6zm-.01 16.95H12c.55 0 .99-.44.99-.99v-.96c0-.55-.44-.99-.99-.99h-.01c-.55 0-.99.44-.99.99v.96c0 .55.44.99.99.99zm-7.74-3.21c.39.39 1.02.39 1.41 0l.39-.39a.993.993 0 0 0 0-1.4l-.01-.01a.996.996 0 0 0-1.41 0l-.39.39c-.38.4-.38 1.02.01 1.41z"
                            fill="#606266"
                            ></path>
                        </svg>
                        </div>
                    </div>
                    </div>
                </div>
                    <button class="gh-search gh-icon-btn" onclick="docSearchFuncMobile()"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" width="20" height="20"><path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path></svg></button>
                    <div class="gh-head-members">
                                <a class="gh-head-link" href="index.html#/portal/signin" data-portal="signin">Sign in</a>
                                <a class="gh-head-button" href="index.html#/portal/signup" data-portal="signup">Subscribe</a>
                    </div>
            </div>
        </div>
    </header>

    <div class="site-content">
      <script src="https://cdn.jsdelivr.net/npm/@docsearch/js@3"></script>
        



<main id="site-main" class="site-main">
<article class="article post tag-technology-growth ">

    <header class="article-header gh-canvas">

        <div class="article-tag post-card-tags">
                <span class="post-card-primary-tag">
                    <a href="../tag/technology-growth/index.html">Technology growth</a>
                </span>
        </div>

        <h1 class="article-title">NodeJS</h1>

            <p class="article-excerpt">Atwood 定律：任何能够用 JavaScript 实现的应用系统，最终都必将用 JavaScript 实现。</p>

        <div class="article-byline">
        <section class="article-byline-content">

            <ul class="author-list">
                <li class="author-list-item">
                    <a href="../author/ziyi/index.html" class="author-avatar">
                        <img class="author-profile-image" src="../content/images/size/w100/2021/07/zs-2.JPG" alt="Ziyi Xie" />
                    </a>
                </li>
            </ul>

            <div class="article-byline-meta">
                <h4 class="author-name"><a href="../author/ziyi/index.html">Ziyi Xie</a></h4>
                <div class="byline-meta-content">
                    <time class="byline-meta-date" datetime="2021-07-08">Jul 8, 2021</time>
                        <span class="byline-reading-time"><span class="bull">&bull;</span> 39 min read</span>
                </div>
            </div>

        </section>
        </div>

            <figure class="article-image">
                <img
                    srcset="../content/images/size/w1000/2022/08/NodeJS-1.jpg 1000w"
                    sizes="(min-width: 1400px) 1400px, 92vw"
                    src="../content/images/size/w2000/2022/08/NodeJS-1.jpg"
                    alt="NodeJS"
                />
                    <figcaption>NodeJS</figcaption>
            </figure>

    </header>

    <section class="gh-content gh-canvas">
    <aside class="toc-container">
        <div class="toc"></div>
    </aside>
    <!--kg-card-begin: markdown--><h2 id="%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B">快速上手</h2>
<h3 id="%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8">浏览器内核</h3>
<blockquote>
<p>常说的浏览器内核指的是浏览器排版引擎 layout engine，也可称为浏览器引擎、页面渲染引擎或样板引擎。</p>
</blockquote>
<p>主流浏览器内核组成：</p>
<ul>
<li>IE/Edge browser：Trident 转向 Blink</li>
<li>Chrome browser：Webkit 转向 Blink -&gt; 统称为 Chromium</li>
<li>Firefox browser：Gecko</li>
<li>Safari browser：Webkit</li>
<li>Opera browser：Presto 变更为 Webkit，现在转向 Blink</li>
</ul>
<p>浏览器内核负责对网页语法的解释以及渲染网页，通常由渲染引擎和 JS 引擎两部分组成。</p>
<h3 id="%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B">浏览器渲染过程</h3>
<p>在浏览网页过程中，所有资源并非一捆下载，而是解析时到具体的标签时，再去相应的定位处下载资源。</p>
<ul>
<li>进入页面 HTML 被首先下载，HTML Parser 开始解析标签并生成 DOM Tree</li>
<li>DOM Tree 生成时会有 JS 引擎帮助解析 JavaScript 代码对 DOM 进行操作</li>
<li>因 HTML 的解析过程是自上而下的，所以在遇见 &lt;link&gt; 标签表示的 CSS 样式时，会根据 CSS Paser 生成对应的 CSS Rules 并与 DOM Tree 结合产生 Render Tree</li>
<li>Render Tree 在生成时会根据 Layout Engine 进行针对浏览器状态的适配调整，并在完成后进行 Painting 与 Display</li>
<li>HTML 解析过程中遇见 JavaScript 会停止解析，不同于 CSS 异步加载执行，因为 JavaScript 代码可以操作 DOM</li>
</ul>
<img src="https://res.cloudinary.com/dzb9ldnvl/image/upload/v1672309386/blog/zsghost/svg/browserRenderingProcess_e5ot5l.svg" style="overflow:scroll" />
<h3 id="javascript-engine">JavaScript Engine</h3>
<p>高级的编程语言最终都是需要转成机器指令来执行的。JavaScript 无论是交给浏览器还是 Node.JS，最后都是需要只认识机器语言指令集的 CPU 执行。所以需要 JS 引擎帮助将 JavaScript 代码翻译成 CPU 指令进行执行。</p>
<blockquote>
<p>=&gt; 常见 JavaScript Engine<br>
SpiderMonkey =&gt; The first JavaScript engine &amp; Developed by Brendan Eich<br>
Chakra =&gt; 微软开发并用于 IE 浏览器<br>
JavaScriptCore =&gt; Apple 开发并用于 WebKit<br>
v8 =&gt; Google 开发用于 Chromium</p>
</blockquote>
<h3 id="v8-%E5%BC%95%E6%93%8E%E5%8E%9F%E7%90%86">V8 引擎原理</h3>
<p>C++ 编写的 <a href="https://v8.dev/">V8 engine</a> 由 Google 开源，是高性能 JS 和 WebAssembly 引擎，用于 Chrome 和 Node 等。V8 可以独立运行，也可以嵌入到任何 C++ 应用程序中。</p>
<blockquote>
<p>V8 engine implements ECMAScript and WebAssembly, and runs on Windows 7 or later, macOS 10.12+, and Linux systems that use x64, IA-32, ARM, or MIPS processors.</p>
<ul>
<li>ECMAScript is a Standard for scripting languages such as JavaScript, JScript, etc. It is a trademark scripting language specification. JavaScript is a language based on ECMAScript. A standard for scripting languages like JavaScript, JScript is ECMAScript.</li>
<li>WebAssembly (abbreviated Wasm) is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications.</li>
</ul>
</blockquote>
<p>JS 经过<a href="https://esprima.org/">词法分析</a>生成由 type 与 value 组成的对象并存储在 tokens 数组。随后的语法分析生成 <a href="https://astexplorer.net/">AST</a> 抽象语法树。</p>
<p>类似 Babel 将 TS 转为 JS，也是先生成 Abstract Syntax Tree 并作出相应修改，产生 new Abstract Syntax Tree，再 generate code 为 JS。</p>
<p>同理 Vue 中 Template 也是先转换成 Abstract Syntax Tree 再 CreateVNode 虚拟节点，最后产生 JS。</p>
<pre><code class="language-js">const name = 'zs'
/* 词法分析 */
[
  { type: 'Keyword', value: 'const' },
  { type: 'Identifier', value: 'name' },
  { type: 'Punctuator', value: '=' },
  { type: 'String', value: &quot;'zs'&quot; }
]

/* 语法分析 */
{
  &quot;type&quot;: &quot;Program&quot;,
  &quot;start&quot;: 0,
  &quot;end&quot;: 17,
  &quot;body&quot;: [
    {
      &quot;type&quot;: &quot;VariableDeclaration&quot;,
      &quot;start&quot;: 0,
      &quot;end&quot;: 17,
      &quot;declarations&quot;: [
        {
          &quot;type&quot;: &quot;VariableDeclarator&quot;,
          &quot;start&quot;: 6,
          &quot;end&quot;: 17,
          &quot;id&quot;: {
            &quot;type&quot;: &quot;Identifier&quot;,
            &quot;start&quot;: 6,
            &quot;end&quot;: 10,
            &quot;name&quot;: &quot;name&quot;
          },
          &quot;init&quot;: {
            &quot;type&quot;: &quot;Literal&quot;,
            &quot;start&quot;: 13,
            &quot;end&quot;: 17,
            &quot;value&quot;: &quot;zs&quot;,
            &quot;raw&quot;: &quot;'zs'&quot;
          }
        }
      ],
      &quot;kind&quot;: &quot;const&quot;
    }
  ],
  &quot;sourceType&quot;: &quot;module&quot;
}
</code></pre>
<img src="https://res.cloudinary.com/dzb9ldnvl/image/upload/v1672309680/blog/zsghost/svg/PrincipleOfV8Engine_nlux1n.svg" style="overflow:scroll" />
<p><a href="https://v8.dev/blog/scanner">官方 V8 引擎原理</a>中是通过 Blink 将源码交给 V8 engine，以 Stream 获取到源码并且进行编码转换；Scanner 进行词法分析生成 tokens，再经过 Parser 和 PreParser 转换成 AST。不同于前者的直接解析转换，后者是预解析，因为并不是所有的 JS 代码在一开始时就会被执行，所以通过延迟解析将不必要的函数进行预解析（函数的全量解析是在函数被调用时才进行 =&gt; 函数 outer 内部定义函数 inner，那 inner 函数就会进行预解析）。生成的抽象语法树会被 Ignition 转成字节码后执行。</p>
<h3 id="io-%E5%AF%86%E9%9B%86">IO 密集</h3>
<blockquote>
<p>非阻塞 IO 模型 =&gt; IO 即计算机输入输出，常见有外接硬件、磁盘读写、网络传输和数据库操作。阻塞 IO 即进行 IO 操作时，进程处于休眠状态，等待 IO 操作完成再通知主进程进行后续处理（触发事件函数通知主进程）。</p>
</blockquote>
<blockquote>
<p>事件驱动 =&gt; 区别于 Nginx 多进程单线程，NodeJS 通过事件驱动的方式处理请求时无需为每一个请求创建额外的线程。每一个 IO 操作都会被添加到事件队列中，线程循环地处理队列上的工作任务，当执行过程中遇到阻塞，线程不会停下来等待结果，而是留下一个处理结果的回调函数，转而继续执行队列中的下一个任务。这个传递到队列中的回调函数在阻塞任务运行结束后才被线程调用。</p>
</blockquote>
<ul>
<li>IO 密集与 CPU 密集</li>
</ul>
<p>CPU 密集 =&gt; 程序大部分时间用于处理逻辑运算、文件压缩解压与数据加密解密</p>
<p>IO 密集 =&gt; 程序大部分时间用来做数据存储以及网络读取的操作</p>
<ul>
<li>WEB 开发的 IO 密集</li>
</ul>
<p>当浏览器中的请求到达服务器时，除了使用 cpu 进行计算 uri 路径的文件位置，剩下的都是文件读取以及数据库操作，由此可见 http 请求大部分还是 IO 操作。此外在页面渲染时，除开使用 cpu 计算，其他涉及读取模板文件或根据数据生成 Html 都算做 IO 操作。所以说 WEB 开发是典型的 IO 密集的场景。</p>
<ul>
<li>进程与线程</li>
</ul>
<p>进程 Process 通俗来说就是正在内存中运行的程序，多进程是通过 cpu 调度算法在纳秒单位切换执行多个进程。线程是进程内一个相对独立的可调度的执行单元，也就是进程中单一顺序的控制流。多任务就是说在一个进程可以并发多个线程，而每条线程并行执行不同的任务。一个进程开启一项任务，就是打开了一个线程，类似于 Downie4 开始了一个下载任务。</p>
<ul>
<li>REPL Read-Eval-Print Loop =&gt; 交互式编程环境。</li>
</ul>
<pre><code class="language-shell">$ node
Welcome to Node.js v14.17.1.
Type &quot;.help&quot; for more information.
$ process
process { version: 'v14.17.1', versions: { node: '14.17.1', v8: '8.4.371.23-...
</code></pre>
<pre><code class="language-javascript">node index.js zszszs age=22 // 给 node 传参使用 process 内置对象的 argv(argument vector) 接收
console.trace(); // 打印函数调用栈
</code></pre>
<h3 id="global-object-module">Global object &amp; Module</h3>
<ul>
<li><a href="https://nodejs.org/api/globals.html">全局对象</a> =&gt; 在程序的任何位置可以直接访问的对象</li>
</ul>
<p>在 JS 源代码通过 Parse 转换为 AST 的阶段，会创建全局对象 GlobalObject，并放入 window 属性（即 this 指向当前 GlobalObject）、setTimeout...。存在部分特殊的全局变量，这些全局变量实际上是模块中的变量，只不过每个模块都有，所以看起来好像是全局变量，但在命令行交互中不可直接使用。</p>
<pre><code class="language-javascript">// 常见的全局变量
process // 提供Node进程相关信息
console // 控制台
// 定时器全局函数
setTimeout(() =&gt; {},time)
setInterval(() =&gt; {},time)
setImmediate(() =&gt; {})
process.nextTick(() =&gt; {})
// 全局对象
global // global. 按两下 Tab
</code></pre>
<pre><code class="language-javascript">// 特殊的全局变量
// 需要进入文件所在文件夹再 node index.js
__dirname // 打印当前文件夹所在目录绝对路径
__filename // 打印当前文件所在目录绝对路径
exports、module、require() // 模块化相关
</code></pre>
<p>V8 在创建 GO 后，为执行代码还需要 ECStack Execution Context Stack 执行上下文栈作为容器去接收 GEC Global Execution Context 全局执行上下文。</p>
<p>VO Variable Object 变量对象在编译时，其内每一项只是对应 GO 的初始未赋值属性，只有在执行期间才会对相应属性更改。</p>
<pre><code class="language-javascript">/* --- 伪代码 --- */
/*
GO =&gt;
var globalObject = {
  String:&quot;Class&quot;, Date:&quot;Class&quot;,setTimeout:&quot;Func&quot;,window:globalObject,name:undefined,age:undefined
}
*/
// 解释变量提升为什么出现 undefined
var name = &quot;zs&quot;
console.log(age) // 编译完成但未执行 =&gt; GO 中还是 undefined
var age = 22
</code></pre>
<ul>
<li>CJS 与 ESM 模块的导入与导出</li>
</ul>
<p>Node CJS 不同于 ES6 ESM。后者使用 export 与 export default 导出，在需要模块的文件中以 import from &quot;模块名&quot; 导入。</p>
<p>export 导出需使用 {} 配合导入；export default 导出的模块可直接导入，无需明确所要加载模块的变量名（默认名）。模块中 export、import 不做限制，而 export default 最多只能有一个。</p>
<pre><code class="language-js">// ES6 —— export
// a.js
export const str = &quot;zairesinatra&quot;;
export function zs (sth) { 
  return sth;
}
// 对应的导入方式：
// b.js
import { str, zs } from 'a'; // 也可以分开写两次，导入的时候带花括号

// ES6 —— export default
// a.js
const str = &quot;zairesinatra&quot;;
export default str;
// 对应的导入方式：
//b.js
import str from 'a'; //导入的时候没有花括号

// ES6 —— 自由命名
// a.js
let name = &quot;xzy&quot;;
export default name // name不能加大括号
// 原本直接export name外部是无法识别的，加上default就可以了.但是一个文件内最多只能有一个export default。
// 其实此处相当于为name变量值&quot;xzy&quot;起了一个系统默认的变量名default，自然default只能有一个值，所以一个文件内不能有多个export default。
// b.js
// 本质上，a.js文件的export default输出一个叫做default的变量，然后系统允许你为它取任意名字。所以可以为import的模块起任何变量名，且不需要用大括号包含
import zs from &quot;./a.js&quot;
import zy from &quot;./a.js&quot; 
console.log(zs,zy)   // xzy,xzy
</code></pre>
<p>CommonJS 使用 require 引入后的返回只有 module.exports 对象。exports 对象实际上只是对 module.exports 的引用。<a href="https://stackoverflow.com/questions/7137397/module-exports-vs-exports-in-node-js/7142924">module.exports 初始值为一个空对象 {}</a>。</p>
<pre><code class="language-javascript">// 区分 exports 与 module.exports
// 如果覆盖 exports 的值,那么将丢失对 module.exports 的引用,而 module.exports 就是作为公共接口公开的内容
var module = new Module(...);
var exports = module.exports;
</code></pre>
<pre><code class="language-javascript">// CommonJS —— 导出单个模块
// formatTime
function formatTime (){
    // 需要的格式 yyyy-MM-dd hh:mm:ss
    var date = new Date(); // 或者传入一个时间戳
    Y = date.getFullYear() + '-';
    M = (date.getMonth()+1 &lt; 10 ? '0'+(date.getMonth()+1) : date.getMonth()+1) + '-';
    D = date.getDate() + ' ';
    h = date.getHours() + ':';
    m = date.getMinutes() + ':';
    s = date.getSeconds(); 
    console.log(Y+M+D+h+m+s); // 当前时间格式化输出
}
module.exports = formatTime
// requireFT
var requireFT = require('./formatTime') // 当然 .js 可以省略
requireFT() // 2019-08-29 20:33:48

// CommonJS —— 导出多个模块
// func.js
var func1 = () =&gt;{console.log('I am func1')}
var func2 = function(){console.log('I am func2')}
module.exports.func1 = func1;
module.exports.func2 = func2;
// 可简写
module.exports = { // 键值同名可以只写一个
    func1: func1, // func1,
    func2: func2 // func2
}

// requireFunc.js
var requireObj = require('./formatTime')
requireObj.func1(); // I am func1
requireObj.func2(); // I am func2
</code></pre>
<pre><code class="language-javascript">// mod1.js
let name = &quot;ok&quot;; // 字符串是值引用,已经指定了地址
setTimeout(() =&gt; { name = &quot;okk&quot; }, 1000)
module.exports = { name: name }
// exec1.js
const mod1 = require('./mod1')
setTimeout(() =&gt; { console.log(mod1.name); }, 2000) // ok

// mod2.js
let info = { name: &quot;ok&quot;}; // 引用对象在堆内存开辟空间
setTimeout(() =&gt; { info.name = &quot;okk&quot; }, 1000) // 改变了指针
module.exports = { info } // info 赋值的是内存地址
// exec2.js
const mod2 = require('./mod2')
setTimeout(() =&gt; { console.log(mod2.info.name); }, 2000) // okk
</code></pre>
<p>require 是帮助引入模块导出对象的<a href="https://stackoverflow.com/questions/20315434/node-js-asynchronous-module-loading">同步函数</a>。require 查找模块首先会判断是否为核心模块，是则直接返回并停止查找；不是则分类讨论。</p>
<p>当 <code>./</code>、<code>../</code> 或 <code>/</code> 开头的文件有后缀名时，先按指定后缀查找，没有则按 js 文件、json 文件、node 文件的顺序查找。若仍无相应文件，则按目录名查找。</p>
<p>目录名查找 =&gt; 从最近的 node_modules 文件夹查到根目录的 node_modules 文件夹。</p>
<ul>
<li>模块的加载过程</li>
</ul>
<p>模块首次引入时会直接运行一次；模块被多次引入也只会加载一次。因每个模块对象都有一个属性 loaded 表示加载完成的状态。</p>
<pre><code class="language-javascript">/* module 对象的属性 */
module.id 模块的识别符，通常是带有绝对路径的模块文件名。
module.filename 模块的文件名，带有绝对路径。
module.loaded 返回一个布尔值，表示模块是否已经完成加载。
module.parent 返回一个对象，表示调用该模块的模块（程序入口文件的module.parent为null）
module.children 返回一个数组，表示该模块要用到的其他模块。
module.exports 表示模块对外输出的值。
</code></pre>
<p>算法中图结构在遍历时有深度优先搜索和广度优先搜索，模块在引入时采用深度优先搜索。下图加载顺序为 main、a、c、d、e、b。</p>
<img src="https://res.cloudinary.com/dzb9ldnvl/image/upload/v1672310187/blog/zsghost/svg/moduleLoadOrder_buarvg.svg" style="overflow:scroll" />
<ul>
<li>其他模块化 =&gt; AMD 和 CMD</li>
</ul>
<p>AMD 是 Asynchronous Module Definition 移步模块化的缩写，采用异步加载模块。常用的库是 require.js 和 curl.js。</p>
<pre><code class="language-html">&lt;script src=&quot;./lib/require.js&quot; data-main=&quot;./index.js&quot;&gt;&lt;/script&gt;
</code></pre>
<pre><code class="language-js">// index.js
(function(){
  require.config({
    baseUrl: '',
    path: {
      &quot;bar&quot;: &quot;./modules/bar&quot;, // 对应模块的映射关系
      &quot;foo&quot;: &quot;./modules/foo&quot;
    }
  })
  require(['foo'], function(foo){})
})()
</code></pre>
<pre><code class="language-javascript">// bar.js
define(function() {
  const name = &quot;zszs&quot;;
  const age = 21;
  const sayHello = function(){
    console.log(&quot;hi&quot; + name);
  }
  return {
    name: name,
    age: age,
    sayHello: sayHello
  }
})
</code></pre>
<pre><code class="language-javascript">// foo.js
define(['bar'], function(bar){
  console.log(bar.name);
  console.log(bar.age);
  bar.sayHello(&quot;zy&quot;);
})
</code></pre>
<p>CMD 是 Common Module Definition 通用模块定义的缩写，也采用异步加载模块。实现方案是 SeaJS。</p>
<pre><code class="language-html">&lt;script src=&quot;./lib.sea.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  seajs.use('./index.js')
&lt;/script&gt;
</code></pre>
<pre><code class="language-javascript">// index.js
define(function(require, exports, module){
  const foo = require('./modules/foo');
  console.log(foo.name);
  console.log(foo.age)
  console.log(foo.sayHello('zy'))
})
</code></pre>
<pre><code class="language-javascript">// foo.js
define(function(require, exports, module){
  const name = &quot;zs&quot;;
  const age = 21;
  const sayHello = function(name){
    console.log(&quot;hi&quot; + name);
  }
  module.exports = {
    name,
    age,
    sayHello
  }
})
</code></pre>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><h2 id="%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97">内置模块</h2>
<h3 id="file-system">File system</h3>
<p>任何为服务端服务的语言或框架通常会有各自的文件系统。fs 模块用于文件系统交互。</p>
<ul>
<li>fs.existsSync(path) =&gt; 检查传参 path 是否存在；异步 fs.exists 已废弃</li>
</ul>
<p>Node 大部分异步 API 会有回调函数 callback 作为参数，而大部分同步 API 不会。</p>
<pre><code class="language-javascript">// 创建文件夹
const fs = require('fs')
const dirname = './testDirectory'
if(!fs.existsSync(dirname)){
  fs.mkdir(dirname, err =&gt; { console.log(err); });
}
</code></pre>
<ul>
<li>fs.readdir(path[, options], callback) =&gt; 读取目录的内容；回调函数的参数 files 是目录中文件名的数组，不递归向下</li>
</ul>
<pre><code class="language-javascript">// 读取文件夹所有文件
const fs = require('fs')
fs.readdir(&quot;./testDirectory&quot;, (err, files) =&gt; {
  console.log(files)
})
</code></pre>
<ul>
<li>fs.rename(oldPath, newPath, callback) =&gt; 对文件异步重命名；newPath 已经存在的情况下，文件会被覆盖，目录则会抛出错误</li>
</ul>
<pre><code class="language-javascript">// 重命名
const fs = require('fs');
fs.rename(&quot;./files/dirtest&quot;, &quot;./files/dirtestandrename&quot;, err =&gt; {
  console.log(err)
})
</code></pre>
<ul>
<li>fs.readFile(path[, options], callback) =&gt; 异步读取文件的全部内容</li>
</ul>
<p>fs.readFile() 是对 fs.read() 的封装，后者使用流程应先用 fs.stat() or fs.fstat() 获取对象文件信息，再通过 fs.open() 创建文件描述符 fd，最后才能以 fs.read() 读取内容。</p>
<pre><code class="language-javascript">// readFile() 读取文件
const fs = require(&quot;fs&quot;);
fs.readFile(&quot;./files/1.txt&quot;, {encoding: 'utf-8'}, function (err, dataStr) {
  if (err) { return console.log(&quot;读取文件失败!&quot; + err.message); } // 读取成功则 err 的结果为 null, 失败则 dataStr 的结果为 undefine
  return console.log(&quot;读取文件成功!&quot; + dataStr);
});
</code></pre>
<ul>
<li>fs.writeFile(file, data[, options], callback) =&gt; 当 file 是文件名时，异步将数据写入文件，如果文件已存在则替换文件；<a href="https://nodejs.org/api/fs.html#file-system-flags">追加内容</a></li>
</ul>
<pre><code class="language-javascript">// 写入文件内容
const fs = require(&quot;fs&quot;);
fs.writeFile(&quot;./files/toBeWrite.txt&quot;, &quot;Hello node.js!&quot;, function (err) {
  if (err) { return console.log(&quot;文件写入失败&quot; + err.message); } // 文件写入成功 err 值等于 null, 文件写入失败，则 err 的值为错误对象
  console.log(&quot;文件写入成功&quot;);
});
</code></pre>
<pre><code class="language-javascript">// 追加文件内容
const fs = require(&quot;fs&quot;);
fs.writeFile(&quot;./files/toBeWrite.txt&quot;, &quot;\r\nHello node.js!&quot;, {flag: &quot;a&quot;}, function (err) {
  if (err) { return console.log(&quot;文件写入失败&quot; + err.message); } // 文件追加成功 err 值等于 null, 文件追加失败，则 err 的值为错误对象
  console.log(&quot;文件追加成功&quot;);
});
</code></pre>
<ul>
<li>fs.appendFile(path, data[, options], callback) =&gt; 将数据异步附加到文件，如果文件尚不存在则创建文件。data可以是字符串或&lt;Buffer&gt;。</li>
</ul>
<pre><code class="language-javascript">// 追加文件内容
const fs = require(&quot;fs&quot;);
fs.appendFile(&quot;./files/toBeWrite.txt&quot;, &quot;\r\n'data to append'&quot;, function (err) {
  if (err) { return console.log(&quot;文件追加失败&quot; + err.message); } // 文件写入成功 err 值等于 null, 文件写入失败，则 err 的值为错误对象
  console.log(&quot;文件追加成功&quot;);
});
</code></pre>
<blockquote>
<p>文件描述符 file descriptors fd =&gt; POSIX 系统对于每个进程，内核都维护着一张当前打开的文件和资源表格。每个打开的文件都分配了一个称为文件描述符的简单数字标识符。在系统层，所有文件系统操作都使用文件描述符标识和跟踪特点的文件。为简化用户工作，Node 抽象出操作系统之间差异，并为所有打开文件分配一个数字型的文件描述符。</p>
</blockquote>
<pre><code class="language-javascript">const fs = require(&quot;fs&quot;);
const path = require(&quot;path&quot;);
const fdfilepath = path.resolve(__dirname + &quot;/files/fd.txt&quot;);
fs.open(fdfilepath, (err, fd) =&gt; {
  if (err) { return; }
  fs.fstat(fd, (err, info) =&gt; {});
});
const content = &quot;hello fd&quot;;
fs.writeFile(&quot;./files/fd.txt&quot;, content, { flag: &quot;a&quot; }, (err) =&gt; { console.log(err); });
fs.readFile(&quot;./files/fd.txt&quot;, null, (err, data) =&gt; { console.log(data.toString()); }); // &lt;Buffer&gt; =&gt; 16进制是二进制的一种表现形式
</code></pre>
<h3 id="path">Path</h3>
<p>path 模块提供用于处理文件和目录路径的方法，屏蔽不同环境下分隔符的差异。</p>
<ul>
<li>path.basename(path[, ext]) =&gt; 返回最末尾分隔符的后续部分；ext -&gt; 可选的文件扩展名，区分大小写</li>
</ul>
<pre><code class="language-javascript">var path = require(&quot;path&quot;);
console.log(path.extname(&quot;/a/b/c.java&quot;), path.basename(&quot;/a/b/c.java&quot;), path.basename(&quot;/a/b/c.java&quot;, '.java')) // .java c.java c
</code></pre>
<ul>
<li>path.delimiter =&gt; 提供特定于平台的路径分隔符</li>
</ul>
<pre><code class="language-javascript">var path = require(&quot;path&quot;);
console.log(process.env.PATH.split(path.delimiter)) // [...]
</code></pre>
<ul>
<li>path.dirname(path) =&gt; 返回路径目录名称</li>
</ul>
<pre><code class="language-javascript">var path = require(&quot;path&quot;);
console.log(path.dirname('/a/b/c')) // /a/b
</code></pre>
<ul>
<li>path.extname(path) =&gt; 返回路径拓展名</li>
</ul>
<pre><code class="language-javascript">var path = require(&quot;path&quot;);
console.log(path.extname('index.coffee.md')) // .md
</code></pre>
<ul>
<li>path.normalize(path) =&gt; 规范化给定的路径 -&gt; 多个连续的路径段分隔符会被特定于平台的路径段分隔符的单个实例替换</li>
</ul>
<pre><code class="language-javascript">var path = require(&quot;path&quot;);
var pathStr = path.normalize(&quot;a/b//c///d\\\e&quot;);
console.log(pathStr); // a/b/c/d\e
</code></pre>
<ul>
<li>path.parse(path) =&gt; 返回对象，其属性表示路径有效元素</li>
</ul>
<pre><code class="language-javascript">var {parse} = require(&quot;path&quot;);
console.log(parse(&quot;/a/b/c.java&quot;)) // { root: '/', dir: '/a/b', base: 'c.java', ext: '.java', name: 'c' }
</code></pre>
<ul>
<li>path.format(pathObject) =&gt; 把对象转化为一个路径字符串</li>
</ul>
<pre><code class="language-javascript">var {format} = require(&quot;path&quot;);
console.log(format({ root: '/', dir: '/a/b', base: 'c.java', ext: '.java', name: 'c' })) // /a/b/c.java
</code></pre>
<ul>
<li>path.resolve([...paths]) =&gt; 将一系列路径或路径段解析为绝对路径</li>
</ul>
<pre><code class="language-javascript">var path = require('path') // 若不传入 path 则返回当前工作目录的绝对路径
console.log(path.resolve('a/b/c')) // 拼接当前的目录 =&gt; /Users/xieziyi/a/b/c
</code></pre>
<ul>
<li>path.join([...paths]) =&gt; 使用特定于平台的分隔符作为分隔符将所有给定的段连接</li>
</ul>
<pre><code class="language-javascript">var {join} = require('path')
console.log(join('a','/b','../c','/d')) // a/c/d
</code></pre>
<p>两者都有连接字符串的效果，区别在于前者会判断拼接字符串路径是否包含以 / 或 ./ 或 ../ 开头的路径分隔符，并以路径分隔符拼接当前文件所在的路径。</p>
<p>以 / 开头 resolve 和 join 效果一致，./ 或 ../ 则会拼接上当前文件所在位置路径。</p>
<ul>
<li>path.sep =&gt; 提供特定于平台的路径段分隔符</li>
</ul>
<pre><code class="language-javascript">var path = require(&quot;path&quot;);
console.log('a/b/c'.split(path.sep)); // [ 'a', 'b', 'c' ]
</code></pre>
<h3 id="http">Http</h3>
<p>不同于 Tomcat 或 Apache 等容器，http 模块具有创建服务器的功能。</p>
<ul>
<li>http.createServer([options][, requestListener]) =&gt; 创建 Web 服务器</li>
</ul>
<pre><code class="language-javascript">const http = require('node:http');
const server = http.createServer((req, res) =&gt; { // Create a local server
  // 指定编码对于 JSON 来说有些多余 =&gt; 因为 JSON 的默认编码是 UTF-8
  res.writeHead(200, { 'Content-Type': 'application/json; charset=utf-8' });
  res.end(JSON.stringify({ data: 'Hello World!' }));
});
server.listen(8000);
</code></pre>
<ul>
<li>request.setHeader(name, value) =&gt; 为标头对象设置单个标头值</li>
</ul>
<pre><code class="language-javascript">const http = require('node:http');
const server = http.createServer((req, res) =&gt; {
  const body = 'hello world';
  res.setHeader(&quot;Content-Length&quot;, body.length);
  res.setHeader(&quot;Content-Type&quot;, &quot;text/plain&quot;);
  res.setHeader(&quot;Set-Cookie&quot;, &quot;type=ninja&quot;);
  res.statusCode = 200; // response.statusCode =&gt; 使用隐式标头时将发送给客户端的状态代码
  res.statusMessage = 'ok'
  res.end(body);
});
server.listen(8000);
</code></pre>
<ul>
<li>response.writeHead(statusCode[, statusMessage][, headers]) =&gt; 向请求发送响应标头</li>
</ul>
<pre><code class="language-javascript">const http = require('node:http');
const server = http.createServer((req, res) =&gt; {
  const body = 'hello world';
  res.writeHead(200, {
    'Content-Length': Buffer.byteLength(body),
    'Content-Type': 'text/plain'
  })
  .end(body);
});
server.listen(8000);
</code></pre>
<ul>
<li>url.parse(urlString[, parseQueryString[, slashesDenoteHost]]) =&gt; 解析 URL 字符串 -&gt; 路径参数是字符串类型，需要解析、分隔转成对象</li>
</ul>
<pre><code class="language-javascript">var http = require('http');
var url = require('url');
http.createServer(function (req, res) {
  var urlObj = url.parse(req.url, true);
  var queryObj = urlObj.query;
  res.writeHead(200, {'Content-Type': 'text/html'});
  res.write(queryObj.name);
  res.end();
}).listen(8080);
</code></pre>
<ul>
<li>
<p><a href="https://nodejs.org/en/knowledge/HTTP/clients/how-to-access-query-string-parameters/#parsing-with-querystring">解析查询字符串</a> =&gt; <a href="https://stackoverflow.com/questions/29136374/what-the-difference-between-qs-and-querystring">对比 qs 和 query-string</a></p>
</li>
<li>
<p>处理 chunk 的 server</p>
</li>
</ul>
<pre><code class="language-javascript">const http = require(&quot;http&quot;);
const port = 8089;
http
  .createServer((req, res) =&gt; {
    let data = &quot;&quot;;
    req.on(&quot;data&quot;, (chunk) =&gt; {
      data += chunk;
    });
    req.on(&quot;end&quot;, function () {
      let method = req.method,
        headers = JSON.stringify(req.headers),
        httpVersion = req.httpVersion,
        requestUrl = req.url;
      res.writeHead(200, { &quot;content-type&quot;: &quot;text/plain;charset=utf-8&quot; });
      let responseData =
        method + &quot;-&quot; + headers + &quot;-&quot; + httpVersion + &quot;-&quot; + requestUrl;
      res.end(responseData);
    });
  })
  .listen(port, () =&gt; {
    console.log(`server is running at http://127.0.0.1:${port}`);
  });
</code></pre>
<ul>
<li>原生 Node 托管静态资源 =&gt; index.html</li>
</ul>
<pre><code class="language-javascript">const fs = require(&quot;fs&quot;);
const http = require(&quot;http&quot;);
const path = require(&quot;path&quot;);
const server = http.createServer();
server.on(&quot;request&quot;, (req, res) =&gt; {
  let fpath = &quot;&quot;;
  if (req.url === &quot;/&quot;) {
    fpath = path.join(__dirname, &quot;./clock/index.html&quot;);
  } else {
    fpath = path.join(__dirname, &quot;/clock&quot;, req.url);
  }
  fs.readFile(fpath, &quot;utf8&quot;, (err, dataStr) =&gt; {
    if (err) return res.end(&quot;404 Not found&quot;);
    res.end(dataStr);
  });
});
server.listen(80, () =&gt; {
  console.log(&quot;server running at http://127.0.0.1&quot;);
});
</code></pre>
<h3 id="stream">Stream</h3>
<blockquote>
<p>A stream is an abstract interface for working with streaming data in Node.js. The node:stream module provides an API for implementing the stream interface.</p>
</blockquote>
<p>There are many stream objects provided by Node.js. For instance, a request to an HTTP server and process.stdout are both stream instances.</p>
<p>Streams can be readable, writable, or both. All streams are instances of EventEmitter.</p>
<p>通常开发中不会直接使用偏底层的流模块，而是选择其的二次封装。http 中的 res 和 req 流对象。文件转化成流对象 =&gt; fs 模块的 createReadStream 和 createWriteStream；zlib 和 crypto 模块是对转化流的应用。</p>
<p>stram 主要用于 IO 操作 -&gt; 网络请求、文件处理，处理端到端数据交换</p>
<p>Node 中处理数据的传统模式是缓冲模式，即程序将所需处理得资源从磁盘全部加载入内存缓冲区，待所有数据全部加载后，再进行后续处理。在流模式下，程序只要加载到数据就会立即进行处理，资源将会被切块传递给调用方。后者占用内存更小，且调用端可能快得到相应。</p>
<p>Node 中的流模块主要用作向其他模块提供流接口的 API。流在结构上可分为可读流 Writable、可写流 Readabale、（可读可写）双工流 Duplex 和转换流 Transform。</p>
<p>Readable 实现 readable、resume、error、data、end、close 事件；Writable 实现 close、finish、drain、error 事件；Duplex 派生 transform 和 passThrough 流。</p>
<p>流之间的交互上实现了 pipe 管道</p>
<pre><code class="language-js">/* Readable 可读流 */
const { Readable } = require(&quot;stream&quot;);
new Readable({
  highWaterMark: 16 * 1024, // 可读流缓冲区最大容量
  encoding: null,
  objectMode: false, // JS 对象解析为可读流 =&gt; 一般情况下流对象只处理字符串和 buffer
  read: function () {}, // 将数据推送至缓冲区 =&gt; 内部调用
});
class myReadableStream extends Readable {
  constructor(options, data) {
    super(options); // options 用于初始化父类的构造函数
    this.data = data;
  }
  _read() {
    // 往缓冲区推数据 =&gt; 此私有方法不可 static
    this.push(this.data);
    this.push(null); // null =&gt; 信号 -&gt; 可读流结束
  }
}

const r = new myReadableStream(
  { encoding: &quot;utf-8&quot; },
  &quot;Readable Stream Test Ok&quot;
);
// r.on(&quot;readable&quot;, () =&gt; { console.log(r.read()); }); // 此 read 是向缓冲区读取数据
// r.on(&quot;readable&quot;, () =&gt; { // 非流动模式 =&gt; 调用 read() =&gt; 自由度高
//   let chunk;
//   while ((chunk = r.read(1))) {
//     console.log(chunk);
//   }
// });
r.on(&quot;data&quot;, (chunk) =&gt; { console.log(chunk)}); // 流动模式
r.on(&quot;end&quot;, () =&gt; { console.log(&quot;Read Data End&quot;)}); // end 事件 =&gt; 监听可读流完全消费后执行回调
r.on(&quot;error&quot;, () =&gt; { console.log(&quot;Read Data Error&quot;)}); // error 事件 =&gt; 捕获可读流出现的错误
</code></pre>
<pre><code class="language-js">/* Writable 可写流 */
const { Writable } = require(&quot;stream&quot;);
const fs = require(&quot;fs&quot;);
const writableTestObj = {
  path: &quot;./writableTestObj.txt&quot;,
  content: &quot;writableTestObj&quot;,
};
class myWritableStream extends Writable {
  constructor(options) {
    super({ ...options, objectMode: true });
  }
  _write(chunk, encoding, cb) {
    fs.writeFile(chunk.path, chunk.content, { encoding }, (err) =&gt; {
      cb();
    });
  }
}
const w = new myWritableStream();
w.on(&quot;finish&quot;, () =&gt; {
  console.log(&quot;DONE&quot;);
});
w.on(&quot;error&quot;, () =&gt; {
  console.log(err);
});
w.write(writableTestObj);
w.end();
</code></pre>
<pre><code class="language-js">/**
 * 前端资源保存服务器
 * http module =&gt; req 可读流、res 可写流
 */
const http = require(&quot;http&quot;);
const fs = require(&quot;fs&quot;);
const server = http.createServer((req, res) =&gt; {
  const w = fs.createWriteStream(&quot;./w.jpeg&quot;);
  req.on(&quot;data&quot;, (chunk) =&gt; { // 可写流 end 事件不能写在 data 事件中 =&gt; 文件会多次触发 data 事件
    w.write(chunk);
  });
  req.on(&quot;end&quot;, () =&gt; {
    w.end();
    res.end(&quot;SAVE SUCCESS&quot;);
  });
  w.on(&quot;error&quot;, (err) =&gt; {
    console.log(err);
    res.end(&quot;SAVE FAILED&quot;);
  });
});
server.listen(3000);
</code></pre>
<p>pipe 是 Node 为 Stream 实现的接口，连接可读流与可写流 =&gt; 可读流.pipe(可写流)，可读流数据自动进入可写流。数据流动由 pipe 管理，无需手动调用 read 和 write 方法。</p>
<pre><code class="language-js">/**
 * 前端资源保存服务器
 * http module =&gt; req 可读流、res 可写流
 */
const http = require(&quot;http&quot;);
const fs = require(&quot;fs&quot;);
const { pipeline } = require(&quot;stream&quot;);
const server = http.createServer((req, res) =&gt; {
  const w = fs.createWriteStream(&quot;./w.jpeg&quot;);
  pipeline(req, w, (err) =&gt; {
    console.log(err);
    res.end(&quot;SAVE FAILED&quot;);
  });
  res.end(&quot;SAVE SUCCESS&quot;);
});
server.listen(3000);
</code></pre>
<p>转换流内部分别实现可写缓冲区和可读缓冲区，可写缓冲区对应外部的可读流，通过 wirte 方法转换流，将可读流数据写入内部的可写缓冲区；转换流的可写缓冲区对应外部的可写流，通过监听 data 事件，可写流可以获取到可读缓冲区的内容。在转换流内部通过私有的 <code>_transform</code> 方法传递数据。转换流的核心就是 <code>_transform</code> 方法的实现。在这个函数中可对数据进行操作，并将转换后的数据通过 push 方法推送到可读缓冲区。</p>
<pre><code class="language-js">/* 文件拷贝且字母大写 */
const {Transform, pipeline} = require(&quot;stream&quot;);
const fs = require(&quot;fs&quot;);
class myStream extends Transform{
  constructor(options){
    super(options)
  }
  _transform(chunk, encoding,cb){
    this.push(chunk.toString().toUpperCase());
    cb();
  }
}
const r = fs.createReadStream(&quot;./r.txt&quot;);
const w = fs.createWriteStream(&quot;./w.txt&quot;);
const t = new myStream();
// r.pipe(t).pipe(w)
pipeline(r, t, w, (err) =&gt; {console.log(err);})
</code></pre>
<p>转换流除 transform 方法还有 flush 方法，其会在整个数据流结束之前被调用。这就提供了接口，可以在数据流的尾部向可写流推送额外数据。</p>
<pre><code class="language-js">/* 过滤数据 =&gt; 将符合条件的数据写入指定文件且计算通过率 */
const { Transform, pipeline, Readable } = require(&quot;stream&quot;);
const fs = require(&quot;fs&quot;);
const testArr = [
  { name: &quot;A&quot;, id: 1 },
  { name: &quot;B&quot;, id: 2 },
  { name: &quot;C&quot;, id: 3 },
];
class myStream extends Transform {
  constructor(options) {
    super({ ...options, objectMode: true });
    this.counter = 0;
    this.total = 0;
  }
  _transform(chunk, encoding, cb) {
    this.total += chunk.length; // 遍历数组的长度
    for (let item of chunk) {
      if (item.id &gt; 1) {
        this.push(JSON.stringify(item));
        this.push(&quot;\n&quot;);
        this.counter++;
      }
    }
    cb();
  }
  _flush(cb) {
    this.push(&quot;---by ok---&quot;);
    this.push(&quot;\n&quot;);
    this.push(`---${this.counter}/${this.total}---`);
    cb();
  }
}

const r = new Readable({
  objectMode: true,
  read() {
    this.push(testArr);
    this.push(null);
  },
});
const t = new myStream();
const w = fs.createWriteStream(&quot;./w.txt&quot;);
pipeline(r, t, w, (err) =&gt; {
  console.log(err);
});
</code></pre>
<h3 id="buffer">Buffer</h3>
<p>缓冲区类似一个整数数组，其元素为十六进制的两位数。在计算机中的二进制都会以十六进制显示，所以尽管存储的是二进制，显示的却还是十六进制。</p>
<p>Buffer 创建内存中空间的元素范围是 00 - ff，所以实际上一个元素就表示内存中的一个字节。</p>
<pre><code class="language-js">00-ff =&gt; 0-255 =&gt; 00000000-11111111 =&gt; 8bit =&gt; 1byte
</code></pre>
<p>Buffer 的内存不是通过 JS 分配，而是在底层通过 C++ 申请的，是对应 V8 堆内存之外的一块原始内存。</p>
<p>缓冲区用于操作二进制数据。后端通常需要读取和操作长文本，处理前端传递的图片和大文件，而这些对象都是二进制的。前端对二进制数据的操作需求不多，可以选择字符串来进行处理，但字符串是不可变的，所有对字符串的操作都会生成新字符串，而这种结果在耗时的同时还会占用内存。缓冲区的二进制数据可以像操作数组般的直接操作数据源。</p>
<ul>
<li>Buffer.alloc(size[, fill[, encoding]]) =&gt; 返回 Buffer 实例</li>
</ul>
<p>缓冲区的大小一旦确定则不能修改，实际上是对内存的直接操作，在内存中分配出连续的长度作为确定的空间。与数组不同，但内存空间不连续会导致性能较差。</p>
<pre><code class="language-js">const buf1 = Buffer.alloc(10); // 创建一个长度为 10、且用 0 填充的 Buffer
const buf2 = Buffer.alloc(10, 1); // 创建一个长度为 10、且用 0x1 填充的 Buffer 
</code></pre>
<ul>
<li>Buffer.from(?) =&gt; 返回 Buffer 实例</li>
</ul>
<p>Buffer.from(?) 和 Buffer.alloc(size) 都可新建 Buffer 实例，前者是静态初始化，后者是动态初始化。</p>
<pre><code class="language-javascript">console.log(Buffer.from('Hello ok').length) // 占用内存大小;一个英文占1字节 - 8
console.log(Buffer.from('Hello 紫').length) // 占用内存大小;一个汉字占3字节 - 9
</code></pre>
<pre><code class="language-js">const buf4 = Buffer.from([1, 2, 3]); // 创建包含 [0x1, 0x2, 0x3] 的 Buffer
console.log(Buffer.from(Buffer.from('Hello zs')), Buffer.compare(Buffer.from('Hello zs'), Buffer.from(Buffer.from('Hello zs')))) // &lt;Buffer 48 65 6c 6c 6f 20 7a 73&gt; 0 =&gt; 拷贝传入的 Buffer 实例数据
const buf5 = Buffer.from('tést'); // 创建包含 UTF-8 字节 [0x74, 0xc3, 0xa9, 0x73, 0x74] 的 Buffer
const buf6 = Buffer.from('tést', 'latin1'); // 创建包含 Latin-1 字节 [0x74, 0xe9, 0x73, 0x74] 的 Buffer
</code></pre>
<blockquote>
<p>动态初始化 =&gt; 数组的定义和分配空间赋值的操作分开进行；静态初始化 =&gt; 数组在初始化时显式指定每个数组元素的初始值。</p>
</blockquote>
<ul>
<li>Buffer.allocUnsafe(size) =&gt; 返回 Buffer 实例</li>
</ul>
<p>Buffer.allocUnsafe(size) 返回一个指定大小的 Buffer 实例,此方法比调用既分配空间又清空数据的 Buffer.alloc() 更快。但是 Buffer 实例不会被初始化则可能包含敏感的旧数据,需要使用 fill() 或 write() 重写。</p>
<pre><code class="language-javascript">const buf3 = Buffer.allocUnsafe(10); // 创建一个长度为 10 且未初始化的 Buffer
</code></pre>
<p>Buffer.allocUnsafeSlow(size) 适用情况 =&gt; 不确定的时刻从池中保留一小块内存</p>
<ul>
<li>
<p>buf.write(string[, offset[, length]][, encoding]) =&gt; 将字符串写入 buf</p>
</li>
<li>
<p>buf.toString([encoding[, start[, end]]]) =&gt; 将 Buffer 实例解码成字符串</p>
</li>
</ul>
<h3 id="events">Events</h3>
<p>所有流都是 EventEmitter 的实例。EventEmitter 主要作用是在 Node 中提供一种函数调用的模式，即观察者模式，给事件注册一个或多个监听器。EventEmitter 核心 API =&gt; on 注册监听器、once 注册一次性监听器、emit 触发事件，同步调用监听器、removeListener 移除某事件监听器。</p>
<pre><code class="language-js">const {EventEmitter} = require(&quot;events&quot;);
const ee = new EventEmitter();
ee.on(&quot;eventTest&quot;,()=&gt;{console.log(&quot;ok&quot;);});
ee.on(&quot;eventTest&quot;,()=&gt;{console.log(&quot;okk&quot;);});
ee.prependListener(&quot;eventTest&quot;,function yes(){console.log(&quot;yes&quot;);}) // prependListener =&gt; 监听器插入数组开头
ee.emit(&quot;eventTest&quot;); // 同步调用 =&gt; 监听器注册顺序就是执行顺序 =&gt; 要求在触发前注册好监听器
console.log(ee.listeners(&quot;eventTest&quot;));
</code></pre>
<pre><code class="language-js">const {EventEmitter} = require(&quot;events&quot;);
const ee = new EventEmitter();
process.nextTick(()=&gt;{ // nextTick 执行会延迟到同步代码之后
  ee.emit(&quot;eventTest&quot;)
})
ee.on(&quot;eventTest&quot;,()=&gt;{console.log(&quot;ok&quot;);});
</code></pre>
<pre><code class="language-js">const { EventEmitter } = require(&quot;events&quot;);
const fs = require(&quot;fs&quot;);
function mySearch(param) {
  const ee = new EventEmitter();
  const r = fs.createReadStream(&quot;./r.txt&quot;, { encoding: &quot;utf-8&quot; });
  r.on(&quot;data&quot;, (chunk) =&gt; {
    if (chunk.match(new RegExp(param))) {
      ee.emit(&quot;found&quot;);
    } else {
      ee.emit(&quot;unfound&quot;);
    }
  }).on(&quot;error&quot;, () =&gt; {
    ee.emit(&quot;error&quot;, error);
  });
  return ee;
}
module.exports = mySearch;
</code></pre>
<pre><code class="language-js">const ms = require(&quot;./utils&quot;);
ms(&quot;okk&quot;).on(&quot;found&quot;,()=&gt;{console.log(&quot;found&quot;);}).on(&quot;unfound&quot;,()=&gt;{console.log(&quot;unfound&quot;);}).on(&quot;error&quot;,(err)=&gt;{console.log(err);})
</code></pre>
<h3 id="crypto">Crypto</h3>
<blockquote>
<p>The crypto module provides cryptographic functionality that includes a set of wrappers for OpenSSL's hash, HMAC, cipher, decipher, sign, and verify funcs.</p>
</blockquote>
<p>message digest algorithm 消息摘要算法或 hash function 散列函数是将任意长度的输入数据映射到固定长度的输出的过程。输出通常被称为散列值、散列码或消息摘要。</p>
<ul>
<li>crypto.createHash(algorithm[, options]) =&gt; 创建并返回 Hash 对象</li>
</ul>
<p>该 Hash 对象可用于以给定算法生成哈希摘要。可选选项参数控制流行为。</p>
<p>algorithm 取决于平台上 OpenSSL 版本所支持的算法。</p>
<pre><code class="language-shell">$ openssl list-message-digest-algorithms
$ openssl list -digest-algorithms
$ openssl version
</code></pre>
<ul>
<li>hash.update(data[, inputEncoding]) =&gt; 用给定的数据更新哈希</li>
</ul>
<p>当 data 传入的是字符串，且未设置输入编码 inputEncoding 时，默认使用 utf-8。</p>
<p>当 data 传入的是 Buffer、TypedArray 或 DataView 时，inputEncoding 可忽略。</p>
<p>update 方法可以多次调用，以更新摄取流数据，例如来自文件读取流的缓冲区。</p>
<ul>
<li>hash.digest([encoding]) =&gt; 计算数据的摘要</li>
</ul>
<p>encoding 可以是 hex、latin1 或 base64。v6.4.0	中将 latin1 作为 binary 的别名。</p>
<p>提供 encoding 会返回字符串，否则返回 Buffer 实例。</p>
<p>调用完 digest 方法后的 Hash 对象不可再使用，否则会抛出异常。</p>
<pre><code class="language-js">const crypto = require('crypto');
const md5 = crypto.createHash('md5');
const message = 'hello crypto';
const digest = md5.update(message, 'utf8').digest('hex'); 
console.log(digest, digest.length); // 2384190895f6fa3de5b7c458532c8d75 32
</code></pre>
<blockquote>
<p><a href="https://zh.m.wikipedia.org/zh-cn/HMAC">HMAC</a> 有时扩展为 keyed-hash message authentication code 密钥散列消息认证码，或 hash-based message authentication code 散列消息认证码，是一种通过特别计算方式之后产生的消息认证码 MAC。使用密码散列函数，同时结合一个加密密钥。可以用来保证资料的完整性，同时可以用来作某个消息的身份验证。</p>
</blockquote>
<ul>
<li>crypto.createHmac(algorithm, key[, options]) =&gt; 返回特定的 Hmac 对象</li>
</ul>
<p>创建并返回使用给定算法和密钥的 Hmac 对象。可选选项参数控制流行为。</p>
<pre><code class="language-js">const crypto = require(&quot;crypto&quot;);
const hmac = crypto.createHmac(&quot;sha256&quot;, &quot;secret key&quot;);
const res = hmac.update(&quot;hello hmac&quot;).digest(&quot;hex&quot;);
console.log(res);
</code></pre>
<p>key 用于生成加密的 HMAC 哈希。若 key 是 <a href="https://nodejs.org/dist/latest-v16.x/docs/api/crypto.html#class-keyobject">KeyObject</a>，其 type 必须为 secret。</p>
<pre><code class="language-js">// hmac.js
const { createReadStream } = require(&quot;fs&quot;);
const { createHmac } = require(&quot;crypto&quot;);
const { argv } = require(&quot;process&quot;);
const filename = argv[2];
const hmac = createHmac(&quot;sha256&quot;, &quot;hello hmac&quot;);
console.log(hmac);
const input = createReadStream(filename);
input.on(&quot;readable&quot;, () =&gt; {
  const data = input.read();
  if (data) hmac.update(data);
  else {
    console.log(`${hmac.digest(&quot;hex&quot;)} ${filename}`);
  }
});
</code></pre>
<pre><code class="language-js">$ node &quot;/Users/.../hmac.js&quot; hmac.js
Hmac {
  _options: undefined,
  [Symbol(kHandle)]: Hmac {},
  [Symbol(kState)]: { [Symbol(kFinalized)]: false }
}
961f862e87d5ef0bf2b4d0d826157473484b20caa7dca746e2764624dee9b00d hmac.js
</code></pre>
<ul>
<li>crypto.randomBytes(size[, callback]) =&gt; 生成加密的强伪随机数据</li>
</ul>
<p>size 为生成的字节数，不得大于 2 ** 31 - 1。</p>
<p>回调函数未提供时，同步生成随机字节并以缓冲区返回；回调函数提供时，会被异步调用生成字节。该回调函数包含 err 和 buf 两个参数。</p>
<p>err 为错误发生时的 Error 对象，buf 为生成字节的缓冲区。</p>
<pre><code class="language-js">const { randomBytes } = require('crypto');
randomBytes(256, (err, buf) =&gt; {
  if (err) throw err;
  console.log(`${buf.length} bytes of random data: ${buf.toString('hex')} =&gt; Async`);
});
const buf = randomBytes(256);
console.log(`${buf.length} bytes of random data: ${buf.toString('hex')} =&gt; Sync`);
</code></pre>
<ul>
<li>Public-key cryptography &amp; Symmetric-key algorithm</li>
</ul>
<p>在明文和密文之间通过指定算法互相转换时，可通过引入密钥来增强安全性。根据加密和解密时所用的秘钥是否相同，可以将加密算法分为对称加密与非对称加密。</p>
<p>公开密钥加密也称为非对称式加密，其公钥用作加密，私钥则用作解密。公钥可任意向外公开或发布；私钥不可以公开，必须严格保管。RSA、ElGamal、DSA...</p>
<p>对称密钥加密要求在加密和解密时使用相同的密钥。对称加密的速度比公钥加密快很多。AES、DES、Blowfish、IDEA...</p>
<ul>
<li>crypto.createCipheriv(algorithm, key, iv[, options]) =&gt; 返回 Cipher 对象</li>
</ul>
<p>使用给定的算法、密钥和初始化向量创建并返回一个 Cipher 对象。</p>
<blockquote>
<p>The key is the raw key used by the algorithm and iv is an initialization vector. Both arguments must be 'utf8' encoded strings, Buffers, TypedArray, or DataViews. The key may optionally be a KeyObject of type secret. If the cipher does not need an initialization vector, iv may be null.</p>
</blockquote>
<p>初始化向量应该是不可预测且唯一的，在理想情况下甚至是加密随机的。初始化向量不必严格保管，通常会添加到未加密的明文。</p>
<p><a href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> 的区块长度固定为 128 比特，密钥长度则可以是 128，192 或 256 比特。</p>
<ul>
<li>crypto.createDecipheriv(algorithm, key, iv[, options])</li>
</ul>
<p>通过指定条件创建并返回一个 Decipher 对象。可选参数 options 控制流的行为。</p>
<ul>
<li>cipher.update(data[, inputEncoding][, outputEncoding])</li>
</ul>
<p>通过 data 更新 Cipher 对象。inputEncoding 指定时，data 是字符串类型。未提供 inputEncoding 时，data 必须时 Buffer、TypedArray 或者 DataView。若 data 是 Buffer、TypedArray 或者 DataView，输入编码格式可忽略。</p>
<p>输出编码格式指定时返回字符串；未提供输出编码格式则会返回一个缓冲区。</p>
<p>update 方法可在 final 方法前调用多次并传入新的 data。final 方法调用后再执行 update 会抛出异常。</p>
<pre><code class="language-js">const crypto = require(&quot;crypto&quot;);
const key = crypto.randomBytes(192 / 8);
const iv = crypto.randomBytes(128 / 8);
const algorithm = &quot;aes192&quot;;
function encrypt(text) {
  const cipher = crypto.createCipheriv(algorithm, key, iv);
  cipher.update(text);
  return cipher.final(&quot;hex&quot;);
}

function decrypt(encrypted) {
  const decipher = crypto.createDecipheriv(algorithm, key, iv);
  decipher.update(encrypted, &quot;hex&quot;);
  return decipher.final(&quot;utf8&quot;);
}

const content = &quot;hello&quot;;
const crypted = encrypt(content);
const decrypted = decrypt(crypted);
console.log(crypted, decrypted);
</code></pre>
<ul>
<li>cipher.final([outputEncoding])</li>
</ul>
<p>返回 Cipher 对象的值。指定 outputEncoding 时返回字符串，否则返回缓冲区。</p>
<p>final 方法被调用后，Cipher 对象不再用作加密数据，重复调用多次 final 方法会抛出异常。</p>
<ul>
<li>crypto.scryptSync(password, salt, keylen[, options])</li>
</ul>
<p>返回缓冲区。提供同步的 scrypt 实现。scrypt 是一个基于密码的密钥派生函数。</p>
<blockquote>
<p>In cryptography, a salt is random data that is used as an additional input to a one-way function that hashes data, a password or passphrase. Salts are used to safeguard passwords in storage. <a href="https://en.wikipedia.org/wiki/Salt_(cryptography)">wiki</a></p>
</blockquote>
<p>尽可能的选择具有唯一性的 salt，推荐 salt 是至少 16 bytes 的随机数。</p>
<p>keylen 表示密钥的长度，必须是数字。</p>
<pre><code class="language-js">const { scryptSync } = require(&quot;crypto&quot;);
const key1 = scryptSync(&quot;hello password&quot;, &quot;hello salt&quot;, 64);
const key2 = scryptSync(&quot;hello password&quot;, &quot;hello salt&quot;, 64, { N: 256 });
console.log(key1.toString(&quot;hex&quot;), key2.toString(&quot;hex&quot;));
</code></pre>
<h3 id="process">Process</h3>
<ul>
<li>process.argv =&gt; 返回命令行启动 Node 进程时所传递的参数数组</li>
</ul>
<p>数组元素依次为 process.execPath，正在执行的文件路径和附加的命令行参数。</p>
<pre><code class="language-js">const { argv } = require('process');
argv.forEach((val, index) =&gt; {
  console.log(`${index}: ${val}`);
});
</code></pre>
<p>process.argv0 属性存储 Node 启动时传递 argv[0] 的原始值的只读副本。</p>
<pre><code class="language-js">process.execPath.split(&quot;/&quot;).pop() == process.argv0
</code></pre>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><h2 id="framework">Framework</h2>
<h3 id="koa2">Koa2</h3>
<p>Express 内置捆绑许多函数，而 <a href="http://koajs.cn/">Koa</a> 轻量到只剩基本功能，当需要的时候再通过适合的中间件 <a href="https://github.com/koajs/koa/wiki">Middleware</a> 来搭配组合。可通过 <a href="https://github.com/i5ting/koa-generator#readme">koa-generator</a> 脚手架快速搭建。</p>
<ul>
<li>Hello World</li>
</ul>
<pre><code class="language-shell">$ npm install --save koa
</code></pre>
<p>引入 Koa 模块并创建 Koa 实例 app。Web 请求会经过 <code>app.use()</code> 函数的处理。</p>
<pre><code class="language-javascript">const Koa = require('koa');
const app = new Koa();
app.use(async ctx =&gt; { ctx.body = 'Hello World'; });
app.listen(3000);
</code></pre>
<ul>
<li>Koa 洋葱模型 onion model</li>
</ul>
<blockquote>
<p>await next() divides each middleware into pre-operation, other middleware operations and post-operation.</p>
</blockquote>
<p>代码运行到 <code>next()</code> 会暂停当前，执行后续中间件。<code>next()</code> 返回 Promise 的实例，使用 await 是欲以同步的方式等待 Promise 实例的执行完成。嵌套的 Promise 就像洋葱的模型，直到 await 返回最内层 Promise 的 resolve 值。</p>
<pre><code class="language-javascript">Promise.resolve(middleware1(context, async() =&gt; {
  return Promise.resolve(middleware2(context, async() =&gt; {
    return Promise.resolve(middleware3(context, async() =&gt; {
      return Promise.resolve();
    }));
  }));
}))
.then(() =&gt; { console.log('end'); });
</code></pre>
<pre><code class="language-javascript">const Koa = require('koa');
let app = new Koa();

const middleware1 = async (ctx, next) =&gt; { console.log(1); await next(); console.log(6); }
const middleware2 = async (ctx, next) =&gt; { console.log(2); await next(); console.log(5); }
const middleware3 = async (ctx, next) =&gt; { console.log(3); await next(); console.log(4); }

app.use(middleware1).use(middleware2).use(middleware3);
app.use(async(ctx, next) =&gt; { ctx.body = 'hello world' })
app.listen(3000)
// Output 1, 2, 3, 4, 5, 6
</code></pre>
<pre><code class="language-javascript">const Koa = require('koa');
let app = new Koa();

const p = function(args) {
  return new Promise(resolve =&gt; { setTimeout(() =&gt; { console.log(args); resolve(); }, 100); });
};

const middleware1 = async (ctx, next) =&gt; {
  await p(1);
  // await next();
  next();
  console.log(6);
};

const middleware2 = async (ctx, next) =&gt; {
  await p(2);
  // await next();
  next();
  console.log(5);
};

const middleware3 = async (ctx, next) =&gt; {
  await p(3);
  // await next();
  next();
  console.log(4);
};

app.use(middleware1).use(middleware2).use(middleware3);
app.use(async(ctx, next) =&gt; { ctx.body = 'hello world' })
app.listen(3000)
// Output: 1, 6, 2, 5, 3, 4
</code></pre>
<p><a href="https://github.com/koajs/compose/blob/master/index.js">koajs/compose</a> 模块实现中间件的执行。<code>dispatch(0)</code> 的执行表示首个中间件函数 fn 取 middleware[0]。middleware 数组维护的是通过 <code>app.use()</code> 压入的中间件。中间件执行时的传参分别是上下文和 next。</p>
<p><code>next()</code> 执行即是调用 <code>dispatch(i)</code> 函数，所以遇见函数 next 的逻辑是执行下一个中间件。</p>
<ul>
<li>Middleware =&gt; <a href="https://github.com/koajs/router/blob/master/API.md">koa-router</a></li>
</ul>
<pre><code class="language-shell">$ npm install @koa/router
</code></pre>
<pre><code class="language-javascript">const Koa = require('koa');
const Router = require('@koa/router');
const app = new Koa();
const router = new Router();
router.get('/', async (ctx, next) =&gt; {
  console.log(&quot;@koa/router get request =&gt; &quot;,`${ctx.method} ${ctx.url}`)
  ctx.body = 'Hello World';
  await next();
});
app.use(router.routes()).use(router.allowedMethods());
app.listen(3000);
</code></pre>
<ul>
<li>Middleware =&gt; <a href="https://www.npmjs.com/package/koa-bodyparser">koa-bodyparser</a></li>
</ul>
<p>Koa 是先经过业务路由，再处理中间件；而 Express 是先经过中间件，如果中间件验证不通过就不会处理业务。<code>app.use(bodyParser());</code> 放在路由处理之前。</p>
<pre><code class="language-shell">$ npm install koa-bodyparser
</code></pre>
<ul>
<li>Middleware =&gt; <a href="https://www.npmjs.com/package/@koa/cors">@koa/cors</a></li>
</ul>
<p>@koa/cors 根据简单请求、预检请求分别对 CORS 头进行不同的处理。</p>
<pre><code class="language-shell">$ npm install @koa/cors --save
</code></pre>
<pre><code class="language-javascript">// 结合 @koa/cors 与 koa-bodyParser
var Koa = require('koa');
const cors = require('koa-cors');
var bodyParser = require('koa-bodyparser'); // 获取post请求的参数
var app = new Koa();
app.use(bodyParser()).use(cors());

app.use(async ctx =&gt; {
  // the parsed body will store in ctx.request.body
  // if nothing was parsed, body will be an empty object {}
  ctx.body = ctx.request.body;
});

app.listen(3000);
</code></pre>
<ul>
<li>Middleware =&gt; <a href="https://www.npmjs.com/package/koa-static">koa-static</a> &amp; <a href="https://www.npmjs.com/package/koa-mount">koa-mount</a></li>
</ul>
<pre><code class="language-shell">$ npm install koa-static
$ npm install koa-mount
</code></pre>
<pre><code class="language-javascript">const Koa = require(&quot;koa&quot;);
const path = require(&quot;path&quot;);
const server = require(&quot;koa-static&quot;); // 搭建静态服务
const mount = require(&quot;koa-mount&quot;); // 指定静态服务的请求前缀
let app = new Koa();

const staticPath = path.resolve(__dirname, &quot;static&quot;);
const staticServer = server(staticPath, {
  setHeaders: (res, path, stats) =&gt; {
    if (path.indexOf(/[jpg|png|gif|jpeg]/) !== -1) {
      console.log(stats);
      res.setHeader(&quot;Cache-Control&quot;, [&quot;private&quot;, &quot;max-age=60&quot;]);
      res.setHeader(&quot;Test-Static-Stats-Birthtime&quot;, stats.birthtime); // 自定义响应头
    }
  },
});

app.use(mount(&quot;/supdir&quot;, staticServer));
app.listen(3000);
</code></pre>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><h2 id="third-party-modules">Third Party Modules</h2>
<h3 id="project-development">project development</h3>
<h3 id="analysis-test">analysis test</h3>
<ul>
<li><a href="https://www.npmjs.com/package/esprima">esprima</a> =&gt; 对 JavaScript 做词法或语法分析的工具 -&gt; <a href="https://esprima.org/demo/parse.html">online site</a></li>
</ul>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><h2 id="%E7%BB%93%E6%9D%9F">结束</h2>
<p>本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh"> CC BY-SA 4.0 </a>协议，转载请注明出处！</p>
<!--kg-card-end: markdown-->
    </section>

    <section class="article-comments gh-canvas">
        
        <script src="https://utteranc.es/client.js"
        repo="Zairesinatra/comments-by-utterances"
        issue-term="pathname"
        theme="photon-dark"
        crossorigin="anonymous"
        async>
        </script>
    </section>

</article>
</main>

    <section class="footer-cta outer">
        <div class="inner">
            <h2 class="footer-cta-title">Sign up for more like this.</h2>
            <a class="footer-cta-button" href="index.html#/portal" data-portal>
                <div class="footer-cta-input">Enter your email</div>
                <span>Subscribe</span>
            </a>
        </div>
    </section>



            <aside class="read-more-wrap outer">
                <div class="read-more inner">
                        
<article class="post-card post">

    <a class="post-card-image-link" href="../vim-neovim/index.html">

        <img class="post-card-image"
            srcset="../content/images/size/w1000/2023/03/ScenicViewOfBeachDuringDaytime.jpg 1000w"
            sizes="(max-width: 1000px) 400px, 800px"
            src="../content/images/size/w600/2023/03/ScenicViewOfBeachDuringDaytime.jpg"
            alt="Scenic View Of Beach During Daytime"
            loading="lazy"
        />


    </a>

    <div class="post-card-content">

        <a class="post-card-content-link" href="../vim-neovim/index.html">
            <header class="post-card-header">
                <div class="post-card-tags">
                </div>
                <h2 class="post-card-title">
                    Vim &amp; Neovim
                </h2>
            </header>
                <div class="post-card-excerpt">Vim ninjas count every keystroke!</div>
        </a>

        <footer class="post-card-meta">
            <time class="post-card-meta-date" datetime="2022-12-12">Dec 12, 2022</time>
                <span class="post-card-meta-length">19 min read</span>
        </footer>

    </div>

</article>
                        
<article class="post-card post">

    <a class="post-card-image-link" href="../design-patterns/index.html">

        <img class="post-card-image"
            srcset="../content/images/size/w1000/2023/03/SixHalogenBulbs.jpg 1000w"
            sizes="(max-width: 1000px) 400px, 800px"
            src="../content/images/size/w600/2023/03/SixHalogenBulbs.jpg"
            alt="Six Halogen Bulbs"
            loading="lazy"
        />


    </a>

    <div class="post-card-content">

        <a class="post-card-content-link" href="../design-patterns/index.html">
            <header class="post-card-header">
                <div class="post-card-tags">
                </div>
                <h2 class="post-card-title">
                    Design Patterns And ...
                </h2>
            </header>
                <div class="post-card-excerpt">"A good programmer is someone who always looks both ways before crossing a one-way street." - Doug Linder</div>
        </a>

        <footer class="post-card-meta">
            <time class="post-card-meta-date" datetime="2022-08-08">Aug 8, 2022</time>
                <span class="post-card-meta-length">35 min read</span>
        </footer>

    </div>

</article>
                        
<article class="post-card post">

    <a class="post-card-image-link" href="../g-toc-css/index.html">

        <img class="post-card-image"
            srcset="../content/images/size/w1000/2023/03/GlassBottleFilledWithBlackStrawonBrownWoodenTable.jpg 1000w"
            sizes="(max-width: 1000px) 400px, 800px"
            src="../content/images/size/w600/2023/03/GlassBottleFilledWithBlackStrawonBrownWoodenTable.jpg"
            alt="Glass Bottle Filled With Black Straw on Brown Wooden Table"
            loading="lazy"
        />


    </a>

    <div class="post-card-content">

        <a class="post-card-content-link" href="../g-toc-css/index.html">
            <header class="post-card-header">
                <div class="post-card-tags">
                </div>
                <h2 class="post-card-title">
                    G&amp;TOC&amp;CSS
                </h2>
            </header>
                <div class="post-card-excerpt">TOC 的需求实现以及相关的思考总结。</div>
        </a>

        <footer class="post-card-meta">
            <time class="post-card-meta-date" datetime="2022-05-01">May 1, 2022</time>
                <span class="post-card-meta-length">6 min read</span>
        </footer>

    </div>

</article>
                </div>
            </aside>



    </div>
    <div class="docsearchwrapper"><div id="docsearch"></div></div>
    <div class="arrowup">
      <svg
        version="1.1"
        id="Layer_1"
        xmlns="http://www.w3.org/2000/svg"
        xmlns:xlink="http://www.w3.org/1999/xlink"
        x="0px"
        y="0px"
        width="20px"
        height="20px"
        viewBox="0 0 122.883 122.882"
        enable-background="new 0 0 20 20"
        xml:space="preserve"
      >
        <g>
          <path
            d="M0,61.441L0,61.441h0.018c0,16.976,6.872,32.335,17.98,43.443c11.108,11.107,26.467,17.979,43.441,17.979v0.018h0.001 h0.001v-0.018c16.974,0,32.335-6.872,43.443-17.98s17.98-26.467,17.98-43.441h0.018v-0.001V61.44h-0.018 c0-16.975-6.873-32.334-17.98-43.443C93.775,6.89,78.418,0.018,61.443,0.018V0h-0.002l0,0v0.018 c-16.975,0-32.335,6.872-43.443,17.98C6.89,29.106,0.018,44.465,0.018,61.439H0V61.441L0,61.441z M42.48,71.7 c-1.962,1.908-5.101,1.865-7.009-0.098c-1.909-1.962-1.865-5.101,0.097-7.009l22.521-21.839l3.456,3.553l-3.46-3.569 c1.971-1.911,5.117-1.862,7.029,0.108c0.055,0.058,0.109,0.115,0.16,0.175L87.33,64.594c1.963,1.908,2.006,5.047,0.098,7.009 c-1.908,1.963-5.047,2.006-7.01,0.098L61.53,53.227L42.48,71.7L42.48,71.7z"
          />
        </g>
      </svg>
    </div>
    <footer class="site-footer outer">
        <div class="inner">
            <section class="copyright"><a href="../index.html">zairesinatra</a> &copy; 2023</section>
            <nav class="site-footer-nav">
                
            </nav>
            <div><a href="https://ghost.org/" target="_blank" rel="noopener">Powered by Ghost</a></div>
        </div>
    </footer>
</div>


<script
    src="https://code.jquery.com/jquery-3.5.1.min.js"
    integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0="
    crossorigin="anonymous">
</script>
<script src="../assets/built/casper.js%3Fv=7d64696598"></script>
<script>
$(document).ready(function () {
    // Mobile Menu Trigger
    $('.gh-burger').click(function () {
        $('body').toggleClass('gh-head-open');
    });
    // FitVids - Makes video embeds responsive
    $(".gh-content").fitVids();
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.18.2/tocbot.min.js"></script>
<script>
  tocbot.init({
    tocSelector: '.toc',
    contentSelector: '.gh-content',
    hasInnerContainers: true
  });
  var tc = document.querySelector(".toc-container");
  if(tc){
    var tch = tc.clientHeight;
    var ah = document.querySelector(".article-header");
    var ahh = ah.clientHeight;
    window.addEventListener("scroll", function () {
    if(document.body.clientWidth > 1170){
      var scrollY = document.documentElement.scrollTop || document.body.scrollTop;
      var ihh = window.innerHeight;
      if(scrollY >= ihh + tch + ahh){
        var ctc = document.querySelector(".toc-container");
        ctc.style.position="sticky";
        ctc.style.position="-webkit-sticky";
        ctc.style.top = "120px";
        ctc.style.marginLeft = "800px";
        ctc.style.minWidth= "260px";
      }
      if(scrollY < tch + ahh -10){
        var ctc = document.querySelector(".toc-container");
        ctc.style.position="";
        ctc.style.top = "";
        ctc.style.marginLeft = "";
      }
    }})
  }
</script>
<script>
  function searchFunc(){
    let autocomplete = document.querySelector("#autocomplete");
    let algoliaouterwrapper = document.querySelector(".algoliaouterwrapper");
    // console.log(algoliaouterwrapper,autocomplete);
    autocomplete.parentNode.removeChild(autocomplete);
    algoliaouterwrapper.appendChild(autocomplete);
    autocomplete.style.marginTop = "50px";
    algoliaouterwrapper.style.background = '#F5F5FA';
    algoliaouterwrapper.style.display = "block";
    algoliaouterwrapper.style.zIndex = 99999;
    autocomplete.addEventListener('click', function(event) {
      event.stopPropagation();
    });
  }
  function outerwrapperFunc(event){
    event.stopPropagation();
    let autocomplete = document.querySelector("#autocomplete");
    let algoliawrapper = document.querySelector(".algoliawrapper");
    let algoliaouterwrapper = document.querySelector(".algoliaouterwrapper");
    autocomplete.parentNode.removeChild(autocomplete);
    algoliawrapper.appendChild(autocomplete);
    algoliaouterwrapper.style.background = '';
    algoliaouterwrapper.style.display = "none";
    algoliaouterwrapper.style.zIndex = 0;
    autocomplete.removeEventListener('click', function(event) {
      event.stopPropagation();
    });
  }
  function searchFuncMobile (){
    let mobileTrigger = document.querySelector(".aa-DetachedSearchButton");
    mobileTrigger.click();
  }
</script>

<script>
  function docSearchFuncMobile(){
    const DocSearchElement = document.querySelector(".DocSearch");
    DocSearchElement.click();
  }
</script>


<!-- searchinghost-easy -->
<!--
<script src="https://cdn.jsdelivr.net/gh/gmfmi/searchinghost-easy@latest/dist/searchinghost-easy-basic.js"></script>
<script>
    new SearchinGhostEasy({
        contentApiKey: 'e93d8b3520ae46be52c9a4b140'
    });
</script>
-->

<!-- Theme Mode -->
<script>
    let currentTheme = localStorage.getItem("theme-color");
    const switchTheme = function () {
        const storedTheme = localStorage.getItem("theme-color") || "theme-light";
        if (
            storedTheme === "theme-dark" &&
            document.getElementsByTagName("html")[0].className !== ""
        ) {
            localStorage.setItem("theme-color", "theme-light");
            currentTheme = localStorage.getItem("theme-color");
            if (currentTheme === "theme-light") {
            document.getElementsByTagName("html")[0].classList.remove("dark-mode");
            document
                .getElementsByClassName("theme-switcher")[0]
                ?.classList.remove("active");
            document
                .getElementsByClassName("toc")[0]
                ?.classList.remove("active");
            }
        } else {
            localStorage.setItem("theme-color", "theme-dark");
            currentTheme = localStorage.getItem("theme-color");
            if (currentTheme === "theme-dark") {
            // console.log(document.getElementById("app"));
            document.getElementsByTagName("html")[0].classList.add("dark-mode");
            document
                .getElementsByClassName("theme-switcher")[0]
                ?.classList.add("active");
            document
                .getElementsByClassName("toc")[0]
                ?.classList.add("active");
            }
        }
    };
    const initTheme = function () {
    const storedTheme = localStorage.getItem("theme-color") || "theme-light";
    if (storedTheme === "theme-dark") {
        document
        .getElementsByClassName("theme-switcher")[0]
        ?.classList.add("active");
        document
        .getElementsByClassName("toc")[0]
        ?.classList.add("active");
        document.getElementsByTagName("html")[0].classList.add("dark-mode");
    }
    };
    initTheme()
</script>

<!-- Arrow up -->
<script>
const arrowup = document.querySelector(".arrowup");
arrowup.addEventListener("click", function() {
  const scrollDuration = 1500; // 滚动持续时间，单位毫秒
    const start = window.pageYOffset; // 当前滚动位置
    const end = 0; // 滚动结束位置
    const distance = end - start; // 滚动距离
    const startTime = performance.now(); // 动画开始时间

    function easeInOutCubic(t) {
      return t < 0.5
        ? 4 * t ** 3
        : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
    }

    function scrollToTopSmooth(timestamp) {
      const currentTime = timestamp - startTime; // 已经经过的时间
      const progress = currentTime / scrollDuration; // 滚动进度
      const position =
        start + distance * easeInOutCubic(Math.min(progress, 1)); // 当前滚动位置
      window.scrollTo(0, position); // 滚动到新位置

      if (currentTime < scrollDuration) {
        // 如果滚动还未结束，则继续执行动画
        requestAnimationFrame(scrollToTopSmooth);
      }
    }

    requestAnimationFrame(scrollToTopSmooth);
});
</script>

<!-- Algolia DocSearch -->
<style>
.docsearchwrapper{
  display: none;
}
.DocSearch-Container{
  z-index: 9999999;
}
</style>

<script type="text/javascript">
  docsearch({
    appId: "722DYFSYDR",
    apiKey: "5b7d4a36b43ac3d135ca6b83ac715f7e",
    indexName: "zairesinatraio",
    container: document.querySelector("#docsearch"),
    debug: false // Set debug to true if you want to inspect the modal
  });
</script>

</body>
</html>
