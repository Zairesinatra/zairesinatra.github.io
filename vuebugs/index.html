<!DOCTYPE html>
<html lang="en">
<head>

    <title>Vue 札记</title>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="stylesheet" type="text/css" href="../assets/built/screen.css%3Fv=7d64696598.css" />

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.18.2/tocbot.css">
    <link rel="stylesheet" type="text/css" href="../assets/css/screen.css%3Fv=7d64696598.css" />
    <meta name="description" content="Vue2 &#x3D;&gt; JavaScript Framework" />
    <link rel="icon" href="../content/images/size/w256h256/2021/07/ghost-orb.png" type="image/png" />
    <link rel="canonical" href="index.html" />
    <meta name="referrer" content="no-referrer-when-downgrade" />
    <link rel="amphtml" href="amp/index.html" />
    
    <meta property="og:site_name" content="zairesinatra" />
    <meta property="og:type" content="article" />
    <meta property="og:title" content="Vue 札记" />
    <meta property="og:description" content="Vue2 &#x3D;&gt; JavaScript Framework" />
    <meta property="og:url" content="https://zairesinatra.github.io//vuebugs/" />
    <meta property="og:image" content="https://zairesinatra.github.io//content/images/2022/07/ShirahigeJinja.jpg" />
    <meta property="article:published_time" content="2020-12-14T12:21:00.000Z" />
    <meta property="article:modified_time" content="2023-02-15T16:48:05.000Z" />
    <meta property="article:tag" content="Technology growth" />
    
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Vue 札记" />
    <meta name="twitter:description" content="Vue2 &#x3D;&gt; JavaScript Framework" />
    <meta name="twitter:url" content="https://zairesinatra.github.io//vuebugs/" />
    <meta name="twitter:image" content="https://zairesinatra.github.io//content/images/2022/07/ShirahigeJinja.jpg" />
    <meta name="twitter:label1" content="Written by" />
    <meta name="twitter:data1" content="Ziyi Xie" />
    <meta name="twitter:label2" content="Filed under" />
    <meta name="twitter:data2" content="Technology growth" />
    <meta name="twitter:site" content="@xieziyi0422" />
    <meta property="og:image:width" content="1920" />
    <meta property="og:image:height" content="1080" />
    
    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "publisher": {
        "@type": "Organization",
        "name": "zairesinatra",
        "url": "https://zairesinatra.github.io//",
        "logo": {
            "@type": "ImageObject",
            "url": "https://zairesinatra.github.io//content/images/2021/07/zs-1.JPG",
            "width": 60,
            "height": 60
        }
    },
    "author": {
        "@type": "Person",
        "name": "Ziyi Xie",
        "image": {
            "@type": "ImageObject",
            "url": "https://zairesinatra.github.io//content/images/2021/07/zs-2.JPG",
            "width": 1079,
            "height": 1079
        },
        "url": "https://zairesinatra.github.io//author/ziyi/",
        "sameAs": []
    },
    "headline": "Vue 札记",
    "url": "https://zairesinatra.github.io//vuebugs/",
    "datePublished": "2020-12-14T12:21:00.000Z",
    "dateModified": "2023-02-15T16:48:05.000Z",
    "image": {
        "@type": "ImageObject",
        "url": "https://zairesinatra.github.io//content/images/2022/07/ShirahigeJinja.jpg",
        "width": 1920,
        "height": 1080
    },
    "keywords": "Technology growth",
    "description": "Vue2 &#x3D;&gt; JavaScript Framework",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://zairesinatra.github.io//"
    }
}
    </script>

    <meta name="generator" content="Ghost 5.33" />
    <link rel="alternate" type="application/rss+xml" title="zairesinatra" href="../rss/index.html" />
    <script defer src="https://cdn.jsdelivr.net/ghost/portal@~2.24/umd/portal.min.js" data-ghost="https://zairesinatra.github.io//" data-key="f5d74add11f1d16d3e59c12945" data-api="https://zairesinatra.github.io//ghost/api/content/" crossorigin="anonymous"></script><style id="gh-members-styles">.gh-post-upgrade-cta-content,
.gh-post-upgrade-cta {
    display: flex;
    flex-direction: column;
    align-items: center;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
    text-align: center;
    width: 100%;
    color: #ffffff;
    font-size: 16px;
}

.gh-post-upgrade-cta-content {
    border-radius: 8px;
    padding: 40px 4vw;
}

.gh-post-upgrade-cta h2 {
    color: #ffffff;
    font-size: 28px;
    letter-spacing: -0.2px;
    margin: 0;
    padding: 0;
}

.gh-post-upgrade-cta p {
    margin: 20px 0 0;
    padding: 0;
}

.gh-post-upgrade-cta small {
    font-size: 16px;
    letter-spacing: -0.2px;
}

.gh-post-upgrade-cta a {
    color: #ffffff;
    cursor: pointer;
    font-weight: 500;
    box-shadow: none;
    text-decoration: underline;
}

.gh-post-upgrade-cta a:hover {
    color: #ffffff;
    opacity: 0.8;
    box-shadow: none;
    text-decoration: underline;
}

.gh-post-upgrade-cta a.gh-btn {
    display: block;
    background: #ffffff;
    text-decoration: none;
    margin: 28px 0 0;
    padding: 8px 18px;
    border-radius: 4px;
    font-size: 16px;
    font-weight: 600;
}

.gh-post-upgrade-cta a.gh-btn:hover {
    opacity: 0.92;
}</style>
    <script defer src="https://cdn.jsdelivr.net/ghost/sodo-search@~1.1/umd/sodo-search.min.js" data-key="f5d74add11f1d16d3e59c12945" data-styles="https://cdn.jsdelivr.net/ghost/sodo-search@~1.1/umd/main.css" data-sodo-search="https://zairesinatra.github.io//" crossorigin="anonymous"></script>
    <link href="https://zairesinatra.github.io//webmentions/receive/" rel="webmention" />
    <script defer src="../public/cards.min.js%3Fv=7d64696598"></script>
    <link rel="stylesheet" type="text/css" href="../public/cards.min.css%3Fv=7d64696598.css">
    <script defer src="../public/member-attribution.min.js%3Fv=7d64696598"></script>
    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-NXZH6Q3K52"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-NXZH6Q3K52');
</script>
<!-- Ghost Init -->
<style>
.post-template .gh-head,
.page-template .gh-head {
  background: #000000 !important;
}
.site-footer {
  background: #000000 !important;
}
.post-card-tags {
  color: var(--color-secondary-text) !important;
}
.gh-portal-triggerbtn-container.with-label::before {
  display: none !important;
}
/* 需提前，否则闪烁 */
.footer-cta,
a.gh-head-button {
  display: none;
}
.algoliaouterwrapper i svg {
  width: 0;
}
/* 更多内容去除外边距 */
.footer-cta + .read-more-wrap {
  margin-top: unset;
}
</style>

<!-- 2023 => prismjs -->
<script src="https://res.cloudinary.com/dzb9ldnvl/raw/upload/v1679662056/Ghost/prism_i9a8up.js"></script>
<link rel="stylesheet" href="https://res.cloudinary.com/dzb9ldnvl/raw/upload/v1679662068/Ghost/prism_mdfwkg.css"/>
<!-- Patch: additional supported languages -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-vim.min.js" integrity="sha512-P1MRK1H11qw68MAfAYVyjumLuurOQKO4wwcx4S2Nbbae9CndG92dkIXq34lsOeMFlWZoT7nVPgsOy3gepk93Bg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<!-- Activate Line Numbers in PrismJS -->
<script>
	window.addEventListener('DOMContentLoaded', (event) => {      
		document.querySelectorAll('pre[class*=language-]').forEach(function(node) {
			node.classList.add('line-numbers');
            node.style.border = 'solid #FFFFFF 1px'
		});
		Prism.highlightAll();
	});
</script>
<!-- Resize Pre Area in PrismJS -->
<style>
    pre[class*="language-"].line-numbers{
		font-size: 0.8em;
        background-color: #202324;
    }
    code[class*="language-"] {
        background-color: transparent !important;
    }
</style>

<!-- TOC -->
<style>
    .toc > .toc-list li:first-child {
      margin-top: 8px;
    }
    .toc-list a {
      color: #000000 !important;
      text-decoration: none;
      word-break: break-word;
    }
    .toc > ol, .toc > li{
      font-size: 1.4rem;
    }
    
    .toc.active > .toc-list li:first-child {
      margin-top: 8px;
    }
    .toc.active .toc-list a {
      color: #FFFFFF !important;
      text-decoration: none;
      word-break: break-word;
    }
    .toc.active > ol, .toc.active > li{
      font-size: 1.4rem;
    }
</style>

<!-- ghost style by wkzs -->
<style>
.gh-content > [id] + * {
  margin-top: 2.5rem !important;
}
.gh-content > [id]:not(:first-child) {
  margin: 1.5em 0 0;
}
.gh-content > hr + *, .gh-content > blockquote + * {
  margin-top: max(1.1rem, 16px) !important;
}
.gh-content > [id]:not(:first-child) {
  margin: 1em 0 0;
}
.gh-content > * + * {
  margin-top: max(1.6vmin, 16px);
  margin-bottom: 0;
}
.gh-content > blockquote:not([class]), .gh-content > ol, .gh-content > ul, .gh-content > dl, .gh-content > p {
    font-family: var(--font-serif);
    font-weight: 400;
    font-size: 1.6rem;
    line-height: 1.6em;
    margin-top: 1.6rem;
}
</style>

<!-- Theme Change -->
<style>
@keyframes slideUp {
  from {
    bottom: 100px;
    opacity: 0;
  }
  to {
    bottom: 0;
    opacity: 1;
  }
}
.theme-switcher-wrap {
  width: 42px;
  height: 24px;
  text-align: right;
}
@media (max-width: 767px) {
  .gh-head-open .theme-switcher-wrap {
    width: 42px;
    height: 24px;
    text-align: right;
    animation: slideUp 1s ease-in-out forwards;
  }
}
.theme-switcher {
  display: inline-block;
  cursor: pointer;
}
.switch-path {
  width: 42px;
  height: 24px;
  border-radius: 10px;
  background-color: #f2f2f2;
  border: #dddfe6 1px solid;
}
.switch-path > .switch-handle {
  background-color: #ffffff;
  width: 20px;
  height: 20px;
  border-radius: 50%;
  transition: all 0.3s ease-in-out;
}
.switch-handle .dark-icon {
  visibility: hidden;
  display: none;
}
.theme-switcher.active .switch-path {
  background-color: #555;
}
.theme-switcher.active .switch-handle {
  transform: translateX(20px);
  background-color: #101115;
}
.theme-switcher.active .switch-handle .light-icon {
  visibility: hidden;
}
.theme-switcher.active .switch-handle .dark-icon {
  visibility: visible;
  display: block;
}
</style>

<!-- Arrow up -->
<style>
    .arrowup {
    	position: fixed;
        width: 50px;
        height: 50px;
        left: 35px;
        bottom: 3.1rem;
        z-index: 99;
        background-color: #15171A;
        display: flex;
        justify-content: center;
        align-items: center;
        border-radius: 10px;
        cursor: pointer;
        opacity: 1;
  		transition: opacity 0.3s ease-in-out;
    }
    .arrowup svg {
    	fill: #FFFFFF;
    }
    .arrowup:hover {
      opacity: 0.8;
    }
</style><style>:root {--ghost-accent-color: #15171A;}</style>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@docsearch/css@3"/></pre></li>
</head>
<body class="post-template tag-technology-growth is-head-left-logo has-cover">
<div class="viewport">
    <header id="gh-head" class="gh-head outer">
        <div class="gh-head-inner inner">
            <div class="gh-head-brand">
                <a class="gh-head-logo" href="../index.html">
                        <img src="../content/images/2021/07/zs-1.JPG" alt="zairesinatra">
                </a>
                <button class="gh-search gh-icon-btn" onclick="docSearchFuncMobile()"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" width="20" height="20"><path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path></svg></button>
                <button class="gh-burger"></button>
            </div>

            <nav class="gh-head-menu">
                <ul class="nav">
    <li class="nav-home"><a href="../index.html">Home</a></li>
    <li class="nav-welcome"><a href="../welcome/index.html">Welcome</a></li>
    <li class="nav-author"><a href="../selfintro/index.html">Author</a></li>
    <li class="nav-tags"><a href="../tags/index.html">Tags</a></li>
</ul>

            </nav>

            <div class="gh-head-actions">
                <div class="theme-switcher-wrap">
                    <div class="theme-switcher" onclick="switchTheme()">
                    <div class="switch-path">
                        <div class="switch-handle">
                        <svg viewBox="0 0 24 24" class="dark-icon">
                            <path
                            d="M11.01 3.05C6.51 3.54 3 7.36 3 12a9 9 0 0 0 9 9c4.63 0 8.45-3.5 8.95-8c.09-.79-.78-1.42-1.54-.95A5.403 5.403 0 0 1 11.1 7.5c0-1.06.31-2.06.84-2.89c.45-.67-.04-1.63-.93-1.56z"
                            fill="#CFD3DC"
                            ></path>
                        </svg>
                        <svg viewBox="0 0 24 24" class="light-icon">
                            <path
                            d="M6.05 4.14l-.39-.39a.993.993 0 0 0-1.4 0l-.01.01a.984.984 0 0 0 0 1.4l.39.39c.39.39 1.01.39 1.4 0l.01-.01a.984.984 0 0 0 0-1.4zM3.01 10.5H1.99c-.55 0-.99.44-.99.99v.01c0 .55.44.99.99.99H3c.56.01 1-.43 1-.98v-.01c0-.56-.44-1-.99-1zm9-9.95H12c-.56 0-1 .44-1 .99v.96c0 .55.44.99.99.99H12c.56.01 1-.43 1-.98v-.97c0-.55-.44-.99-.99-.99zm7.74 3.21c-.39-.39-1.02-.39-1.41-.01l-.39.39a.984.984 0 0 0 0 1.4l.01.01c.39.39 1.02.39 1.4 0l.39-.39a.984.984 0 0 0 0-1.4zm-1.81 15.1l.39.39a.996.996 0 1 0 1.41-1.41l-.39-.39a.993.993 0 0 0-1.4 0c-.4.4-.4 1.02-.01 1.41zM20 11.49v.01c0 .55.44.99.99.99H22c.55 0 .99-.44.99-.99v-.01c0-.55-.44-.99-.99-.99h-1.01c-.55 0-.99.44-.99.99zM12 5.5c-3.31 0-6 2.69-6 6s2.69 6 6 6s6-2.69 6-6s-2.69-6-6-6zm-.01 16.95H12c.55 0 .99-.44.99-.99v-.96c0-.55-.44-.99-.99-.99h-.01c-.55 0-.99.44-.99.99v.96c0 .55.44.99.99.99zm-7.74-3.21c.39.39 1.02.39 1.41 0l.39-.39a.993.993 0 0 0 0-1.4l-.01-.01a.996.996 0 0 0-1.41 0l-.39.39c-.38.4-.38 1.02.01 1.41z"
                            fill="#606266"
                            ></path>
                        </svg>
                        </div>
                    </div>
                    </div>
                </div>
                    <button class="gh-search gh-icon-btn" onclick="docSearchFuncMobile()"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" width="20" height="20"><path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path></svg></button>
                    <div class="gh-head-members">
                                <a class="gh-head-link" href="index.html#/portal/signin" data-portal="signin">Sign in</a>
                                <a class="gh-head-button" href="index.html#/portal/signup" data-portal="signup">Subscribe</a>
                    </div>
            </div>
        </div>
    </header>

    <div class="site-content">
      <script src="https://cdn.jsdelivr.net/npm/@docsearch/js@3"></script>
        



<main id="site-main" class="site-main">
<article class="article post tag-technology-growth ">

    <header class="article-header gh-canvas">

        <div class="article-tag post-card-tags">
                <span class="post-card-primary-tag">
                    <a href="../tag/technology-growth/index.html">Technology growth</a>
                </span>
        </div>

        <h1 class="article-title">Vue 札记</h1>

            <p class="article-excerpt">Vue2 &#x3D;&gt; JavaScript Framework</p>

        <div class="article-byline">
        <section class="article-byline-content">

            <ul class="author-list">
                <li class="author-list-item">
                    <a href="../author/ziyi/index.html" class="author-avatar">
                        <img class="author-profile-image" src="../content/images/size/w100/2021/07/zs-2.JPG" alt="Ziyi Xie" />
                    </a>
                </li>
            </ul>

            <div class="article-byline-meta">
                <h4 class="author-name"><a href="../author/ziyi/index.html">Ziyi Xie</a></h4>
                <div class="byline-meta-content">
                    <time class="byline-meta-date" datetime="2020-12-14">Dec 14, 2020</time>
                        <span class="byline-reading-time"><span class="bull">&bull;</span> 28 min read</span>
                </div>
            </div>

        </section>
        </div>

            <figure class="article-image">
                <img
                    srcset="../content/images/size/w1000/2022/07/ShirahigeJinja.jpg 1000w"
                    sizes="(min-width: 1400px) 1400px, 92vw"
                    src="../content/images/size/w2000/2022/07/ShirahigeJinja.jpg"
                    alt="Shirahige Jinja"
                />
                    <figcaption><b>Shirahige Jinja</b></figcaption>
            </figure>

    </header>

    <section class="gh-content gh-canvas">
    <aside class="toc-container">
        <div class="toc"></div>
    </aside>
    <!--kg-card-begin: markdown--><h2 id="basicconcepts">Basic Concepts</h2>
<h3 id="vue">Vue 项目结构</h3>
<ul>
<li>main.js =&gt; 程序入口 -&gt; 实例化、初始化，指派插件并导入公共组件</li>
</ul>
<pre><code class="language-javascript">// 完整写法 import Vue from &quot;../node_modules/vue/dist/vue.js&quot;
// import...from...的 from 命令后面可以跟很多路径格式,若只给出 vue, axios 这样的包名,则会自动到 node_modules 中加载;若给出相对路径及文件前缀，则到指定位置寻找
import Vue from 'vue'
import App from './App.vue'
import router from './router'
import store from './store'
Vue.config.productionTip = false
new Vue({ router, store, render: h =&gt; h(App) }).$mount('#app')
</code></pre>
<ul>
<li>App.vue =&gt; 主组件、页面入口文件。所有页面都是此进行切换</li>
</ul>
<pre><code class="language-html">&lt;template&gt;
  &lt;div id=&quot;app&quot;&gt;
    &lt;!-- 路由出口 --&gt;
    &lt;router-view/&gt;
    &lt;h1&gt;App&lt;/h1&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default { name: 'App' }
&lt;/script&gt;
&lt;style lang=&quot;less&quot;&gt;&lt;/style&gt;
</code></pre>
<ul>
<li>router/index.js =&gt; 注册路由组件到路由中</li>
</ul>
<pre><code class="language-javascript">import Vue from 'vue'
import VueRouter from 'vue-router'
Vue.use(VueRouter)
const routes = []
const router = new VueRouter({ routes })
export default router
</code></pre>
<h3 id="jsx"><a href="https://v2.cn.vuejs.org/v2/guide/render-function.html">渲染函数 &amp; JSX</a></h3>
<p>h 函数是 createElement 函数的 ES6 语法缩写，源自 <a href="https://github.com/Matt-Esch/virtual-dom/blob/master/virtual-hyperscript/README.md">virtual-dom</a> 源码中实现生成 HTML 结构的 <a href="https://github.com/hyperhype/hyperscript">hyperscript</a> 脚本。render 函数是暴露给开发者使用 createElement 的钩子选项。<a href="https://github.com/Matt-Esch/virtual-dom/blob/master/vdom/create-element.js">createElement</a> 函数用于生成 VNode 节点。</p>
<pre><code class="language-javascript">render: h =&gt; h(App)
render: function(createElement){ return createElement(App) }
const h = (tag, props, children) =&gt; {return {tag, props, children,...}}
</code></pre>
<p>渲染函数适合处理复杂逻辑，典型的推荐场景是当模板中要声明式渲染冗长的重复内容。</p>
<h3 id="componentclassification">Component Classification</h3>
<ul>
<li>
<p><a href="https://v2.cn.vuejs.org/v2/guide/render-function.html#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6">函数式组件</a> =&gt; 无状态，无法实例化，内部没有任何生命周期处理方法</p>
</li>
<li>
<p><a href="https://v2.cn.vuejs.org/v2/guide/components-dynamic-async.html#%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6">异步组件</a> =&gt; 异步组件注册 &amp; 路由的按需加载</p>
</li>
</ul>
<p>异步组件通常用于解决项目过大所导致的加载缓慢问题，重点是按需加载。注册异步组件的常规方式是 =&gt; 工厂函数返回配置化的组件对象、工厂函数返回 Promise 和工厂函数执行 resolve 回调。</p>
<p><a href="https://router.vuejs.org/zh/guide/advanced/lazy-loading.html">路由组件按需加载</a>基于 ES6 中模块化规范 import 动态加载，返回一个 Promise 对象。import 方法是异步的。</p>
<ul>
<li><a href="https://v2.cn.vuejs.org/v2/guide/components.html#%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6">动态组件</a> =&gt; tab 切换时会涉及到组件动态加载</li>
</ul>
<blockquote>
<p>动态组件是使用 component 组件，通过特殊的 attribute <code>is</code> 实现。</p>
</blockquote>
<pre><code class="language-html">&lt;!-- 组件重新加载会消耗大量性能 --&gt;
&lt;component v-bind:is=&quot;currentTabComponent&quot;&gt;&lt;/component&gt;
&lt;!-- 保持状态 --&gt;
&lt;transition&gt;&lt;keep-alive&gt;&lt;component v-bind:is=&quot;currentTabComponent&quot;&gt;&lt;/component&gt;&lt;/keep-alive&gt;&lt;/transition&gt;
</code></pre>
<p>动态组件通常会与 <a href="https://v2.cn.vuejs.org/v2/api/#keep-alive">&lt;keep-alive&gt;</a> 组件一并使用，保证组件切换时不丢失状态。</p>
<pre><code class="language-jsx">/* keep-alive property */
include - String | RegExp | Array =&gt; 名称匹配组件被缓存
exclude - String | RegExp | Array =&gt; 名称匹配组件不被缓存
max - Number | String =&gt; 最多可缓存的组件实例
</code></pre>
<p>对于缓存的组件，再次进入时，不会执行 created 或 mounted 等生命周期函数。</p>
<p>组件在 &lt;keep-alive&gt; 中切换，activated 和 deactivated 生命周期将会对应执行。</p>
<ul>
<li><a href="https://v2.cn.vuejs.org/v2/guide/components-edge-cases.html#%E9%80%92%E5%BD%92%E7%BB%84%E4%BB%B6">递归组件</a></li>
</ul>
<p>递归组件即组件在模板内递归调用自身，适合开发树型组件。设置组件名以调用自身，设置阈值是为避免抛出 &quot;max stack size exceed&quot; 的异常。</p>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><h2 id="">双向数据绑定</h2>
<h3 id="mvvmmodelviewviewmodel">MVVM Model-View-ViewModel</h3>
<p>早期页面是预先存放在服务器上的静态资源，相当于托管静态资源。随着页面与功能增加，通过 JS 修改服务器渲染后的数据已经不能再满足页面的交互需求。</p>
<pre><code class="language-javascript">app.use(express.static(path.join(__dirname, 'zspublic')));
</code></pre>
<p>模型-视图-视图模型是软件架构的设计模式，产生了 GUI Graphical user interface 图形用户界面以及促进了前后端的业务分离。</p>
<p>MVVM 的核心是以 JS、runtime、compiler 为集合的 ViewModel 视图模型层。向上与 View 视图层进行双向数据绑定，向下与 Model 层通过接口请求进行数据交互 (Ajax &lt;=&gt; JSON)。</p>
<h3 id="principle">Principle 原理</h3>
<p>双向数据绑定的本质是数据劫持结合发布订阅模式，通过对需要 observe 的数据对象进行属性（包括子属性对象的属性）递归遍历，增加访问器和更改器。当被劫持对象的属性变动时，会触发相应的监听回调。</p>
<p>编译解析模板指令就是将模板中的变量替换成数据。在初始化渲染时将每个指令对应节点都绑定更新函数，添加监听数据的订阅者，在数据变动时就会收到通知以更新视图。</p>
<p>发布订阅模式是劫持和编译之间通信的桥梁，主要做的事情是在自身实例化时往属性订阅器 dep 里面添加自己，其自身必须有一个 update 方法，待属性变动 dep.notice 通知时，能调用自身的 update 方法，并触发 Compile 中绑定的回调，则功成身退。</p>
<p>MVVM 作为数据绑定的入口，整合 Observer、compile 和 Watcher 三者，通过 Observer<br>
来监听自己的 model 数据变化，通过 Compile 来解析编译模板指令，最终利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，达到数据变化 -＞视图更新；视图交互变化(input）-＞数据 model 变更的双向绑定效果。</p>
<ul>
<li>数据劫持 =&gt; Object.defineProperty(obj, prop, descriptor)</li>
</ul>
<blockquote>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">Object.defineProperty()</a> 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。</p>
</blockquote>
<pre><code class="language-javascript">var zsobj = {};
Object.defineProperty(zsobj,'biubiubiu',{
  // value: 23,
  get: function () {
    console.log('调用新定义的 biubiubiu 属性的 get 方法')
  },
  set: function(args){
    console.log('调用新定义的 biubiubiu 属性的 set 方法, 传入的值是' + args);
  }
});
zsobj.biubiubiu; // =&gt; 调用新定义的 biubiubiu 属性的 get 方法
zsobj.biubiubiu = 'zairesinatra' // 调用新定义的 biubiubiu 属性的 set 方法, 传入的值是zairesinatra

var zy = {};
Value = 23;
Object.defineProperty(zy, 'one', {
  writable: true,
});
// 不能尝试混合两者: 数据描述符、访问器描述符
Object.defineProperty(zy, 'onee', {
  get () { return console.log(Value) },
  set (newValue) { Value = newValue; },
  enumerable: true,
  configurable: true
});
zy.onee // 23
zy.onee = '24'
zy.onee // 24
</code></pre>
<ul>
<li>发布订阅模式</li>
</ul>
<p>发布订阅模式和观察者模式很像。观察者模式中一个对象被修改时，则会自动通知依赖它的对象，即 obsevers 知道 subject 的事件，属于行为型模式；但是发布订阅模式的发布者和订阅者并不直接取得联系，通过类似于中间件（事件总线）的帮助下进行代理事件通信，传入消息并完成相应的分发。<a href="https://hackernoon.com/observer-vs-pub-sub-pattern-50d3b27f838c">更多点此</a><br>
<img src="../content/images/2021/09/------pubscrib.png" alt="------pubscrib" loading="lazy"></p>
<ul>
<li>实现双向绑定</li>
</ul>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;mvvm&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;input type=&quot;text&quot;&gt;
    &lt;span&gt;&lt;/span&gt;
    &lt;script&gt;
        // 获取文档中的第一个DOM元素
        let input = document.querySelector('input');
        let span = document.querySelector('span');
        // 建立 event channel
        let obj = {};
        let value = '';
        Object.defineProperty(obj,'dataDescribe',{
            configurable: true | false, // 如果是false则不可以删除
            enumerable: true | false, // 如果为false则在枚举时候会忽略
            writable: true | false // 如果为false则不可采用数据运算符进行赋值
        });
        Object.defineProperty(obj, 'zsget', {
            set: function (newValue) {
                // fire event
                value = newValue
                input.value = newValue
                span.innerText = newValue
            },
            get: function () {
                return value
            }
        })
        input.addEventListener('keyup',(e) =&gt; {
            obj.zsget = e.target.value
        })
        input.value = obj.zsget
        span.innerText = obj.zsget
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><img src="https://res.cloudinary.com/dzb9ldnvl/image/upload/v1676479482/Ghost/Vue%20%E6%9C%AD%E8%AE%B0/%E5%8F%8C%E5%90%91%E5%AE%9E%E7%8E%B0_ekxfdf.png" alt="双向实现" loading="lazy"></p>
<ul>
<li>数据代理</li>
</ul>
<p>通过一个对象代理对另一个对象中属性的操作（读、写）称为数据代理。</p>
<pre><code class="language-javascript">let obj1 = {x:100}
let obj2 = {y:200}
Object.defineProperty(obj2, 'x', {
  get(){ return obj1.x },
  set(value){ obj1.x = value }
})
// obj2.x = 1
// obj2.x // 1
</code></pre>
<p>Vue 中数据代理通过 vm 对象来代理 data 对象中属性的操作，可以更方便的操作 data 中的数据（不必在花括号写 _data.属性）。Object.defineProperty() 把 data 对象中所有属性添加到 vm 上，为每一个添加到 vm 上的属性都指定一个 getter 和 setter。在 getter 和 setter 内部去操作 data 中对应的属性。</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;data proxy&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;root&quot;&gt;
        &lt;h2&gt;name: {{name}}&lt;/h2&gt;
        &lt;h2&gt;address: {{address}}&lt;/h2&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    let data = {
        name: 'zszy',
        address: 'cs'
    }
    const vm = new Vue({
        el: '#root',
        data
    })
    console.log(vm._data === data) // true -&gt; vm._data === vm.options.data === data
    console.log(vm.name === vm._data.name); // 进行 vm._data.name = 'zyzy' 后 vm.name 变为 zyzy
&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<p><img src="https://res.cloudinary.com/dzb9ldnvl/image/upload/v1676479483/Ghost/Vue%20%E6%9C%AD%E8%AE%B0/%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%90%86_uabhkn.png" alt="数据代理" loading="lazy"></p>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><h2 id="diffdom">Diff 算法和虚拟 DOM</h2>
<p>避免新增内容引起整个 DOM 树的重新渲染，而只针对改动区域重新更新。精细化对比，最小量更新的 Diff (from different) 运营而生。</p>
<p>虚拟 DOM 是通过 <a href="https://github.com/snabbdom/snabbdom">snabbdom.js</a> 库实现的，考虑到源码由 TypeScript 编写，可以通过 npm 下载使用 build 编译出来的 JavaScript 版 snabbdom 库。</p>
<pre><code class="language-javascript"># snabbdom =&gt; 3.0.3
npm i -S snabbdom
</code></pre>
<p>snabbdom 库是 DOM 库，不能在 nodejs 环境运行，所以需要搭建 webpack 和 webpack-dev-server 开发环境（不需安装任何loader）理解实现过程。</p>
<pre><code class="language-shell">npm i -D webpack webpack-cli webpack-dev-server
</code></pre>
<pre><code class="language-shell">[webpack-cli] You need to install 'webpack-dev-server' for running 'webpack serve'.
Error: Cannot find module 'webpack-dev-server'
Require stack:
- /Users/$/node_modules/@webpack-cli/serve/lib/index.js
- /Users/$/node_modules/webpack-cli/lib/webpack-cli.js
- /Users/$/node_modules/webpack-cli/lib/bootstrap.js
- /Users/$/node_modules/webpack-cli/bin/cli.js
- /Users/$/zairesinatra/fullStack/study-snabbdom/node_modules/webpack/bin/webpack.js
</code></pre>
<p>如果安装过程省略依赖会出现找不到目标文件并向上层目录继续寻找的报错。这里表示没有安装 webpack-cli 。在 webpack@3 版本里 webpack 和 webpack-cli 是在同一个包中，但在 ^4 版本两者已经分开。</p>
<p>配置 webpack.config.js 文件</p>
<pre><code class="language-javascript">const path = require('path')
// const HtmlWebpackPlugin = require('html-webpack-plugin');
module.exports = {
  // 入口
  entry: './src/index.js',
  // 出口
  output: {
    // 虚拟打包路径，就是说文件夹不会真正生成，而是在 8080 端口虚拟生成，不会真正的物理生成
    publicPath: '/virtual',
    // 打包出来的文件名
    filename: 'bundle.js'
  },
  devServer: {
    // 端口号
    port: 8080,
    // 静态资源文件夹
    contentBase: 'www'
  }
}
</code></pre>
<p>终端运行 <code>npx webpack serve</code> 启动项目，访问：<a href="http://localhost:8080/">http://localhost:8080/</a> 和 <a href="http://127.0.0.1:8080/virtual/bundle.js%EF%BC%8C">http://127.0.0.1:8080/virtual/bundle.js，</a> 可以看到 www/index.html 和 xuni/bundle.js 文件的内容。</p>
<p>在 html 文件创建 id 为 container 的 DOM 节点并引入 bundle.js 。如果没有成功创建节点会出现 <code>Uncaught TypeError: Cannot read property 'sel' of null snabbdom</code> 的 console 面板报错（div 写在了 script 标签之后）。</p>
<pre><code class="language-html">zairesinatra
&lt;div id=&quot;container&quot;&gt;&lt;/div&gt;
&lt;script src=&quot;/virtual/bundle.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p>在 index.js 中引入 snabbdom 。主要完成 compile（把真实 DOM 编译成 Vnode ）、diff（比较 oldVnode 和 newVnode 区别）、patch（补丁更新真实 DOM ）的工作。</p>
<pre><code class="language-javascript">console.log(&quot;zsxzy's bundle.js import completed&quot;);
import {
    init,
    classModule,
    propsModule,
    styleModule,
    eventListenersModule,
    h,
} from &quot;snabbdom&quot;;

const patch = init([
  // Init patch function with chosen modules
  classModule, // makes it easy to toggle classes
  propsModule, // for setting properties on DOM elements
  styleModule, // handles styling on elements with support for animations
  eventListenersModule, // attaches event listeners
]);

const container = document.getElementById(&quot;container&quot;);

const vnode = h(&quot;div#container.two.classes&quot;, { on: { click: function(){} } }, [
  h(&quot;span&quot;, { style: { fontWeight: &quot;bold&quot; } }, &quot;This is bold&quot;),
  &quot; and this is just normal text&quot;,
  h(&quot;a&quot;, { props: { href: &quot;/foo&quot; } }, &quot;I'll take you places!&quot;),
]);
// Patch into empty DOM element – this modifies the DOM as a side effect
patch(container, vnode);

const newVnode = h(
  &quot;div#container.two.classes&quot;,
  { on: { click: function(){} } },
  [
    h(
      &quot;span&quot;,
      { style: { fontWeight: &quot;normal&quot;, fontStyle: &quot;italic&quot; } },
      &quot;This is now italic type&quot;
    ),
    &quot; and this is still just normal text&quot;,
    h(&quot;a&quot;, { props: { href: &quot;/bar&quot; } }, &quot;I'll take you places!&quot;),
  ]
);
// Second `patch` invocation
patch(vnode, newVnode); // Snabbdom efficiently updates the old view to the new state
</code></pre>
<p><img src="https://res.cloudinary.com/dzb9ldnvl/image/upload/v1676479639/Ghost/Vue%20%E6%9C%AD%E8%AE%B0/initcompleted_a0ni1o.png" alt="initcompleted" loading="lazy"></p>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><p>虚拟 DOM 是用 JavaScript 对象描述 DOM 的层次结构。在 DOM 中的一切属性都能从虚拟 DOM 中找到对应。sel(selector) 表示元素选择器、data 表示元素属性、children 表示元素子节点、elm 表示该元素对应的真正的DOM节点（若值是 undefined 则未上树）、key 为节点唯一标识、text 文本内容。</p>
<p>diff 是发生在虚拟 DOM 上的：新虚拟 DOM 和老虚拟 DOM 进行 diff （精细化比较），计算最小量更新反映到真实的 DOM 上。key 是节点的唯一标识，告诉 diff 算法在更改前后是否为同一个 DOM 节点。只有是选择器相同且 key 相同的同一个虚拟节点，才进行虚拟化比较，否则就是暴力删除旧的、插入新的。最后注意的是 diff 算法只进行同层比较，不会进行跨层比较。</p>
<p>通过 h 函数传参数产生一个虚拟节点 (vnode) 对象用来描述真实的 DOM 。<code>h('a', { props: { href: 'https://blog.zairesinatra.com', target: '_blank'  } }, 'blog')</code> 可生成此类虚拟节点 <code>{ &quot;sel&quot;: &quot;a&quot;, &quot;data&quot;: { &quot;props&quot;: { &quot;href&quot;: &quot;https://blog.zairesinatra.com&quot; } }, &quot;text&quot;: &quot;zsxzy&quot; }</code>。h 函数中可以进行子节点的嵌套。</p>
<p>手写实现简易 diff 算法代码如下。</p>
<pre><code class="language-javascript">// vnode.js
export default function (sel, data, children, text, elm) {
  const key = data.key;
  return { sel, data, children, text, elm, key }
}
</code></pre>
<pre><code class="language-javascript">// h 函数(强制接受3个参数、弱重置功能)
// 封装 vnode 函数并抽离后导入
import vnode from './vnode'
// 形态可能: h('div', {}, '文字')\h('div', {}, [])\h('div', {}, h())
export default function (sel, data, c) {
  if (arguments.length !== 3)
    throw new Error('此 h 函数强制传入 3 个参数')
  if (typeof c === 'string' || typeof c === 'number') {
    return vnode(sel, data, undefined, c, undefined)
  } else if (Array.isArray(c)) {
    let children = []
    for (let i = 0; i &lt; c.length; i++) {
      if (!(typeof c[i] === 'object' &amp;&amp; c[i].hasOwnProperty('sel'))){
          throw new Error('传入的数组参数中有不是 h 函数的项')
      }
      children.push(c[i])
    }
    return vnode(sel, data, children, undefined, undefined)
  } else if (typeof c === 'object' &amp;&amp; c.hasOwnProperty('sel')) {
    let children = [c]
    return vnode(sel, data, children, undefined, undefined)
  } else {
    throw new Error('传入的第三个参数类型不对')
  }
}
</code></pre>
<pre><code class="language-javascript">// createElement 函数
// 真正创建节点, 将 vnode 创建为 DOM , 但未上树
export default function createElement(vnode) {
  // 创建由 tagName 指定的 HTML 元素节点
  let domNode = document.createElement(vnode.sel);
  // 仅论述子节点是文本或 children 情况
  if (vnode.text !== '' &amp;&amp; (vnode.children === undefined ||  vnode.children.length === 0)) {
    domNode.innerText = vnode.text;
  } else if (Array.isArray(vnode.children) &amp;&amp; vnode.children.length &gt; 0) {
    // children 情况递归创建节点
    for (let i = 0; i &lt; vnode.children.length; i++) {
      let ch = vnode.children[i];
      let chDom = createElement(ch);
      domNode.appendChild(chDom);
    }
  }
  // 补充纯 DOM 对象 —— elm 属性, 并返回
  vnode.elm = domNode;
  return vnode.elm;
}
</code></pre>
<pre><code class="language-javascript">// patch 函数
import vnode from './vnode'
import patchVnode from './patchVnode'
import createElement from './createElement'
export default function patch(oldVnode, newVnode) {
  // 判断旧节点是 DOM 节点还是虚拟节点, DOM 节点需要包装为虚拟节点
  if (oldVnode.sel === '' || oldVnode.sel === undefined) {
    oldVnode = vnode(oldVnode.tagName.toLowerCase(), {}, [], undefined, oldVnode);
  }
  // 判断 oldVnode 和 newVnode 是否同一个节点
  if (oldVnode.key === newVnode.key &amp;&amp; oldVnode.sel === newVnode.sel) {
    // 同一个节点情况较多, 封装函数
    patchVnode(oldVnode, newVnode);
  } else {
    // 不是同一个节点, 暴力插新删旧
    let newVnodeElm = createElement(newVnode);
    if (oldVnode.elm &amp;&amp; newVnodeElm) {
      oldVnode.elm.parentNode.insertBefore(newVnodeElm, oldVnode.elm);
    }
    oldVnode.elm.parentNode.removeChild(oldVnode.elm);
  }
}
</code></pre>
<pre><code class="language-javascript">// patchVnode.js
import createElement from './createElement'
export default function patchVnode(oldVnode, newVnode) {
  // 判断新旧 vnode 是否为同一个对象
  if (oldVnode === newVnode) {return}
  // 若 newVnode 有 text 属性
  if (
    newVnode.text != undefined &amp;&amp;
    (newVnode.children === undefined || newVnode.children.length === 0)
  ) {
    if (newVnode.text != oldVnode.text) {
      // innerText 产生重排, 直接覆盖 oldVnode.elm 故不必考虑 children 情况
      oldVnode.elm.innerText = newVnode.text;
    }
  } else {
    // newVnode 没有 text 属性 =&gt; 有children
    // 判断 oldVnode 有无 children
    if (oldVnode.children !== undefined &amp;&amp; oldVnode.children.length &gt; 0) {
      // 此时是最复杂的情况 —— oldVnode、newVnode 都有 children 属性
      // 仅书写新增节点的逻辑, 不考虑删除和更新节点的实现
      let un = 0;
      for (let i = 0; i &lt; newVnode.children.length; i++) {
        const ch = newVnode.children[i]
        let isExist = false;
        for (let j = 0; j &lt; oldVnode.children.length; j++) {
          const oldCh = oldVnode.children[j];
          if (oldCh.sel === ch.sel &amp;&amp; oldCh.key === ch.key) {
            isExist = true;
          }
        }
        if (!isExist) {
          const dom = createElement(ch);
          ch.elm = dom;
          if (un &lt; oldVnode.children.length) {
            oldVnode.elm.insertBefore(dom, oldVnode.children[un].elm);
          } else {
            oldVnode.elm.appendChild(dom);
          }
        } else {
          un++;
        }
      }
    } else {
      // 清空 oldVnode 的内容, 遍历 newVnode 子节点, 创建 DOM 并上树
      oldVnode.elm.innerText = '';
      for (let i = 0; i &lt; newVnode.children.length; i++) {
        const dom = createElement(newVnode.children[i]);
        oldVnode.elm.appendChild(dom);
      }
    }
  }
}
</code></pre>
<p>diff 算法的子节点更新策略 —— 四种命中查找：新前与旧前、新后与旧后、新后与旧前（旧前指向的节点，移动到旧后之后）、新前与旧后（旧后指向的节点，移动到旧前之前）。上述查找方式命中一种就不在进行判断，若一种未命中则需要使用循环寻找。</p>
<p>手写对应 snabbdom 源码简易子节点更新策略如下。</p>
<pre><code class="language-javascript">// updateChildren.js
import createElement from './createElement'
import patchVnode from './patchVnode'
// 判断是否同一个虚拟节点
function checkSameVnode(a, b) {
  return a.sel === b.sel &amp;&amp; a.key === b.key;
}
export default function updateChildren(parentElm, oldCh, newCh) {
  let oldStartIdx = 0, newStartIdx = 0, oldEndIdx = oldCh.length - 1, newEndIdx = newCh.length - 1, oldStartVnode = oldCh[oldStartIdx], oldEndVnode = oldCh[oldEndIdx], newStartVnode = newCh[newStartIdx], newEndVnode = newCh[newEndIdx], keyMap = null; // 旧前、新前、旧后、新后、旧前节点、旧后节点、新前节点、新后节点、Map映射
  while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) {
    // 略过已加 undefined 标记节点
    if (oldStartVnode === null || oldCh[oldStartIdx] === undefined) {
      oldStartVnode = oldCh[++oldStartIdx];
    } else if (oldEndVnode === null || oldCh[oldEndIdx] === undefined) {
      oldEndVnode = oldCh[--oldEndIdx];
    } else if (newStartVnode === null || newCh[newStartIdx] === undefined) {
      newStartVnode = newCh[++newStartIdx];
    } else if (newEndVnode === null || newCh[newEndIdx] === undefined) {
      newEndVnode = newCh[--newEndIdx];
    } else if (checkSameVnode(oldStartVnode, newStartVnode)) { // 判断命中开始
      patchVnode(oldStartVnode, newStartVnode);
      oldStartVnode = oldCh[++oldStartIdx];
      newStartVnode = newCh[++newStartIdx];
    } else if (checkSameVnode(oldEndVnode, newEndVnode)) {
      patchVnode(oldEndVnode, newEndVnode);
      oldEndVnode = oldCh[--oldEndIdx];
      newEndVnode = newCh[--newEndIdx];
    } else if (checkSameVnode(oldStartVnode, newEndVnode)) {
      patchVnode(oldStartVnode, newEndVnode);
      parentElm.appendChild(oldStartVnode.elm, oldEndVnode.elm.nextSibling);
      oldStartVnode = oldCh[++oldStartIdx];
      newEndVnode = newCh[--newEndIdx];
    } else if (checkSameVnode(oldEndVnode, newStartVnode)) {
      patchVnode(oldEndVnode, newStartVnode);
      parentElm.insertBefore(oldEndVnode.elm, oldStartVnode.elm);
      oldEndVnode = oldCh[--oldEndIdx];
      newStartVnode = newCh[++newStartIdx];
    } else {
      // 四种命中都没有找到则制作 keyMap 缓存 —— 快速遍历
      if (!keyMap) {
        keyMap = {};
        // 从 oldStartIdx 开始，到oldEndIdx结束，创建keyMap映射对象
        for (let i = oldStartIdx; i &lt;= oldEndIdx; i++) {
          const key = oldCh[i].key;
          if (key !== undefined) {
            keyMap[key] = i;
          }
        }
      }
      // 寻找当前这项 newStartIdx 这项在 keyMap 中映射的序号
      const idxInOld = keyMap[newStartVnode.key]
      if (idxInOld === undefined) {
        // idxInOld 是 undefined 表示全新的项
        // 被加入的项 (newStartVnode) 现在不是真实的DOM
        parentElm.insertBefore(createElement(newStartVnode), oldStartVnode.elm);
      } else {
        // idxInOld 不是 undefined 表示不是全新的项, 需移动
        const elmToMove = oldCh[idxInOld];
        patchVnode(elmToMove, newStartVnode)
        // 把这项设置为 undefined 表示已处理完
        oldCh[idxInOld] = undefined;
        // 移动调用 insertBefore
        parentElm.insertBefore(elmToMove.elm, oldStartVnode.elm);
      }
      // 指针下移, 仅移动新的头
      newStartVnode = newCh[++newStartIdx];
    }
  }
  // 继续看有无剩余、循环结束时 newStartIdx 比 newEndIdx 小
  if (newStartIdx &lt;= newEndIdx) {
    // new 还有剩余节点没有处理
    for (let i = newStartIdx; i &lt;= newEndIdx; i++) {
      // insertBefore 可以自动识别 null, 如果是 null 就会自动排到队尾.和appendChild是一致的
      parentElm.insertBefore(createElement(newCh[i]), oldCh[oldStartIdx].elm);
    }
  } else if (oldStartIdx &lt;= oldEndIdx) {
    // old 还有剩余节点没有处理
    for (let i = oldStartIdx; i &lt;= oldEndIdx; i++) {
      if (oldCh[i]) {
        parentElm.removeChild(oldCh[i].elm);
      }
    }
  }
}
</code></pre>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><h2 id="vuecli">Vue CLI</h2>
<p>Vue CLI 是一个基于 Vue.js 进行快速开发的完整系统。由三部分组成：CLI (@vue/cli)、CLI 服务 (@vue/cli-service)、CLI 插件。<a href="https://cli.vuejs.org/zh/guide/cli-service.html#%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4">CLI (@vue/cli)</a></p>
<pre><code class="language-zsh"># 快速原型开发
vue serve
# 创建 vue 项目
vue create
# 进入 vue 可视化管理界面
vue ui
</code></pre>
<p>例如对单个 <code>*.vue</code> 文件进行快速原型开发：需要在 <code>npm install -g @vue/cli-service-global</code> 之后才可进行使用 <code>vue serve</code> 启动项目。<br>
可以借助 npm 进行 Vue 项目的启动和打包等操作，例如： <code>npm run serve</code> 启动项目；<code>npm run build</code> 打包项目。同时在启动 React 项目的时候使用的是 <code>npm start</code>；在打包 React 项目的时候也是使用的 <code>npm run build</code>；但是创建 React项目的是使用的 React 自己的脚手架 create-react-app ；Vue使用的命令是 <code>vue create</code>。</p>
<p>CLI 服务 (@vue/cli-service) 是一个 <strong>开发环境</strong> 依赖。本质是一个 npm 包，局部安装在每个 @vue/cli 创建的项目中。</p>
<p>在一个 Vue CLI 项目中，@vue/cli-service 安装了一个名为 <code>vue-cli-service</code> 的命令。可以在 npm scripts 中以 <code>vue-cli-service</code>、或者从终端中以 <code>./node_modules/.bin/vue-cli-service</code> 访问这个命令。</p>
<pre><code>// 使用默认 preset 的项目的 package.json
{
  &quot;scripts&quot;: {
    &quot;serve&quot;: &quot;vue-cli-service serve&quot;,
    &quot;build&quot;: &quot;vue-cli-service build&quot;
  }
}
</code></pre>
<pre><code>// 通过 npm 调用这些 script
npm run serve
npm run build
</code></pre>
<pre><code>// 使用 npx (最新版的 npm 应该已经自带)调用
npx vue-cli-service serve
</code></pre>
<p>CLI 插件是向 Vue 项目提供可选功能的 npm 包，例如 Babel/TypeScript 转译、ESLint 集成等。</p>
<p>其中 CLI 插件的名字以 <code>@vue/cli-plugin- (xxx)</code>开头，在 <code>package.json</code> 中可查看。</p>
<p>当在项目内部运行 <code>vue-cli-service</code> 命令时，它会自动解析并加载 <code>package.json</code> 中列出的所有 CLI 插件。</p>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><h2 id="vuerouter">VueRouter</h2>
<h3 id="quickstart">Quick Start</h3>
<p>路由即路径和组件的对应关系，route 和 router 之间可以看作是路由和路由器的关系，route 由 router 进行管理，由于前者通常具有多个，故常写成 routes。路由的主要作用是实现单页面应用导航区与展示区的切换功能。</p>
<p>路由广义上分为前端路由以及后端路由，前端路由依靠锚链接，一种实现同一页面定位不同资源节点的特殊超链接；后端路由通过服务器实现资源分发，相比于前者性能较低。</p>
<p><a href="https://router.vuejs.org/zh/">vue-router</a> 是 vue 用来实现单页面应用的插件库。单页面应用有且只有一个完整的页面；点击页面中的导航链接不会刷新页面，只会做页面的局部更新；数据需要通过 ajax 请求获取。</p>
<p>Vue Router 配置步骤：</p>
<pre><code class="language-html">&lt;!--1. 引入库文件,在全局 window 对象上挂载 VueRouter 构造函数--&gt;
&lt;script src=&quot;lib/vue-router_3.0.2.js&quot;&gt;&lt;/script&gt;
</code></pre>
<pre><code class="language-javascript">// 2. 加入默认渲染成超链接的 router 链接 (to属性渲染为 href 属性)
&lt;router-link to=&quot;/zs&quot;&gt;toZs&lt;/router-link&gt;    
</code></pre>
<pre><code class="language-javascript">// 3. 设置路由占位符(路由填充位)
&lt;router-view&gt;&lt;/router-view&gt;  
</code></pre>
<pre><code class="language-javascript">// 4. 定义router's component模板
// 若动态参数较多以及需要换行考虑模板字符串``
var Haizeiwang = {template:&quot;&lt;div&gt;It's a test&lt;/div&gt;&quot;}
</code></pre>
<pre><code class="language-javascript">// 5. 创建VueRouter实例并配置规则
var myRouter = new VueRouter({routes:
[{path:&quot;/zs&quot;,component:Haizeiwang},...]}) 
// component后接组件名非string切忌&quot;&quot;
</code></pre>
<pre><code class="language-javascript">// 6. 路由挂载实例
var app = new Vue({el:&quot;#app&quot;,router:myRouter})
</code></pre>
<p>嵌套路由：</p>
<p>嵌套路由就是在路由实例中存在其他路由：</p>
<ul>
<li>被嵌套的路由组件模板中需新增的路由链接与路由占位符，这里有涉及换行，避免转译麻烦则使用ES6新增的模板字符串代替 <code>&quot;</code> ；</li>
<li>路由实例的配置文件中通过 children 数组添加子路由规则</li>
</ul>
<p>动态路由：</p>
<p>携带具有规律动态变化的参数的路由规则匹配，重点在动态参数、规则匹配。主要设置地方是创建路由实例对象的规则配置域中。</p>
<pre><code>&lt;!--示例代码如下：--&gt;
&lt;router-link to=&quot;/zairesinatra/1&quot;&gt;xx&lt;/router-link&gt;
&lt;router-link to=&quot;/zairesinatra/2&quot;&gt;zz&lt;/router-link&gt;
&lt;router-link to=&quot;/zairesinatra/3&quot;&gt;yy&lt;/router-link&gt;
......
&lt;!--而配置文件不必写为--&gt;
{path:'/zairesinatra/1',component:xx}
{path:'/zairesinatra/2',component:zz}
{path:'/zairesinatra/3',component:yy}
......
</code></pre>
<p>可简写为：</p>
<pre><code>// 路由规则配置中：
var myRouter = new VueRouter({
    //routes是路由规则数组
    routes: [
        //通过/:参数名  的形式传递参数 
        { path: &quot;/zairesinatra/:id&quot;, component: 组件名 },})
// 路由组件中
const Zs = {
	//路由组件中通过$route.params对象来获取路由参数
	template:'&lt;div&gt;zairesinatra{{$route.params.id}}&lt;/div&gt;'
}
</code></pre>
<p>而时常被诟病与路由高度耦合的的<code>$route.params.id</code>可换成<code>props</code>：</p>
<pre><code>// 路由组件模板
// 通过props来接收参数
var Zs = { 
    props:[&quot;id&quot;],
    template:&quot;&lt;div&gt;num：{{id}}&lt;/div&gt;&quot;
    }

// 路由实例与配置域
var myRouter = new VueRouter({
    //routes是路由规则数组
    routes: [
        // 通过/:参数名的形式传递参数 
        // 如果props设置为true，则route.params将会被设置为组件属性
        { path: &quot;/zairesinatra/:id&quot;, component: Zs, props:true },...]})
</code></pre>
<p>同时注意：如果是传递静态参数，props设置为对象；传递复杂参数时，props设置为箭头函数路由模板应使用mustache传值，且路由实例中props设置为带参数(route)箭头函数,返回值中动态项无需添加$，直接route.params.id即可。</p>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><h2 id="additionalconsiderations">Additional considerations</h2>
<h3 id="vbindfunctionsync">v-bind:Function &amp; .sync</h3>
<pre><code class="language-html">&lt;template&gt;
&lt;div&gt;
  &lt;BindFunc :parentHandler=&quot;parentHandler&quot; /&gt;
  &lt;SyncModefier v-bind:sync-data.sync=&quot;syncData&quot; :data-to-be-modified=&quot;dataToBeModified&quot; @setDataToBeModified=&quot;res =&gt; dataToBeModified = res&quot; /&gt;
  &lt;div&gt;{{dataToBeModified}}&lt;/div&gt;
  &lt;div&gt;{{syncData}}&lt;/div&gt;
&lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
import BindFunc from './components/BindFunc.vue'
import SyncModefier from './components/SyncModifier.vue'
export default {
  components: {
    BindFunc,
    SyncModefier
  },
  data () {
    return {
      dataToBeModified: 'value of dataToBeModified',
      syncData: 'value of syncData'
    }
  },
  methods: {
    parentHandler () {
      console.log('这是父组件的方法')
    }
  }
}
&lt;/script&gt;
</code></pre>
<pre><code class="language-html">&lt;template&gt;
  &lt;div&gt;SyncModefier =&gt; {{ syncData }} =&gt; {{ dataToBeModified }}&lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  name: 'SyncModefier',
  props: {
    dataToBeModified: {
      type: String,
      default: () =&gt; {
        return 'yes dataToBeModified default'
      }
    },
    syncData: {
      type: String,
      //   default: &quot;yes syncData default&quot;
      default: () =&gt; {
        return 'yes syncData default'
      }
    }
  },
  mounted () {
    this.$emit('setDataToBeModified', 'hello sync')
    this.$emit('update:syncData', 'hello syncData')
  }
}
&lt;/script&gt;
</code></pre>
<pre><code class="language-html">&lt;template&gt;
  &lt;div&gt;
    &lt;button @click=&quot;handler&quot;&gt;子组件的按钮 =&gt; 测试父组件向子组件传递函数方法&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  name: 'BindFunc',
  props: {
    parentHandler: {
      type: Function,
      default: () =&gt; {
        return Function
      }
    }
  },
  methods: {
    handler () {
      this.parentHandler()
    }
  }
}
&lt;/script&gt;
</code></pre>
<h3 id=""><a href="https://v2.cn.vuejs.org/v2/style-guide/">命名风格</a></h3>
<blockquote>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Template_literals">模板字面量</a>是允许嵌入表达式的字符串字面量，在 ES2015 规范前被称为模板字符串。模板字符串使用反引号 `` 来代替普通字符串中的用双引号和单引号，且包含特定语法（${expression}）的占位符。</p>
</blockquote>
<blockquote>
<p>JSX 是 JavaScript 的语法扩充，允许在 JS 中使用 HTML 的标签。</p>
</blockquote>
<p>测试一下测试一下测试一下测试一下测试一下测试一下测试一下测试一下测试一下测试一下测试一下测试一下测试一下测试一下</p>
<ul>
<li><a href="https://v2.cn.vuejs.org/v2/style-guide/#%E6%A8%A1%E6%9D%BF%E4%B8%AD%E7%9A%84%E7%BB%84%E4%BB%B6%E5%90%8D%E5%A4%A7%E5%B0%8F%E5%86%99%E5%BC%BA%E7%83%88%E6%8E%A8%E8%8D%90">组件名大小写</a></li>
</ul>
<p>单文件组件、JSX 和模板字符串中支持 PascalCase、kebab-case 风格；DOM 模板中仅支持 kebab-case 风格。</p>
<p>DOM 模板直接参与浏览器解析渲染，而模板字符串需要通过 Vue 将其编译转换成真正的 HTML 代码。</p>
<ul>
<li><a href="https://v2.cn.vuejs.org/v2/style-guide/#Prop-%E5%90%8D%E5%A4%A7%E5%B0%8F%E5%86%99%E5%BC%BA%E7%83%88%E6%8E%A8%E8%8D%90">prop 大小写</a></li>
</ul>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><h2 id="okkk">okkk</h2>
<h3 id="nexttick">nextTick</h3>
<p>测试一下测试一下测试一下测试一下测试一下测试一下测试一下测试一下测试一下测试一下测试一下</p>
<p>全局 API <a href="https://v2.cn.vuejs.org/v2/api/#Vue-nextTick">Vue.nextTick( [callback, context] )</a> 和实例方法 <a href="https://v2.cn.vuejs.org/v2/api/#vm-nextTick">vm.$nextTick( [callback] )</a> 都是在下次 DOM 更新循环结束之后执行延迟回调，不同的是后者回调的 this 会自动绑定到调用此方法的实例上。</p>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><h2 id="bug">BUG 分析</h2>
<ul>
<li><code>title</code>优化 ✔️</li>
</ul>
<p>针对不同打包环境展示不同内容，通过插件方式区别定义后报错如下:</p>
<pre><code>Template execution failed: ReferenceError: ❌... is not defined
ReferenceError: ❌... is not defined
  - index.html:7 eval
    [.]/[cli-service]/[html-webpack-plugin]/lib/loader.js!./public/index.html:7:
</code></pre>
<p><code>&lt;%= htmlWebpackPlugin.options.isProd ? '' : 'dev - ' %&gt;</code> 在注入模板字符串语法后，注释内容的不规范所导致。</p>
<ul>
<li>vue-ui新建项目 ✔️</li>
</ul>
<p>初始化项目时删除 <code>hello.vue</code> 后，在 <code>app.vue</code> 导入组件热编译运行报错:</p>
<pre><code>This relative module was not found:
* ../views/About.vue in ./src/router/index.js
</code></pre>
<p>项目中安装 router 依赖，需要及时更新 router 中对应的 index.js 相关初始化配置，指向 <code>app.vue</code>。</p>
<ul>
<li>warning ❓</li>
</ul>
<p>&quot;无法解析&quot; 的警告出现几率较为频繁，但是并不影响运行。<a href="https://github.com/vuejs/vue-cli/issues/2873">详情移步</a></p>
<pre><code>WARN  
Couldn't parse bundle asset &quot;/Users/.../zsvuex/dist/js/chunk-vendors.js&quot;.
Analyzer will use module sizes from stats file.
</code></pre>
<ul>
<li>echarts ✔️</li>
</ul>
<p>使用 Echarts 可视化图表，在按照官方文档说明进行敲代码时，遇见如下<a href="https://github.com/PanJiaChen/vue-admin-template/issues/607">报错</a>:</p>
<pre><code>[Echarts] TypeError: Cannot read property 'init' of undefined
</code></pre>
<p><code> var myChart = echarts.init(document.getElementById('main'));</code> 定位到存在  init 报错的位置。方法出现 undefined 考虑此调用对象的声明定义是否成功。补充代码 <code>var echarts = require('echarts');</code>。</p>
<ul>
<li>import ✔️</li>
</ul>
<p>引入 vant 组件库出现报错</p>
<pre><code>error  Import in body of module; reorder to top  import/first
</code></pre>
<p>代码格式规范要求所有的 <code>import</code> 在顶部，中间不允许出现其他代码，如<code>vue.use(vant)</code>。</p>
<ul>
<li>PostCSS Error ✔️</li>
</ul>
<p><code>npm install postcss-pxtorem -D</code> 下载将 px 转化为 rem 单位的插件出现报错:</p>
<pre><code>Syntax Error: Error: PostCSS plugin postcss-pxtorem requires PostCSS 8.
Migration guide for end-users:
https://github.com/postcss/postcss/wiki/PostCSS-8-for-end-users


 @ ./src/style/index.less ...
 @ ./src/main.js
 @ multi (webpack)-dev-server/client?http://192.xxx.xxx.2:8080&amp;sockPath=/sockjs-node (webpack)/hot/dev-server.js ./src/main.js
</code></pre>
<p>由于 postcss-pxtorem 版本过高，放弃了对旧 Node.js 版本的支持。考虑到 PostCSS 8 未带来重大的 API 更改。先执行: <code>npm uninstall postcss-pxtorem</code> 卸载当前版本。在 package.json 中 devDependencies 下添加&quot;postcss-pxtorem&quot;: &quot;^5.1.1&quot;，执行 <code>npm i</code> 安装制定版本包。</p>
<ul>
<li>ElementUI 按需加载后启动项目时的 babel-preset-es2015 报错。</li>
</ul>
<p>项目使用 @vue/cli 4.5.x 脚手架工具构建，根据<a href="https://element.eleme.cn/#/zh-CN/component/quickstart">官方文档</a>中的提示按需引入。babelrc 和 babel.config.js 的区别在于，前者只会影响本项目中的代码，而后者会影响整个项目中的代码，包含 node_modules。</p>
<pre><code class="language-js">// 出错配置
module.exports = {
  &quot;presets&quot;: [
    '@vue/cli-plugin-babel/preset',[&quot;es2015&quot;, { &quot;modules&quot;: false }]
  ],
  &quot;plugins&quot;: [
    [
      &quot;component&quot;,
      {
        &quot;libraryName&quot;: &quot;element-ui&quot;,
        &quot;styleLibraryName&quot;: &quot;theme-chalk&quot;
      }
    ]
  ]
}
</code></pre>
<pre><code class="language-js">// Error
Cannot find module 'babel-preset-es2015'
</code></pre>
<p>修改 babel.config.js 文件，将 es2015 改为 @babel/preset-env。</p>
<pre><code class="language-js">// 正解配置
module.exports = {
  &quot;presets&quot;: [
    '@vue/cli-plugin-babel/preset',[&quot;@babel/preset-env&quot;, { &quot;modules&quot;: false }]
  ],
  &quot;plugins&quot;: [
    [
      &quot;component&quot;,
      {
        &quot;libraryName&quot;: &quot;element-ui&quot;,
        &quot;styleLibraryName&quot;: &quot;theme-chalk&quot;
      }
    ]
  ]
}
</code></pre>
<ul>
<li>引入字体</li>
</ul>
<p>将后缀名为 .ttf、.otf、.eot 等格式的字体包放入新建的 fonts 文件夹，并创建一个 fonts.css 文件用于定义所用字体。在 app.vue 中引入 fonts.css。</p>
<pre><code class="language-javascript">@font-face: {
  font-family: 'xxxyyy';
  /* 重命名字体名 */
  src: url('./xxxxxx.otf');
  font-weight: normal;
  font-style: normal;
}
</code></pre>
<pre><code class="language-javascript">&lt;style lang=&quot;scss&quot;&gt;
  @import './assets/fonts/fonts.css';
  #app {
    font-family: 'xxxyyy';
    font-weight: normal;
  }
&lt;/style&gt;
</code></pre>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><h2 id="">结束</h2>
<p>本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh"> CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
<!--kg-card-end: markdown-->
    </section>

    <section class="article-comments gh-canvas">
        
        <script src="https://utteranc.es/client.js"
        repo="Zairesinatra/comments-by-utterances"
        issue-term="pathname"
        theme="photon-dark"
        crossorigin="anonymous"
        async>
        </script>
    </section>

</article>
</main>

    <section class="footer-cta outer">
        <div class="inner">
            <h2 class="footer-cta-title">Sign up for more like this.</h2>
            <a class="footer-cta-button" href="index.html#/portal" data-portal>
                <div class="footer-cta-input">Enter your email</div>
                <span>Subscribe</span>
            </a>
        </div>
    </section>



            <aside class="read-more-wrap outer">
                <div class="read-more inner">
                        
<article class="post-card post">

    <a class="post-card-image-link" href="../vim-neovim/index.html">

        <img class="post-card-image"
            srcset="../content/images/size/w1000/2023/03/ScenicViewOfBeachDuringDaytime.jpg 1000w"
            sizes="(max-width: 1000px) 400px, 800px"
            src="../content/images/size/w600/2023/03/ScenicViewOfBeachDuringDaytime.jpg"
            alt="Scenic View Of Beach During Daytime"
            loading="lazy"
        />


    </a>

    <div class="post-card-content">

        <a class="post-card-content-link" href="../vim-neovim/index.html">
            <header class="post-card-header">
                <div class="post-card-tags">
                </div>
                <h2 class="post-card-title">
                    Vim &amp; Neovim
                </h2>
            </header>
                <div class="post-card-excerpt">Vim ninjas count every keystroke!</div>
        </a>

        <footer class="post-card-meta">
            <time class="post-card-meta-date" datetime="2022-12-12">Dec 12, 2022</time>
                <span class="post-card-meta-length">19 min read</span>
        </footer>

    </div>

</article>
                        
<article class="post-card post">

    <a class="post-card-image-link" href="../design-patterns/index.html">

        <img class="post-card-image"
            srcset="../content/images/size/w1000/2023/03/SixHalogenBulbs.jpg 1000w"
            sizes="(max-width: 1000px) 400px, 800px"
            src="../content/images/size/w600/2023/03/SixHalogenBulbs.jpg"
            alt="Six Halogen Bulbs"
            loading="lazy"
        />


    </a>

    <div class="post-card-content">

        <a class="post-card-content-link" href="../design-patterns/index.html">
            <header class="post-card-header">
                <div class="post-card-tags">
                </div>
                <h2 class="post-card-title">
                    Design Patterns And ...
                </h2>
            </header>
                <div class="post-card-excerpt">"A good programmer is someone who always looks both ways before crossing a one-way street." - Doug Linder</div>
        </a>

        <footer class="post-card-meta">
            <time class="post-card-meta-date" datetime="2022-08-08">Aug 8, 2022</time>
                <span class="post-card-meta-length">35 min read</span>
        </footer>

    </div>

</article>
                        
<article class="post-card post">

    <a class="post-card-image-link" href="../g-toc-css/index.html">

        <img class="post-card-image"
            srcset="../content/images/size/w1000/2023/03/GlassBottleFilledWithBlackStrawonBrownWoodenTable.jpg 1000w"
            sizes="(max-width: 1000px) 400px, 800px"
            src="../content/images/size/w600/2023/03/GlassBottleFilledWithBlackStrawonBrownWoodenTable.jpg"
            alt="Glass Bottle Filled With Black Straw on Brown Wooden Table"
            loading="lazy"
        />


    </a>

    <div class="post-card-content">

        <a class="post-card-content-link" href="../g-toc-css/index.html">
            <header class="post-card-header">
                <div class="post-card-tags">
                </div>
                <h2 class="post-card-title">
                    G&amp;TOC&amp;CSS
                </h2>
            </header>
                <div class="post-card-excerpt">TOC 的需求实现以及相关的思考总结。</div>
        </a>

        <footer class="post-card-meta">
            <time class="post-card-meta-date" datetime="2022-05-01">May 1, 2022</time>
                <span class="post-card-meta-length">6 min read</span>
        </footer>

    </div>

</article>
                </div>
            </aside>



    </div>
    <div class="docsearchwrapper"><div id="docsearch"></div></div>
    <div class="arrowup">
      <svg
        version="1.1"
        id="Layer_1"
        xmlns="http://www.w3.org/2000/svg"
        xmlns:xlink="http://www.w3.org/1999/xlink"
        x="0px"
        y="0px"
        width="20px"
        height="20px"
        viewBox="0 0 122.883 122.882"
        enable-background="new 0 0 20 20"
        xml:space="preserve"
      >
        <g>
          <path
            d="M0,61.441L0,61.441h0.018c0,16.976,6.872,32.335,17.98,43.443c11.108,11.107,26.467,17.979,43.441,17.979v0.018h0.001 h0.001v-0.018c16.974,0,32.335-6.872,43.443-17.98s17.98-26.467,17.98-43.441h0.018v-0.001V61.44h-0.018 c0-16.975-6.873-32.334-17.98-43.443C93.775,6.89,78.418,0.018,61.443,0.018V0h-0.002l0,0v0.018 c-16.975,0-32.335,6.872-43.443,17.98C6.89,29.106,0.018,44.465,0.018,61.439H0V61.441L0,61.441z M42.48,71.7 c-1.962,1.908-5.101,1.865-7.009-0.098c-1.909-1.962-1.865-5.101,0.097-7.009l22.521-21.839l3.456,3.553l-3.46-3.569 c1.971-1.911,5.117-1.862,7.029,0.108c0.055,0.058,0.109,0.115,0.16,0.175L87.33,64.594c1.963,1.908,2.006,5.047,0.098,7.009 c-1.908,1.963-5.047,2.006-7.01,0.098L61.53,53.227L42.48,71.7L42.48,71.7z"
          />
        </g>
      </svg>
    </div>
    <footer class="site-footer outer">
        <div class="inner">
            <section class="copyright"><a href="../index.html">zairesinatra</a> &copy; 2023</section>
            <nav class="site-footer-nav">
                
            </nav>
            <div><a href="https://ghost.org/" target="_blank" rel="noopener">Powered by Ghost</a></div>
        </div>
    </footer>
</div>


<script
    src="https://code.jquery.com/jquery-3.5.1.min.js"
    integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0="
    crossorigin="anonymous">
</script>
<script src="../assets/built/casper.js%3Fv=7d64696598"></script>
<script>
$(document).ready(function () {
    // Mobile Menu Trigger
    $('.gh-burger').click(function () {
        $('body').toggleClass('gh-head-open');
    });
    // FitVids - Makes video embeds responsive
    $(".gh-content").fitVids();
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.18.2/tocbot.min.js"></script>
<script>
  tocbot.init({
    tocSelector: '.toc',
    contentSelector: '.gh-content',
    hasInnerContainers: true
  });
  var tc = document.querySelector(".toc-container");
  if(tc){
    var tch = tc.clientHeight;
    var ah = document.querySelector(".article-header");
    var ahh = ah.clientHeight;
    window.addEventListener("scroll", function () {
    if(document.body.clientWidth > 1170){
      var scrollY = document.documentElement.scrollTop || document.body.scrollTop;
      var ihh = window.innerHeight;
      if(scrollY >= ihh + tch + ahh){
        var ctc = document.querySelector(".toc-container");
        ctc.style.position="sticky";
        ctc.style.position="-webkit-sticky";
        ctc.style.top = "120px";
        ctc.style.marginLeft = "800px";
        ctc.style.minWidth= "260px";
      }
      if(scrollY < tch + ahh -10){
        var ctc = document.querySelector(".toc-container");
        ctc.style.position="";
        ctc.style.top = "";
        ctc.style.marginLeft = "";
      }
    }})
  }
</script>
<script>
  function searchFunc(){
    let autocomplete = document.querySelector("#autocomplete");
    let algoliaouterwrapper = document.querySelector(".algoliaouterwrapper");
    // console.log(algoliaouterwrapper,autocomplete);
    autocomplete.parentNode.removeChild(autocomplete);
    algoliaouterwrapper.appendChild(autocomplete);
    autocomplete.style.marginTop = "50px";
    algoliaouterwrapper.style.background = '#F5F5FA';
    algoliaouterwrapper.style.display = "block";
    algoliaouterwrapper.style.zIndex = 99999;
    autocomplete.addEventListener('click', function(event) {
      event.stopPropagation();
    });
  }
  function outerwrapperFunc(event){
    event.stopPropagation();
    let autocomplete = document.querySelector("#autocomplete");
    let algoliawrapper = document.querySelector(".algoliawrapper");
    let algoliaouterwrapper = document.querySelector(".algoliaouterwrapper");
    autocomplete.parentNode.removeChild(autocomplete);
    algoliawrapper.appendChild(autocomplete);
    algoliaouterwrapper.style.background = '';
    algoliaouterwrapper.style.display = "none";
    algoliaouterwrapper.style.zIndex = 0;
    autocomplete.removeEventListener('click', function(event) {
      event.stopPropagation();
    });
  }
  function searchFuncMobile (){
    let mobileTrigger = document.querySelector(".aa-DetachedSearchButton");
    mobileTrigger.click();
  }
</script>

<script>
  const cmdkevent = new KeyboardEvent('keydown', {
    metaKey: true,
    key: 'k',
  });
  function docSearchFuncMobile(){
    const DocSearchElement = document.querySelector(".DocSearch");
    DocSearchElement.click();
    console.log(DocSearchElement);
  }
</script>


<!-- searchinghost-easy -->
<!--
<script src="https://cdn.jsdelivr.net/gh/gmfmi/searchinghost-easy@latest/dist/searchinghost-easy-basic.js"></script>
<script>
    new SearchinGhostEasy({
        contentApiKey: 'e93d8b3520ae46be52c9a4b140'
    });
</script>
-->

<script>
    let currentTheme = localStorage.getItem("theme-color");
    const switchTheme = function () {
        const storedTheme = localStorage.getItem("theme-color") || "theme-light";
        if (
            storedTheme === "theme-dark" &&
            document.getElementsByTagName("html")[0].className !== ""
        ) {
            localStorage.setItem("theme-color", "theme-light");
            currentTheme = localStorage.getItem("theme-color");
            if (currentTheme === "theme-light") {
            document.getElementsByTagName("html")[0].classList.remove("dark-mode");
            document
                .getElementsByClassName("theme-switcher")[0]
                ?.classList.remove("active");
            document
                .getElementsByClassName("toc")[0]
                ?.classList.remove("active");
            }
        } else {
            localStorage.setItem("theme-color", "theme-dark");
            currentTheme = localStorage.getItem("theme-color");
            if (currentTheme === "theme-dark") {
            // console.log(document.getElementById("app"));
            document.getElementsByTagName("html")[0].classList.add("dark-mode");
            document
                .getElementsByClassName("theme-switcher")[0]
                ?.classList.add("active");
            document
                .getElementsByClassName("toc")[0]
                ?.classList.add("active");
            }
        }
    };
    const initTheme = function () {
    const storedTheme = localStorage.getItem("theme-color") || "theme-light";
    if (storedTheme === "theme-dark") {
        document
        .getElementsByClassName("theme-switcher")[0]
        ?.classList.add("active");
        document
        .getElementsByClassName("toc")[0]
        ?.classList.add("active");
        document.getElementsByTagName("html")[0].classList.add("dark-mode");
    }
    };
    initTheme()
</script>

<!-- Arrow up -->
<script>
const arrowup = document.querySelector(".arrowup");
arrowup.addEventListener("click", function() {
  const scrollDuration = 1500; // 滚动持续时间，单位毫秒
    const start = window.pageYOffset; // 当前滚动位置
    const end = 0; // 滚动结束位置
    const distance = end - start; // 滚动距离
    const startTime = performance.now(); // 动画开始时间

    function easeInOutCubic(t) {
      return t < 0.5
        ? 4 * t ** 3
        : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
    }

    function scrollToTopSmooth(timestamp) {
      const currentTime = timestamp - startTime; // 已经经过的时间
      const progress = currentTime / scrollDuration; // 滚动进度
      const position =
        start + distance * easeInOutCubic(Math.min(progress, 1)); // 当前滚动位置
      window.scrollTo(0, position); // 滚动到新位置

      if (currentTime < scrollDuration) {
        // 如果滚动还未结束，则继续执行动画
        requestAnimationFrame(scrollToTopSmooth);
      }
    }

    requestAnimationFrame(scrollToTopSmooth);
});
</script>

<style>
    /*
.gt-container .gt-svg {
    display: none;
}
    */
</style>

<!-- Algolia -->
<!-- 在 HTML 文件中引入 Algolia 的库文件 -->
<script src="https://cdn.jsdelivr.net/npm/@algolia/autocomplete-js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@algolia/autocomplete-theme-classic"/>
<script src="https://cdn.jsdelivr.net/npm/algoliasearch@4.16.0/dist/algoliasearch.umd.min.js"></script>
<style>
.algoliawrapper {
  margin-top: 6rem;
}
.imgwrapper {
  width: 5rem;
}
.algoliaouterwrapper {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  display: none;
  z-index: 0;
  height: 100%;
  width: 100%;
}
.aa-Panel {
  z-index: 99999;
}
.algoliaouterwrapper i {
  cursor: pointer;
}
.algoliaouterwrapper i svg {
  width: 4rem;
  height: 4rem;
  position: absolute;
  right: 25px;
  top: 52px;
}
.showwrapper {
  display: flex;
  justify-content: space-between;
  align-items: center;
  direction: column;
}
#autocomplete {
  left: 50%;
  transform: translate(50%, 0);
  width: 50%;
}
</style>

<style>
.docsearchwrapper{
  margin-top: 6rem;
  width: 100%;
  height: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  display: none;
}
.DocSearch-Container{
  z-index: 9999999;
}
</style>

<script type="text/javascript">
  docsearch({
    appId: "722DYFSYDR",
    apiKey: "5b7d4a36b43ac3d135ca6b83ac715f7e",
    indexName: "zairesinatraio",
    container: document.querySelector("#docsearch"),
    debug: false // Set debug to true if you want to inspect the modal
  });
</script>

</body>
</html>
