<!DOCTYPE html>
<html ⚡>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">

    <title>Spring5</title>

    <meta name="description" content="Java Spring5 框架" />
    <link rel="icon" href="../../content/images/size/w256h256/2021/07/ghost-orb.png" type="image/png" />
    <link rel="canonical" href="../index.html" />
    <meta name="referrer" content="no-referrer-when-downgrade" />
    
    <meta property="og:site_name" content="zairesinatra" />
    <meta property="og:type" content="article" />
    <meta property="og:title" content="Spring5" />
    <meta property="og:description" content="Java Spring5 框架" />
    <meta property="og:url" content="yourdomain.com/spring5/" />
    <meta property="og:image" content="yourdomain.com/content/images/2022/05/GreyWhiteClouds.JPG" />
    <meta property="article:published_time" content="2020-05-25T12:20:00.000Z" />
    <meta property="article:modified_time" content="2022-12-28T10:05:10.000Z" />
    <meta property="article:tag" content="Technology growth" />
    
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Spring5" />
    <meta name="twitter:description" content="Java Spring5 框架" />
    <meta name="twitter:url" content="yourdomain.com/spring5/" />
    <meta name="twitter:image" content="yourdomain.com/content/images/2022/05/GreyWhiteClouds.JPG" />
    <meta name="twitter:label1" content="Written by" />
    <meta name="twitter:data1" content="Ziyi Xie" />
    <meta name="twitter:label2" content="Filed under" />
    <meta name="twitter:data2" content="Technology growth" />
    <meta name="twitter:site" content="@xieziyi0422" />
    <meta property="og:image:width" content="2000" />
    <meta property="og:image:height" content="1125" />
    
    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "publisher": {
        "@type": "Organization",
        "name": "zairesinatra",
        "url": "yourdomain.com/",
        "logo": {
            "@type": "ImageObject",
            "url": "yourdomain.com/content/images/2021/07/zs-1.JPG",
            "width": 60,
            "height": 60
        }
    },
    "author": {
        "@type": "Person",
        "name": "Ziyi Xie",
        "image": {
            "@type": "ImageObject",
            "url": "yourdomain.com/content/images/2021/07/zs-2.JPG",
            "width": 1079,
            "height": 1079
        },
        "url": "yourdomain.com/author/ziyi/",
        "sameAs": []
    },
    "headline": "Spring5",
    "url": "yourdomain.com/spring5/",
    "datePublished": "2020-05-25T12:20:00.000Z",
    "dateModified": "2022-12-28T10:05:10.000Z",
    "image": {
        "@type": "ImageObject",
        "url": "yourdomain.com/content/images/2022/05/GreyWhiteClouds.JPG",
        "width": 2000,
        "height": 1125
    },
    "keywords": "Technology growth",
    "description": "Java Spring5 框架",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "yourdomain.com/"
    }
}
    </script>

    <meta name="generator" content="Ghost 5.25" />
    <link rel="alternate" type="application/rss+xml" title="zairesinatra" href="../../rss/index.html" />

    <style amp-custom>
    *,
    *::before,
    *::after {
        box-sizing: border-box;
    }

    html {
        overflow-x: hidden;
        overflow-y: scroll;
        font-size: 62.5%;
        -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
    }

    body {
        min-height: 100vh;
        margin: 0;
        padding: 0;
        color: #3a4145;
        font-family: -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Open Sans,Helvetica Neue,sans-serif;
        font-size: 1.7rem;
        line-height: 1.55em;
        font-weight: 400;
        font-style: normal;
        background: #fff;
        scroll-behavior: smooth;
        overflow-x: hidden;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
    }

    p,
    ul,
    ol,
    li,
    dl,
    dd,
    hr,
    pre,
    form,
    table,
    video,
    figure,
    figcaption,
    blockquote {
        margin: 0;
        padding: 0;
    }

    ul[class],
    ol[class] {
        padding: 0;
        list-style: none;
    }

    img {
        display: block;
        max-width: 100%;
    }

    input,
    button,
    select,
    textarea {
        font: inherit;
        -webkit-appearance: none;
    }

    fieldset {
        margin: 0;
        padding: 0;
        border: 0;
    }

    label {
        display: block;
        font-size: 0.9em;
        font-weight: 700;
    }

    hr {
        position: relative;
        display: block;
        width: 100%;
        height: 1px;
        border: 0;
        border-top: 1px solid currentcolor;
        opacity: 0.1;
    }

    ::selection {
        text-shadow: none;
        background: #cbeafb;
    }

    mark {
        background-color: #fdffb6;
    }

    small {
        font-size: 80%;
    }

    sub,
    sup {
        position: relative;
        font-size: 75%;
        line-height: 0;
        vertical-align: baseline;
    }
    sup {
        top: -0.5em;
    }
    sub {
        bottom: -0.25em;
    }

    ul li + li {
        margin-top: 0.6em;
    }

    a {
        color: var(--ghost-accent-color, #1292EE);
        text-decoration-skip-ink: auto;
    }

    h1,
    h2,
    h3,
    h4,
    h5,
    h6 {
        margin: 0;
        font-weight: 700;
        color: #121212;
        line-height: 1.4em;
    }

    h1 {
        font-size: 3.4rem;
        line-height: 1.1em;
    }

    h2 {
        font-size: 2.4rem;
        line-height: 1.2em;
    }

    h3 {
        font-size: 1.8rem;
    }

    h4 {
        font-size: 1.7rem;
    }

    h5 {
        font-size: 1.6rem;
    }

    h6 {
        font-size: 1.6rem;
    }

    amp-img {
        height: 100%;
        width: 100%;
        max-width: 100%;
        max-height: 100%;
    }

    amp-img img {
        object-fit: cover;
    }
    
    amp-youtube {
        height: calc(100vw / 1.78);
        width: 100vw;
        position: relative;
    }

    amp-youtube img {
        position: absolute;
    }

    .page-header {
        padding: 50px 5vmin 30px;
        text-align: center;
        font-size: 2rem;
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }

    .page-header a {
        color: #121212;
        font-weight: 700;
        text-decoration: none;
        font-size: 1.6rem;
        letter-spacing: -0.1px;
    }

    .post {
        max-width: 680px;
        margin: 0 auto;
    }

    .post-header {
        margin: 0 5vmin 5vmin;
        text-align: center;
    }

    .post-meta {
        margin: 1rem 0 0 0;
        text-transform: uppercase;
        color: #738a94;
        font-weight: 500;
        font-size: 1.3rem;
    }

    .post-image {
        margin: 0 0 5vmin;
    }

    .post-image img {
        display: block;
        width: 100%;
        height: auto;
    }

    .post-content {
        padding: 0 5vmin;
    }

    .post-content > * + * {
        margin-top: 1.5em;
    }

    .post-content [id]:not(:first-child) {
        margin: 2em 0 0;
    }

    .post-content > [id] + * {
        margin-top: 1rem;
    }

    .post-content [id] + .kg-card,
    .post-content blockquote + .kg-card {
        margin-top: 40px;
    }

    .post-content > ul,
    .post-content > ol,
    .post-content > dl {
        padding-left: 1.9em;
    }

    .post-content hr {
        margin-top: 40px;
    }

    .post .post-content hr + * {
        margin-top: 40px;
    }

    .post-content amp-img {
        background-color: #f8f8f8;
    }

    .post-content blockquote {
        position: relative;
        font-style: italic;
    }

    .post-content blockquote::before {
        content: "";
        position: absolute;
        left: -1.5em;
        top: 0;
        bottom: 0;
        width: 0.3rem;
        background: var(--ghost-accent-color, #1292EE);
    }

    .post-content blockquote.kg-blockquote-alt {
        font-size: 1.2em;
        font-style: italic;
        line-height: 1.6em;
        text-align: center;
        color: #738a94;
        padding: 0.75em 3em 1.25em;
    }

    .post-content blockquote.kg-blockquote-alt::before {
        display: none;
    }

    .post-content :not(.kg-card):not([id]) + .kg-card {
        margin-top: 40px;
    }

    .post-content .kg-card + :not(.kg-card) {
        margin-top: 40px;
    }

    .kg-card figcaption {
        padding: 1.5rem 1.5rem 0;
        text-align: center;
        font-weight: 500;
        font-size: 1.3rem;
        line-height: 1.4em;
        opacity: 0.6;
    }

    .kg-card figcaption strong {
        color: rgba(0,0,0,0.8);
    }

    .post-content :not(pre) code {
        vertical-align: middle;
        padding: 0.15em 0.4em 0.15em;
        border: #e1eaef 1px solid;
        font-weight: 400;
        font-size: 0.9em;
        line-height: 1em;
        color: #15171a;
        background: #f0f6f9;
        border-radius: 0.25em;
    }

    .post-content > pre {
        overflow: scroll;
        padding: 16px 20px;
        color: #fff;
        background: #1F2428;
        border-radius: 5px;
        box-shadow: 0 2px 6px -2px rgba(0,0,0,.1), 0 0 1px rgba(0,0,0,.4);
    }

    .kg-embed-card {
        display: flex;
        flex-direction: column;
        align-items: center;
        width: 100%;
    }

    .kg-image-card img {
        margin: auto;
    }

    .kg-gallery-card + .kg-gallery-card {
        margin-top: 0.75em;
    }

    .kg-gallery-container {
        position: relative;
    }

    .kg-gallery-row {
        display: flex;
        flex-direction: row;
        justify-content: center;
    }

    .kg-gallery-image {
        width: 100%;
        height: 100%;
    }

    .kg-gallery-row:not(:first-of-type) {
        margin: 0.75em 0 0 0;
    }

    .kg-gallery-image:not(:first-of-type) {
        margin: 0 0 0 0.75em;
    }

    .kg-bookmark-card,
    .kg-bookmark-publisher {
        position: relative;
    }

    .kg-bookmark-container,
    .kg-bookmark-container:hover {
        display: flex;
        flex-wrap: wrap;
        flex-direction: row-reverse;
        color: currentColor;
        background: rgba(255,255,255,0.6);
        font-family: -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Open Sans,Helvetica Neue,sans-serif;
        text-decoration: none;
        border-radius: 3px;
        box-shadow: 0 2px 6px -2px rgba(0, 0, 0, 0.1), 0 0 1px rgba(0, 0, 0, 0.4);
        overflow: hidden;
    }

    .kg-bookmark-content {
        flex-basis: 0;
        flex-grow: 999;
        padding: 20px;
        order: 1;
    }

    .kg-bookmark-title {
        font-weight: 600;
        font-size: 1.5rem;
        line-height: 1.3em;
    }

    .kg-bookmark-description {
        display: -webkit-box;
        max-height: 45px;
        margin: 0.5em 0 0 0;
        font-size: 1.4rem;
        line-height: 1.55em;
        overflow: hidden;
        opacity: 0.8;
        -webkit-line-clamp: 2;
        -webkit-box-orient: vertical;
    }

    .kg-bookmark-metadata {
        margin-top: 20px;
    }

    .kg-bookmark-metadata {
        display: flex;
        align-items: center;
        font-weight: 500;
        font-size: 1.3rem;
        line-height: 1.3em;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    .kg-bookmark-description {
        display: -webkit-box;
        -webkit-box-orient: vertical;
        -webkit-line-clamp: 2;
        overflow: hidden;
    }

    .kg-bookmark-metadata amp-img {
        width: 18px;
        height: 18px;
        max-width: 18px;
        max-height: 18px;
        margin-right: 10px;
    }

    .kg-bookmark-thumbnail {
        display: flex;
        flex-basis: 20rem;
        flex-grow: 1;
        justify-content: flex-end;
    }

    .kg-bookmark-thumbnail amp-img {
        max-height: 200px;
    }

    .kg-bookmark-author {
        white-space: nowrap;
        text-overflow: ellipsis;
        overflow: hidden;
    }

    .kg-bookmark-publisher::before {
        content: "•";
        margin: 0 .5em;
    }

    .kg-toggle-card-icon {
        display: none;
    }

    .kg-toggle-content {
        margin-top: 0.8rem;
    }

    .kg-product-card-container {
        background: transparent;
        padding: 20px;
        width: 100%;
        border-radius: 5px;
        box-shadow: inset 0 0 0 1px rgb(124 139 154 / 25%);
    }

    .kg-product-card-description p {
        margin-top: 1.5em;
    }

    .kg-product-card-description ul {
        margin-left: 24px;
    }

    .kg-product-card-title {
        font-size: 1.9rem;
        font-weight: 700;
    }

    .kg-product-card-rating-star {
        height: 28px;
        width: 20px;
        margin-right: 2px;
    }

    .kg-product-card-rating-star svg {
    width: 16px;
    height: 16px;
    fill: currentColor;
    opacity: 0.15;
    }

    .kg-product-card-rating-active.kg-product-card-rating-star svg {
    opacity: 1;
    }

    .kg-nft-card-container {
        position: relative;
        display: flex;
        flex: auto;
        flex-direction: column;
        text-decoration: none;
        font-family: -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Open Sans,Helvetica Neue,sans-serif;
        font-size: 1.4rem;
        font-weight: 400;
        box-shadow: 0 2px 6px -2px rgb(0 0 0 / 10%), 0 0 1px rgb(0 0 0 / 40%);
        width: 100%;
        max-width: 512px;
        color: #15212A;
        background: #fff;
        border-radius: 5px;
        transition: none;
        margin: 0 auto;
    }

    .kg-nft-metadata {
        padding: 2.0rem;
    }

    .kg-nft-image-container {
        position: relative;
    }

    .kg-nft-image {
        display: flex;
        border-radius: 5px 5px 0 0;
    }

    .kg-nft-header {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        gap: 20px;
    }

    .kg-nft-header h4.kg-nft-title {
        font-size: 1.9rem;
        font-weight: 700;
        margin: 0;
        color: #15212A;
    }

    .kg-nft-header amp-img {
        max-width: 114px;
        max-height: 26px;
    }

    .kg-nft-opensea-logo {
        margin-top: 2px;
        width: 100px;
    }

    .kg-nft-creator {
        font-family: inherit;
        color: #95A1AD;
    }

    .kg-nft-creator span {
        font-weight: 500;
        color: #15212A;
    }

    .kg-nft-card p.kg-nft-description {
        font-size: 1.4rem;
        line-height: 1.4em;
        margin: 2.0rem 0 0;
        color: #222;
    }

    .kg-button-card {
        display: flex;
        position: static;
        align-items: center;
        width: 100%;
        justify-content: center;
    }

    .kg-btn {
        display: flex;
        position: static;
        align-items: center;
        padding: 0 2.0rem;
        height: 4.0rem;
        line-height: 4.0rem;
        font-size: 1.65rem;
        font-weight: 600;
        text-decoration: none;
        border-radius: 5px;
        transition: opacity 0.2s ease-in-out;
    }

    .kg-btn:hover {
        opacity: 0.85;
    }

    .kg-btn-accent {
        background-color: var(--ghost-accent-color, #1292EE);
        color: #fff;
    }

    .kg-callout-card {
        display: flex;
        padding: 20px 28px;
        border-radius: 3px;
    }

    .kg-callout-card-grey {
        background: rgba(124, 139, 154, 0.13);
    }

    .kg-callout-card-white {
        background: transparent;
        box-shadow: inset 0 0 0 1px rgba(124, 139, 154, 0.25);
    }

    .kg-callout-card-blue {
        background: rgba(33, 172, 232, 0.12);
    }

    .kg-callout-card-green {
        background: rgba(52, 183, 67, 0.12);
    }

    .kg-callout-card-yellow {
        background: rgba(240, 165, 15, 0.13);
    }

    .kg-callout-card-red {
        background: rgba(209, 46, 46, 0.11);
    }

    .kg-callout-card-pink {
        background: rgba(225, 71, 174, 0.11);
    }

    .kg-callout-card-purple {
        background: rgba(135, 85, 236, 0.12);
    }

    .kg-callout-card-accent {
        background: var(--ghost-accent-color);
        color: #fff;
    }

    .kg-callout-card-accent a {
        color: #fff;
    }

    .kg-callout-emoji {
        padding-right: 16px;
        line-height: 1.3;
        font-size: 1.25em;
    }

    .kg-header-card {
        padding: 6em 3em;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        text-align: center;
    }

    .kg-header-card.kg-size-small {
        padding-top: 4em;
        padding-bottom: 4em;
    }

    .kg-header-card.kg-size-large {
        padding-top: 12em;
        padding-bottom: 12em;
    }

    .kg-header-card.kg-width-full {
        padding-left: 4em;
        padding-right: 4em;
    }

    .kg-header-card.kg-align-left {
        text-align: left;
        align-items: flex-start;
    }

    .kg-header-card.kg-style-dark {
        background: #15171a;
        color: #ffffff;
    }

    .kg-header-card.kg-style-light {
        color: #15171a;
        border: 1px solid rgba(124, 139, 154, 0.25);
        border-width: 1px 0;
    }

    .kg-header-card.kg-style-accent {
        background-color: var(--ghost-accent-color);
    }

    .kg-header-card.kg-style-image {
        background-color: #e7e7eb;
        background-size: cover;
        background-position: center center;
    }

    .kg-header-card h2 {
        font-size: 4em;
        font-weight: 700;
        line-height: 1.1em;
        margin: 0;
    }

    .kg-header-card h2 strong {
        font-weight: 800;
    }

    .kg-header-card.kg-size-small h2 {
        font-size: 3em;
    }

    .kg-header-card.kg-size-large h2 {
        font-size: 5em;
    }

    .kg-header-card h3 {
        font-size: 1.25em;
        font-weight: 500;
        line-height: 1.3em;
        margin: 0;
    }

    .kg-header-card h3 strong {
        font-weight: 600;
    }

    .kg-header-card.kg-size-small h3 {
        font-size: 1em;
    }

    .kg-header-card.kg-size-large h3 {
        font-size: 1.5em;
    }

    .kg-header-card:not(.kg-style-light) h2,
    .kg-header-card:not(.kg-style-light) h3 {
        color: #ffffff;
    }

    .kg-header-card a.kg-header-card-button {
        display: flex;
        position: static;
        align-items: center;
        padding: 0 1.2em;
        height: 2.4em;
        line-height: 1em;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", "Oxygen", "Ubuntu", "Cantarell", "Fira Sans", "Droid Sans", "Helvetica Neue", sans-serif;
        font-size: 0.95em;
        font-weight: 600;
        text-decoration: none;
        border-radius: 5px;
        transition: opacity 0.2s ease-in-out;
        background-color: var(--ghost-accent-color);
        color: #ffffff;
        margin: 1.75em 0 0;
    }

    .kg-header-card a.kg-header-card-button:hover {
        opacity: 0.85;
    }

    .kg-header-card.kg-size-large a.kg-header-card-button {
        margin-top: 2em;
    }

    .kg-header-card.kg-size-small a.kg-header-card-button {
        margin-top: 1.5em;
    }

    .kg-header-card.kg-style-image a.kg-header-card-button,
    .kg-header-card.kg-style-dark a.kg-header-card-button {
        background: #ffffff;
        color: #15171a;
    }

    .kg-header-card.kg-style-accent a.kg-header-card-button {
        background: #ffffff;
        color: var(--ghost-accent-color);
    }

    .kg-audio-card {
        display: flex;
        width: 100%;
        box-shadow: inset 0 0 0 1px rgba(124, 139, 154, 0.25);
    }

    .kg-audio-thumbnail {
        display: flex;
        justify-content: center;
        align-items: center;
        width: 80px;
        min-width: 80px;
        height: 80px;
        background: transparent;
        object-fit: cover;
        aspect-ratio: 1/1;
        border-radius: 3px 0 0 3px;
    }

    .kg-audio-thumbnail.placeholder {
        background: var(--ghost-accent-color);
    }

    .kg-audio-thumbnail.placeholder svg {
        width: 24px;
        height: 24px;
        fill: white;
    }

    .kg-audio-player-container {
        position: relative;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        width: 100%;
        --seek-before-width: 0%;
        --volume-before-width: 100%;
        --buffered-width: 0%;
    }

    .kg-audio-title {
        width: 100%;
        padding: 8px 12px 0;
        border: none;
        font-family: inherit;
        font-size: 1.1em;
        font-weight: 700;
        background: transparent;
    }

    .kg-audio-player {
        display: none;
    }

    .kg-width-full.kg-card-hascaption {
        display: grid;
        grid-template-columns: inherit;
    }

    .post-content table {
        border-collapse: collapse;
        width: 100%;
    }

    .post-content th {
        padding: 0.5em 0.8em;
        text-align: left;
        font-size: .75em;
        text-transform: uppercase;
    }

    .post-content td {
        padding: 0.4em 0.7em;
    }

    .post-content tbody tr:nth-child(2n + 1) {
        background-color: rgba(0,0,0,0.1);
        padding: 1px;
    }

    .post-content tbody tr:nth-child(2n + 2) td:last-child {
        box-shadow:
            inset 1px 0 rgba(0,0,0,0.1),
            inset -1px 0 rgba(0,0,0,0.1);
    }

    .post-content tbody tr:nth-child(2n + 2) td {
        box-shadow: inset 1px 0 rgba(0,0,0,0.1);
    }

    .post-content tbody tr:last-child {
        border-bottom: 1px solid rgba(0,0,0,.1);
    }

    .page-footer {
        padding: 60px 5vmin;
        margin: 60px auto 0;
        text-align: center;
        background-color: #f8f8f8;
    }

    .page-footer h3 {
        margin: 0.5rem 0 0 0;
    }

    .page-footer p {
        max-width: 500px;
        margin: 1rem auto 1.5rem;
        font-size: 1.7rem;
        line-height: 1.5em;
        color: rgba(0,0,0,0.6)
    }

    .powered {
        display: inline-flex;
        align-items: center;
        margin: 30px 0 0;
        padding: 6px 9px 6px 6px;
        border: rgba(0,0,0,0.1) 1px solid;
        font-size: 12px;
        line-height: 12px;
        letter-spacing: -0.2px;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", "Oxygen", "Ubuntu", "Cantarell", "Fira Sans", "Droid Sans", "Helvetica Neue", sans-serif;
        font-weight: 500;
        color: #222;
        text-decoration: none;
        background: #fff;
        border-radius: 6px;
    }

    .powered svg {
        height: 16px;
        width: 16px;
        margin: 0 6px 0 0;
    }

    @media (max-width: 600px) {
        body {
            font-size: 1.6rem;
        }
        h1 {
            font-size: 3rem;
        }

        h2 {
            font-size: 2.2rem;
        }
    }

    @media (max-width: 400px) {
        h1 {
            font-size: 2.6rem;
            line-height: 1.15em;
        }
        h2 {
            font-size: 2rem;
            line-height: 1.2em;
        }
        h3 {
            font-size: 1.7rem;
        }
    }

    :root {--ghost-accent-color: #15171A;}
    </style>

    <style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style><noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript>
    <script async src="https://cdn.ampproject.org/v0.js"></script>

    

</head>

<body class="amp-template">
    <header class="page-header">
        <a href="../../index.html">
                <amp-img class="site-icon" src="yourdomain.com/content/images/2021/07/ghost-orb.png" width="50" height="50" layout="fixed" alt="zairesinatra"></amp-img>
        </a>
    </header>

    <main class="content" role="main">
        <article class="post">

            <header class="post-header">
                <h1 class="post-title">Spring5</h1>
                <section class="post-meta">
                    Ziyi Xie -
                    <time class="post-date" datetime="2020-05-25">25 May 2020</time>
                </section>
            </header>
            <figure class="post-image">
                <amp-img src="yourdomain.com/content/images/2022/05/GreyWhiteClouds.JPG" width="600" height="340" layout="responsive" 
                alt="GreyWhiteClouds"
                ></amp-img>
            </figure>
            <section class="post-content">

                <h2 id="%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B">快速上手</h2>
<h3 id="core-concepts">Core Concepts</h3>
<p><amp-img src="https://res.cloudinary.com/dzb9ldnvl/image/upload/v1671815139/BackendDev/Spring/SpringFrameworkRuntime.png" alt width="720" height="540" layout="responsive"></amp-img></p>
<p>(IOC) Inversion of Control 控制反转的思想是将对象的创建权移交外部，避免出现业务层 service 与数据层 dao 有强耦合的情况。</p>
<pre><code class="language-java">// 强耦合
public class XxxServiceImpl implements XxxService {
    private XxxDao xxxDao = new XxxDaoImpl();
    public void yyy(){
        xxxDao.yyy();
    }
}
// 解耦
public class XxxServiceImpl implements XxxService {
    private XxxDao xxxDao; // 对象创建控制权移交外部
    public void yyy(){
        xxxDao.yyy();
    }
}
</code></pre>
<pre><code class="language-java">public class XxxDaoImpl implements XxxDao {
    public void yyy() {
        System.out.println("xxx dao yyy");
    }
}
</code></pre>
<p>Spring 技术对 IoC 思想的实现：</p>
<ol>
<li>Spring 提供一个用于充当“外部”的 IoC 容器</li>
<li>从主动 new 出对象转换至由“外部”提供对象</li>
<li>被 IoC 容器接管创建与初始化过程的对象叫做 Bean</li>
</ol>
<blockquote>
<p>Beans're special type of Pojos. There're some restrictions on POJO to be a bean.</p>
</blockquote>
<ul>
<li>POJO:
<ul>
<li>不继承任何类</li>
<li>不实现任何接口</li>
<li>不包含注解</li>
</ul>
</li>
<li>Beans:
<ul>
<li>不可以通过名称访问字段，仅能使用 getters 和 setters</li>
<li>一定实现 serializable 接口，是可序列化的类</li>
<li>所有字段都是私有访问类型 private</li>
<li>一定存在无参构造函数</li>
</ul>
</li>
</ul>
<p>在 IoC 容器中建立不同 Bean 之间依赖关系的过程称为 (DI) Dependency Injection 依赖注入。</p>
<p>由于 service 与 dao 都同在 IoC，那么依赖注入理所当然的可以解决 service 运行时需要依赖 dao 的问题。</p>
<p><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans">Spring</a> 中 IoC 容器的两种获取方式：BeanFactory 和 ApplicationContext 接口。</p>
<blockquote>
<p>The org.springframework.beans and org.springframework.context packages are the basis for Spring Framework’s IoC container. The BeanFactory interface provides an advanced configuration mechanism capable of managing any type of object. ApplicationContext is a sub-interface of BeanFactory.</p>
</blockquote>
<blockquote>
<p>The org.springframework.context.ApplicationContext interface represents the Spring IoC container and is responsible for instantiating, configuring, and assembling the beans.</p>
</blockquote>
<blockquote>
<p>Several implementations of the ApplicationContext interface are supplied with Spring. In stand-alone applications, it is common to create an instance of ClassPathXmlApplicationContext or FileSystemXmlApplicationContext.</p>
</blockquote>
<h3 id="ioc-container-beans">IoC Container &amp; Beans</h3>
<p>在导入 Spring 坐标并定义 Spring 管理的类后，在 resources 目录创建 Spring 配置文件，配置对应类作为 Spring 管理的 bean。</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
    &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">// 组件类
public class HelloComponent { public void HelloMethod() { System.out.println("hello component..."); } }
</code></pre>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd"&gt;
    &lt;bean id="helloComponent" class="com.xxx.HelloComponent"&gt;&lt;/bean&gt;
    &lt;bean id="..." class="..."&gt;
        &lt;!-- collaborators and configuration for this bean go here --&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>id attribute 指定 bean 的唯一标识，用于精确获取到组件对象。</p>
<p>class attribute 通过全类名的形式定义 bean 的类型。</p>
<pre><code class="language-java">// 测试类
public class IOCTest {
    // 创建 IOC 容器对象
    private ApplicationContext iocContainer = new ClassPathXmlApplicationContext("helloComponent.xml");
    @Test
    public void testExperiment01() {
        // 根据 id 从 IoC 容器对象里获取 bean =&gt; 组件对象
        HelloComponent helloComponent = (helloComponent) iocContainer.getBean("helloComponent");
        helloComponent.HelloMethod();
    }
}
</code></pre>
<h3 id="bean-%E4%BD%9C%E7%94%A8%E5%9F%9F">Bean 作用域</h3>
<p>SF 共支持六个作用域，其中四个仅在 web-aware ApplicationContext 时可使用。</p>
<p>Bean 作用域就是配置创建 Bean 实例是 prototype 还是 singleton。默认单例。</p>
<p>&lt;bean /&gt; 的 scope 属性设置为 singleton 或 prototype 分别表示单实例或多实例。</p>
<p>单实例对象在加载配置文件的过程中创建，多实例对象创建在调用 getBean 后。</p>
<p>从默认创建单例 bean 可以看出 Spring 更多的是管理可复用的对象，如：servlet、service、dao layer objects 和工具对象。封装实体的域对象不适合（有状态）。</p>
<pre><code class="language-xml">&lt;!--&lt;bean id="myBean" class="com.&lt;secret&gt;.spring5.factorybean.MyBean"&gt;&lt;/bean&gt;--&gt;
&lt;bean id="myBean" class="com.&lt;secret&gt;.spring5.factorybean.MyBean" scope="singleton"&gt;&lt;/bean&gt;
</code></pre>
<pre><code class="language-java">@Test
public void testFBean(){
    ApplicationContext context = new ClassPathXmlApplicationContext("bean7.xml");
    MyBean myBean = context.getBean("myBean", MyBean.class);
    MyBean myBean1 = context.getBean("myBean", MyBean.class);
    System.out.println(myBean); // com.&lt;secret&gt;.spring5.factorybean.MyBean@42d8062c
    System.out.println(myBean1); // com.&lt;secret&gt;.spring5.factorybean.MyBean@42d8062c 
}
</code></pre>
<h3 id="instantiating-beans">Instantiating Beans</h3>
<p><strong>实例化 Bean：</strong></p>
<ul>
<li>通常 Spring 是在容器本身通过反射调用无参构造函数直接创建 bean</li>
<li>容器调用 static factory method 静态工厂方法来创建 bean</li>
<li>容器调用实例工厂创建 bean（非静态 =&gt; 需要先 new 出工厂对象）</li>
</ul>
<p>(Instantiation with a Constructor) 构造函数方法创建 bean：</p>
<ul>
<li>应提供一个无参构造函数（不写也可以）</li>
<li>如果无参构造方法不提供，实例化 Bean 会抛出 beanCreationException</li>
</ul>
<pre><code class="language-java">public class XxxDaoImpl implements XxxDao {
    public void yyy() { ... }
}
</code></pre>
<pre><code class="language-xml">&lt;bean id="xxxDao" class="com.???.dao.impl.XxxDaoImpl" /&gt;
</code></pre>
<p>(Instantiation with a Static Factory Method) 静态工厂方法创建 bean：</p>
<ul>
<li>class attribute 指定包含静态工厂方法的全类名</li>
<li>factory-method attribute 指定工厂方法的名称</li>
</ul>
<pre><code class="language-java">public class XxxDaoFactory{ // 静态工厂
    public static XxxDao getXxxDao(){
        return new XxxDaoImpl(); 
    }
}
</code></pre>
<pre><code class="language-xml">&lt;bean id="xxxDao" class="com.???.factory.XxxDaoFactory" factory-method="getXxxDao"/&gt;
</code></pre>
<p>(Instantiation by Using an Instance Factory Method) 实例工厂方法创建 bean：</p>
<ul>
<li>该方式可看作从容器中调用现有 bean 的非静态方法来创建新 bean</li>
<li>class attribute 留空</li>
<li>factory-bean attribute 指向工厂 bean</li>
<li>factory-method attribute 指向工厂方法名</li>
</ul>
<pre><code class="language-java">public class XxxDaoFactory{ // 实例工厂
    public XxxDao getXxxDao(){
        return new XxxDaoImpl(); 
    }
}
</code></pre>
<pre><code class="language-xml">&lt;!-- 额外配置工厂 bean --&gt;
&lt;bean id="xxxDaoFactory" class="com.???.factory.XxxDaoFactory" /&gt;
&lt;bean id="xxxDao" factory-method="getXxxDao" factory-bean="xxxDaoFactory"/&gt;
</code></pre>
<p>通过实例工厂方法创建 bean 的缺陷：</p>
<ul>
<li>额外的工厂 bean 标签除了配合实例化 bean 之外没有实际的意义</li>
<li>因方法名的不确定，每次实例化 bean 都需要对 factory-method 进行配置</li>
</ul>
<p>解决上述缺陷：FactoryBean 可以向容器中注册两个 bean：经 getObject 方法的返回值所代表的 bean 和其自身。</p>
<p>❤️‍🔥 使用 FactoryBean 实例化 bean：</p>
<ul>
<li>实现 FactoryBean 接口并重写接口中的 getObject 和 getObjectType 方法</li>
<li>getObject 返回工厂生产的对象（这是 Spring 容器将使用的对象）</li>
<li>getObjectType 返回此 FactoryBean 生成的对象类型</li>
<li>class attribute 设置为现 FactoryBean 的全类名</li>
</ul>
<blockquote>
<p>factory bean 是指配置在容器中并通过实例或静态工厂方法而创建的 bean。<br />
FactoryBean 是指特定于 Spring 中 FactoryBean 的实现类。<br />
FactoryBean 创建完成后，所有的 bean 均为延迟加载</p>
</blockquote>
<pre><code class="language-java">public class XxxDaoFactoryBean implements FactoryBean&lt;XxxDao&gt;{
    // 代替原始实例工厂中创建对象的方法
    @Override
    public XxxDao getObject() throws Exception {
        return new XxxDaoImpl();
    }
    @Override
    public Class&lt;?&gt; getObjectType() {
        return XxxDao.class;
    }
}
</code></pre>
<pre><code class="language-xml">&lt;bean id="xxxDao" class="com.???.factory.XxxDaoFactoryBean"/&gt;
</code></pre>
<pre><code class="language-java">public class TestFactoryBean {
    @Test
    public void testFBean(){
        ApplicationContext ctx = new ClassPathXmlApplicationContext("fbBeam.xml");
        XxxDao xxxDao = (XxxDao) ctx.getBean("xxxDao");
        xxxDao.yyy();
    }
}
</code></pre>
<h3 id="lifecycle-callbacks">Lifecycle Callbacks</h3>
<p>初始化回调：</p>
<ol>
<li>使用 @PostConstruct 注解</li>
<li>对配置元数据使用 init-method 来指定 void no-argument 的方法名</li>
<li>实现接口 InitializingBean 的 afterPropertiesSet 方法</li>
</ol>
<p>销毁回调：</p>
<ol>
<li>使用 @PreDestroy 注解</li>
<li>对配置元数据使用 destroy-method 来指定 void no-argument 的方法名</li>
<li>实现接口 DisposableBean 的 destroy 方法</li>
</ol>
<pre><code class="language-java">public class XxxDaoImpl implements XxxDao {
    public void yyy(){ ... }
    public void initFunc(){ ... }
    public void destroyFunc(){ ... }
}
</code></pre>
<pre><code class="language-xml">&lt;bean id="orders" class="com.???.dao.impl.XxxDaoImpl" init-method="initFunc" destroy-method="destroyFunc"/&gt;
</code></pre>
<pre><code class="language-java">public class TestLifeCycle {
    @Test
    public void testLifeCycle(){
        ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext("lifeCyclebean.xml");
        XxxDao xxxDao = (XxxDao) ctx.getBean("xxxDao");
        xxxDao.yyy();
        ctx.registerShutdownHook();  // 关闭容器 =&gt; 效果同 close
//      ctx.close();
    }
}
</code></pre>
<p>生命周期：</p>
<ol>
<li>初始化容器：新建实例、执行构造、属性注入（set 操作）、bean 初始化</li>
<li>使用 bean：执行业务</li>
<li>关闭/销毁容器：执行 bean 销毁方法</li>
</ol>
<p>Spring IOC 容器提供的扩展接口 BeanPostProcessor 定义了两个回调方法：</p>
<ul>
<li>postProcessBeforeInitialization 在 bean 实例初始化前调用</li>
<li>postProcessAfterInitialization 在 bean 实例初始化后调用</li>
</ul>
<p>后置处理器会对当前配置文件中的所有 bean 都生效。</p>
<pre><code class="language-xml">&lt;bean id="myBeanPost" class="com.&lt;secret&gt;.spring5.lifeCycle.MyBeanPost"/&gt;
</code></pre>
<pre><code class="language-java">public class MyBeanPost implements BeanPostProcessor {
    @Nullable
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        System.out.println("在初始化之前执行的方法");
        return bean;
    }
    @Nullable
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        System.out.println("在初始化之后执行的方法");
        return bean;
    }
}
</code></pre>
<h2 id="%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5-di">依赖注入 DI</h2>
<p>向类中传递数据的方法有两种：普通方法（set 方法）和构造方法。</p>
<p>创建 bean 不仅会依赖引用数据类型，也会依赖基本数据类型。</p>
<p>以上，依赖注入会分别存在通过 setter 或构造器注入简单或引用类型的四种方式。</p>
<h3 id="setter-%E6%B3%A8%E5%85%A5">setter 注入</h3>
<p>Setter-based DI，即 setter 注入是通过容器在调用无参构造函数或无参静态工厂方法实例化 bean 后调用其 setter 方法来实现的。</p>
<p><strong>setter 注入引用类型：</strong></p>
<ul>
<li>bean 中定义引用类型属性并提供可访问的 set 方法</li>
<li>配置中使用 property 标签的 ref 属性注入引用类型对象</li>
</ul>
<pre><code class="language-java">public class XxxServiceImpl implements XxxService {
    private XxxDao xxxDao;
    public void setXxxDao(XxxDao xxxDao) {
      this.xxxDao = xxxDao;
    }
}
</code></pre>
<pre><code class="language-xml">&lt;bean id="xxxDao" class="com.xxx.dao.impl.XxxDaoImpl"&gt;
&lt;bean id="xxxService" class="com.xxx.service.impl.XxxServiceImpl"&gt;
    &lt;property name="xxxDao" ref="xxxDao" /&gt;
&lt;/bean&gt;
</code></pre>
<p><strong>setter 注入简单类型：</strong></p>
<ul>
<li>bean 中定义简单类型属性并提供可访问的 set 方法</li>
<li>配置中使用 property 标签的 value 属性注入简单类型对象</li>
</ul>
<pre><code class="language-java">public class XxxServiceImpl implements XxxService {
    private int connectionNumber;
    public void setConnectionNumber(int connectionNumber) {
      this.connectionNumber = connectionNumber;
    }
}
</code></pre>
<pre><code class="language-xml">&lt;bean id="xxxService" class="com.xxx.service.impl.XxxServiceImpl"&gt;
    &lt;property name="connectionNumber" value="6" /&gt;
&lt;/bean&gt;
</code></pre>
<h3 id="%E6%9E%84%E9%80%A0%E5%99%A8%E6%B3%A8%E5%85%A5">构造器注入</h3>
<p>在创建对象时默认执行无参数的构造，若在类中定义有参构造器却不定义无参构造器则会报错。</p>
<p><strong>构造器注入引用类型：</strong></p>
<ul>
<li>bean 中定义引用类型属性并提供可访问的构造方法</li>
<li>配置中使用 constructor-arg 标签的 ref 属性注入引用类型对象</li>
</ul>
<pre><code class="language-java">public class XxxServiceImpl implements XxxService {
    private XxxDao xxxDao;
    public void setXxxDao(XxxDao xxxDao) {
      this.xxxDao = xxxDao;
    }
}
</code></pre>
<pre><code class="language-xml">&lt;bean id="xxxDao" class="com.xxx.dao.impl.XxxDaoImpl"&gt;
&lt;bean id="xxxService" class="com.xxx.service.impl.XxxServiceImpl"&gt;
    &lt;constructor-arg name="xxxDao" ref="xxxDao" /&gt;
&lt;/bean&gt;
</code></pre>
<p><strong>构造器注入简单类型：</strong></p>
<ul>
<li>bean 中定义简单类型属性并提供可访问的构造方法</li>
<li>配置中使用 constructor-arg 标签的 value 属性注入简单类型对象</li>
</ul>
<pre><code class="language-java">public class XxxServiceImpl implements XxxService {
    private int connectionNumber;
    public void setConnectionNumber(int connectionNumber) {
      this.connectionNumber = connectionNumber;
    }
}
</code></pre>
<pre><code class="language-xml">&lt;bean id="xxxService" class="com.xxx.service.impl.XxxServiceImpl"&gt;
    &lt;constructor-arg name="xxxDao" value="6" /&gt;
&lt;/bean&gt;
</code></pre>
<p><strong>构造器注入的参数适配：</strong></p>
<ul>
<li>配置中使用 constructor-arg 标签的 type 属性设置按形参类型注入</li>
<li>配置中使用 constructor-arg 标签的 index 属性设置按形参位置注入</li>
</ul>
<h3 id="%E4%BE%9D%E8%B5%96%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D">依赖自动装配</h3>
<p>自动装配即 IoC 容器据 bean 依赖的资源在容器里自动查找并注入 bean 的过程。</p>
<ul>
<li>配置中使用 bean 标签的 autowire 属性</li>
<li>自动装配用于引用类型依赖注入，不能对简单类型进行操作</li>
<li>使用 byType 按类型装配时必须保证容器中相同类型的 bean 唯一</li>
<li>使用 byName 按名称装配时必须保证容器中具有指定名称的 bean</li>
<li>自动装配优先级低于 setter 注入和狗在器注入，同时出现时自动装配失效</li>
</ul>
<pre><code class="language-java">// 自动装配类
public class Emp {
    private Dept dept;
    @Override
    public String toString() { return "Emp{" + "dept=" + dept + '}'; }
    public void setDept(Dept dept) { this.dept = dept; }
    public void test(){ System.out.println(dept); }
}
</code></pre>
<pre><code class="language-java">// 待装配类
public class Dept {
    @Override
    public String toString() { return "Dept{}"; }
}
</code></pre>
<pre><code class="language-xml">&lt;!-- 实现自动装配 =&gt; autowire属性 =&gt; 用的较少 --&gt;
    &lt;!-- byName 根据名称注入 =&gt; 注入值 bean 的 id 值和类属性名称一样 --&gt;
    &lt;!-- byType 根据类型注入 =&gt; 多个 bean 不能进行选择 --&gt;
&lt;bean id="emp" class="com.&lt;secret&gt;.spring5.autowire.Emp" autowire="byName"/&gt;
&lt;bean id="dept" class="com.&lt;secret&gt;.spring5.autowire.Dept"&gt;&lt;/bean&gt;
</code></pre>
<pre><code class="language-java">public class TestAutoWire {
    // 测试自动注入
    @Test
    public void testAutoWire(){
        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("bean9.xml");
        Emp emp = context.getBean("emp", Emp.class);
        System.out.println(emp);
        emp.test();
    }
}
</code></pre>
<p>Spring 会将属性的 empty arguments 视作为空字符串。</p>
<pre><code class="language-xml">&lt;bean class="..."&gt;&lt;property name="email" value=""/&gt;&lt;/bean&gt;
&lt;bean class="..."&gt;&lt;property name="email"&gt;&lt;null/&gt;&lt;/property&gt;&lt;/bean&gt;
</code></pre>
<p>特殊符号的处理：</p>
<ul>
<li>使用转义字符进行代替</li>
<li>property 标签中的 value 属性应抽离成独立标签</li>
<li>value 标签通过 <code>&lt;![CDATA[?]]&gt;</code> 标签内容包裹特殊符号</li>
</ul>
<blockquote>
<p>CData section − Characters between these two enclosures are interpreted as characters, and not as markup. This section may contain markup characters (&lt;, &gt;, and &amp;), but they are ignored by the XML processor.</p>
</blockquote>
<pre><code class="language-xml">&lt;bean id="user" class="com.???.spring5.User"&gt;
    &lt;property name="name"&gt;
        &lt;value&gt;
            &lt;!-- CDATA[] 内中填写要输出的值 --&gt;
            &lt;![CDATA[&lt;&lt;okk&gt;&gt;]]&gt;
        &lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<blockquote>
<p>The p-namespace lets you use the bean element’s attributes (instead of nested <code>&lt;property/&gt;</code> elements) to describe your property values collaborating beans, or both.</p>
</blockquote>
<p>简化 XML 配置文件的 p-namespace：</p>
<ul>
<li>引入 ns：<code>xmlns:p="http://www.springframework.org/schema/p"</code></li>
<li>在对应的 bean 中使用 <code>p:属性</code> 替代 <code>&lt;property&gt;</code> 标签</li>
<li>注意此方式不需要修改 xsi:schemaLocation</li>
</ul>
<pre><code class="language-xml">&lt;bean name="my_classicBean" class="com.example.ExampleBean"&gt;
    &lt;property name="email" value="ok@gmail.com"/&gt;
&lt;/bean&gt;
&lt;!-- 上下两种方式等价 --&gt;
&lt;bean name="my_p-namespaceBean" class="com.example.ExampleBean" p:email="ok@gmail.com"/&gt;
</code></pre>
<blockquote>
<p>The c-namespace, introduced in Spring 3.1, allows inlined attributes for configuring the constructor arguments rather then nested constructor-arg elements.</p>
</blockquote>
<p>简化 XML 配置文件的 c-namespace：</p>
<ul>
<li>引入 ns：<code>xmlns:c="http://www.springframework.org/schema/c"</code></li>
<li>在对应的 bean 中使用 <code>c:属性</code> 替代 <code>&lt;constructor-arg&gt;</code> 标签</li>
<li>注意此方式不需要修改 xsi:schemaLocation</li>
</ul>
<pre><code class="language-xml">&lt;!-- traditional declaration --&gt;
&lt;bean id="foo" class="x.y.Foo"&gt;
    &lt;constructor-arg ref="bar"/&gt;
    &lt;constructor-arg ref="baz"/&gt;
    &lt;constructor-arg value="foo@bar.com"/&gt;
&lt;/bean&gt;
&lt;!-- c-namespace declaration --&gt;
&lt;bean id="foo" class="x.y.Foo" c:bar-ref="bar" c:baz-ref="baz" c:email="foo@bar.com"/&gt;
</code></pre>
<h3 id="%E9%9B%86%E5%90%88%E6%B3%A8%E5%85%A5">集合注入</h3>
<p>注入集合类型的属性，即注入数组、List、Map 以及 Set。</p>
<pre><code class="language-java">public class XxxDaoImpl implements XxxDao {
    private int[] array;
    private List&lt;String&gt; list;
    private Map&lt;String, String&gt; map;
    private Set&lt;String&gt; set;
    private Properties properties;
    public void setArray(int[] array) { this.array = array; }
    public void setList(List&lt;String&gt; list) { this.list = list; }
    public void setMap(Map&lt;String, String&gt; maps) { this.maps = maps; }
    public void setSet(Set&lt;String&gt; sets) { this.sets = sets; }
    public void setProperties(Properties properties) { this.properties = properties; }
    public void test(){
        System.out.println(Arrays.toString(array));
        System.out.println(list);
        System.out.println(map);
        System.out.println(set);
        System.out.println(properties);
    }
}
</code></pre>
<pre><code class="language-xml">&lt;bean id="xxxDao" class="com.???.dao.impl.XxxDaoImpl"&gt;
    &lt;property name="array"&gt;
        &lt;array&gt;
            &lt;value&gt;1&lt;/value&gt;
            &lt;value&gt;2&lt;/value&gt;
            &lt;value&gt;3&lt;/value&gt;
        &lt;/array&gt;
    &lt;/property&gt;
    &lt;property name="list"&gt;
        &lt;list&gt;
            &lt;value&gt;yes&lt;/value&gt;
            &lt;value&gt;ok&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
    &lt;property name="map"&gt;
        &lt;map&gt;
            &lt;entry key="JAVA" value="java"/&gt;
            &lt;entry key="JAVASCRIPT" value="javascript"/&gt;
        &lt;/map&gt;
    &lt;/property&gt;
    &lt;property name="set"&gt;
        &lt;set&gt;
            &lt;value&gt;MySQL&lt;/value&gt;
            &lt;value&gt;Redis&lt;/value&gt;
        &lt;/set&gt;
    &lt;/property&gt;
    &lt;property name="properties"&gt;
        &lt;props&gt;
            &lt;prop key="msg"&gt;msgcontext&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<pre><code class="language-java">public class TestL {
    @Test
    public void testCollection1(){
        ApplicationContext ctx = new ClassPathXmlApplicationContext("beanDI.xml");
        XxxDao xxxDao = (XxxDao) ctx.getBean("xxxDao");
        xxxDao.test();
    }
}
</code></pre>
<p>在注入 bean 集合类型属性时，对于存在可复用的集合，应抽取单独封装。</p>
<pre><code class="language-java">/* 集合注入提取 */
public class BookExtract {
    private List&lt;String&gt; list;
    public void setList(List&lt;String&gt; list) { this.list = list; }
    public void test(){ System.out.println(list); }
}
</code></pre>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans ...
       xmlns:util="http://www.springframework.org/schema/util"
       xsi:schemaLocation="...
                           http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd"&gt;
    &lt;!-- 集合注入部分提取 --&gt;
    &lt;util:list id="bookList"&gt;
        &lt;value&gt;js&lt;/value&gt;
        &lt;value&gt;java&lt;/value&gt;
        &lt;value&gt;nodejs&lt;/value&gt;
    &lt;/util:list&gt;
    &lt;bean id="bookExtract" class="com.&lt;secret&gt;.spring5.bean.BookExtract"&gt;
        &lt;property name="list" ref="bookList"&gt;&lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="language-java">public class TestL {
    // 集合注入部分抽取测试
    @Test
    public void testCollection2(){
        ApplicationContext context = new ClassPathXmlApplicationContext("bean6.xml");
        BookExtract be = context.getBean("bookExtract", BookExtract.class);
        be.test();
    }
}
</code></pre>
<h3 id="%E5%BC%95%E7%94%A8%E5%A4%96%E9%83%A8%E6%96%87%E4%BB%B6">引用外部文件</h3>
<p>数据源对象管理：导入坐标后配置数据源对象作为 Spring 管理的 bean。</p>
<pre><code class="language-xml">&lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource"&gt;
    &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"/&gt;
    &lt;property name="url" value="jdbc:mysql://localhost:3306/spring_db"/&gt;
    &lt;property name="username" value="root"/&gt;
    &lt;property name="password" value="yesok"/&gt;
&lt;/bean&gt;
</code></pre>
<pre><code class="language-xml">&lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt;
    &lt;property name="driverClass" value="com.mysql.jdbc.Driver"/&gt;
    &lt;property name="jdbcUrl" value="jdbc:mysql://localhost:3306/spring_db"/&gt;
    &lt;property name="user" value="root"/&gt;
    &lt;property name="password" value="yesok"/&gt;
&lt;/bean&gt;
</code></pre>
<p>加载 properties 文件：</p>
<ul>
<li>开启 context 命名空间</li>
<li>使用 context 空间加载 properties 文件</li>
<li>使用占位符 <code>${}</code> 读取 properties 文件中的属性</li>
</ul>
<pre><code class="language-xml">&lt;beans ...
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="...
       http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt;
    &lt;context:property-placeholder location="classpath*:*.properties"/&gt;
    &lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource"&gt;
        &lt;property name="driverClassName" value="${jdbc.driverClass}"/&gt;
        &lt;property name="url" value="${jdbc.url}"/&gt;
        &lt;property name="username" value="${jdbc.userName}"/&gt;
        &lt;property name="password" value="${jdbc.password}"/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="language-yaml">jdbc.driverClass=com.mysql.cj.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:3306/???
jdbc.userName=root
jdbc.password=yesok
</code></pre>
<h2 id="%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91">注解开发</h2>
<p>和配置文件一样，注解本身并不执行，仅做为标记。具体的功能是框架检测到注解标记的位置，然后针对这个位置按照注解标记的功能来执行操作。</p>
<h3 id="%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91%E5%AE%9A%E4%B9%89-bean">注解开发定义 bean</h3>
<p>创建 bean 实例（下列注解无本质区别）：</p>
<ul>
<li><code>@Component</code> 标记普通组件</li>
<li><code>@Controller</code> 标记表述层组件</li>
<li><code>@Service</code> 标记业务层组件</li>
<li><code>@Repository</code> 标记数据层组件（DAO 和 Mapper 接口）</li>
</ul>
<p>组件扫描配置：</p>
<ul>
<li>通过 <code>@Component</code> 注解将组件类视作 bean</li>
<li>通过 <code>context:component-scan</code> 标签的 <code>base-package</code> 属性进行扫描</li>
</ul>
<p>存在多个包需要扫描的情况下，可以使用逗号分隔或者直接扫描上层目录。</p>
<pre><code class="language-java">@Component(value = "userAnnot")
public class UserAnnot {
    public void add(){ System.out.println("Annot add..."); }
}
</code></pre>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt;
    &lt;context:component-scan base-package="com.&lt;secret&gt;.spring5.wkAnnot"/&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="language-java">/* 注解测试类 */
public class TestAnno {
    @Test
    public void testAnno1(){
        ApplicationContext ctx = new ClassPathXmlApplicationContext("bbean1.xml");
        UserAnnot ua = ctx.getBean("userAnnot", UserAnnot.class);
        System.out.println(ua);
        ua.add();
    }
}
</code></pre>
<p>作用范围用 @Scope 定义，生命周期用 @PostConstruct 和 @PreDestroy 定义。</p>
<h3 id="%E7%BA%AF%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91">纯注解开发</h3>
<p>Spring3 开启的纯注解开发可以通过配置类替代配置文件。</p>
<ul>
<li>@Configuration 注解标记当前类作为配置类，代替配置文件结构</li>
<li>@ComponentScan 替代 context:component-scan 标签</li>
<li>@PropertySource 可加载 properties 文件</li>
</ul>
<pre><code class="language-java">public class TestPureAnnot {
    @Test
    public void TestPureAnnot(){
        ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class);
        UserService userservice = ctx.getBean("userService", UserService.class);
        userservice.usMethod();
    }
}
</code></pre>
<pre><code class="language-java">@Configuration
@ComponentScan(basePackages = {"com.&lt;secret&gt;.spring5.annoDev"})
@PropertySource("classpath:jdbc.properties")
public class SpringConfig {}
</code></pre>
<h3 id="%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5">依赖注入</h3>
<p>自动装配：</p>
<ul>
<li><code>@Autowired</code> 根据 bean 类型进行装配</li>
<li><code>@Qualifier</code> 根据 bean 名称进行装配</li>
<li><code>@Resource</code> 既可根据类型装配，也可根据名称装配</li>
<li><code>@Value</code> 进行简单类型注入</li>
</ul>
<p><code>@Qualifier</code> 必须依赖 <code>@Autowired</code>，用于解决相同类型 bean 注入的冲突。</p>
<p>自动装配基于反射设计创建对象并暴力反射对应属性为私有属性初始化数据，因此无需提供 setter 方法。</p>
<p>自动装配建议使用无参构造方法创建对象（默认），若不提供对应构造方法，则提供唯一构造方法。</p>
<pre><code class="language-java">@Service
public class UserService {
//    @Autowired // 根据类型进行注入
//    @Qualifier(value="userDaoImpl1")
//    private UserService userDao;
//    @Resource // 根据类型进行注入
    @Resource(name = "userDaoImpl1") // 根据名称进行注入
    private UserDao userDao;
    @Value(value="hz") // 注入普通类型属性
    private String name;
    public void usMethod(){
        System.out.println("service usMethod");
        userDao.udiMethod();
        System.out.println(name);
    }
}
</code></pre>
<pre><code class="language-java">@Repository(value="userDaoImpl1")
public class UserDaoImpl implements UserDao{
    @Override
    public void udiMethod() { System.out.println("impl ado udiMethod"); }
}
</code></pre>
<h3 id="%E7%AE%A1%E7%90%86%E7%AC%AC%E4%B8%89%E6%96%B9-bean">管理第三方 bean</h3>
<p>第三方 bean 管理：</p>
<ul>
<li>使用独立的配置类管理第三方 bean</li>
<li>@Bean 标记返回值是 bean 的方法</li>
<li>手动加入配置类到核心配置
<ul>
<li>导入式 @Import 注解</li>
<li>扫描式 @ComponentScan 注解（需额外 @Configuration 注解）</li>
</ul>
</li>
</ul>
<pre><code class="language-java">// @Configuration
public class JdbcConfig {
    @Bean
    public DataSource dataSource(){
        DruidDataSource ds = new DruidDataSource();
        ds.setDriverClassName("com.mysql.jdbc.Driver");
        ds.setUrl("jdbc:mysql://localhost:3306/???");
        ds.setUsername("root");
        ds.setPassword("yesok");
        return ds;
    }
}
</code></pre>
<pre><code class="language-java">@Configuration
@Import({JdbcConfig.class}) // @ComponentScan({"com.xxx.config"})
public class SpringConfig {}
</code></pre>
<p>第三方 bean 的依赖注入：</p>
<ul>
<li>简单类型通过 @Value 注解进行注入</li>
<li>引用类型注入需为返回 bean 的方法设置相应的形参</li>
</ul>
<pre><code class="language-java">public class JdbcConfig {
    @Value("com.mysql.jdbc.Driver");
    private String driver;
    @Value("jdbc:mysql://localhost:3306/???");
    private String url;
    @Value("root");
    private String userName;
    @Value("password")
    private String password;
    @Bean
    public DataSource dataSource(XxxService xxxService){
        System.out.println(xxxService);
        DruidDataSource ds = new DruidDataSource();
        ds.setDriverClassName(driver);
        ds.setUrl(url);
        ds.setUsername(userName);
        ds.setPassword(password);
        return ds;
    }
}
</code></pre>
<pre><code class="language-java">@Configuration
@ComponentScan({"com..???..config","com.???.service"})
@Import({JdbcConfig.class})
public class SpringConfig {}
</code></pre>
<h2 id="aspect-oriented-programming">Aspect Oriented Programming</h2>
<blockquote>
<p>AOP <strong>面向切面编程</strong>：在不惊动原始设计的基础上进行功能的增强。</p>
</blockquote>
<blockquote>
<p>In Spring AOP, aspects are implemented by using regular classes (the schema-based approach) or regular classes annotated with the @Aspect annotation (the @AspectJ style).</p>
</blockquote>
<h3 id="aop-basis">AOP Basis</h3>
<p>AOP 术语并不是特定于 Spring。因其抽象性，Spring 不会增加额外的概念。</p>
<ul>
<li>连接点 JoinPoint：已存在的功能，对应各类的方法，执行位置不限</li>
<li>切入点 Pointcut：需要追加功能的方法，可通过表达式匹配对应的连接点</li>
<li>通知 Advice：已抽取出的共性功能与增强逻辑，依托通知类（定义通知）</li>
<li>切面 Aspect：描述通知的共性功能与对应切入点的关系</li>
</ul>
<p>使用 pointcut designator 确定对具体类里的具体方法进行增强：</p>
<pre><code class="language-java">// The format of an execution expression follows:
execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern) throws-pattern?)
</code></pre>
<p>AOP 操作的实现 AspectJ 并非是 Spring 的组成部分，而是独立的 AOP 框架：</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
    &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
    &lt;version&gt;1.9.19&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>注解操作 AspectJ 进行 AOP 开发：</p>
<ul>
<li>导入 AspectJ 相关坐标；spring-context 坐标默认依赖 spring-aop 坐标</li>
<li>定义 AOP 接口与实现类</li>
<li>定义通知类抽取通知，并通过 @Pointcut 定义切入点</li>
<li>绑定切入点与通知关系，并指定通知添加到原始连接点的具体执行位置</li>
<li>定义通知类接受 Spring 容器管理，且定义当前类为切面类</li>
<li>在 Spring 核心配置中开启 Spring 对 AOP 注解的驱动支持</li>
</ul>
<pre><code class="language-java">// 被增强类
@Component
public class User {
    public void uMethod(){ System.out.println("user method"); }
}
</code></pre>
<p>切入点的定义依托一个不具有实际意义的方法进行，即无参数，无返回值，无实际逻辑。AOP 通知类型查看　=&gt; <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-advice">Declaring Advice</a></p>
<pre><code class="language-java">// 增强类 or 通知类 =&gt; 不同方法代表不同通知内容
@Component // 生成 bean
@Aspect // 生成代理对象 &amp; 作为 AOP 处理
@Order(3) // 多个增强类设置优先级
public class UserProxy {
    // 相同切入点抽取
    @Pointcut(value="execution(* com.&lt;secret&gt;.spring5.aopanno.User.uMethod())")
    public void pointExtraction(){

    }
    // 前置通知
    @Before(value="execution(* com.&lt;secret&gt;.spring5.aopanno.User.uMethod())")
    public void before(){
        // 前置通知
        System.out.println("before...");
    }
    // 后置通知 =&gt; 方法之后 =&gt; 异常也执行
    @After(value="pointExtraction()") // 重用切入点定义
    public void after(){
        System.out.println("after...");
    }
    // 返回通知 =&gt; 返回值之后执行
    @AfterReturning(value="pointExtraction()")
    public void afterReturning(){
        System.out.println("afterReturning...");
    }
    @AfterThrowing(value="execution(* com.&lt;secret&gt;.spring5.aopanno.User.uMethod())")
    public void afterThrowing(){
        System.out.println("afterThrowing...");
    }
    // 环绕通知
    @Around(value="execution(* com.&lt;secret&gt;.spring5.aopanno.User.uMethod())")
    public Object around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable{
        System.out.println("around before...");
        Object ret = proceedingJoinPoint.proceed();
        System.out.println("around after...");
        return ret;
    }
}
</code></pre>
<p>以下开启 Spring 对 AOP 注解驱动的支持方式任选其一即可。</p>
<pre><code class="language-java">@Configuration
@ComponentScan(basePackages = {"com.???"})
@EnableAspectJAutoProxy(proxyTargetClass = true)
public class ConfigAop {}
</code></pre>
<pre><code class="language-xml">&lt;beans ...
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="...
                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd
                           http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt;
    &lt;!-- 开启注解扫描 --&gt;
    &lt;context:component-scan base-package="com.&lt;secret&gt;.spring5.aopanno"&gt;&lt;/context:component-scan&gt;
    &lt;!-- 开启 Aspect 生成代理对象 --&gt;
    &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;
&lt;/beans&gt;
</code></pre>
<p>xml 操作 AspectJ 进行 AOP 开发：</p>
<pre><code class="language-java">// 被增强类
public class Coffee { public void drink(){ System.out.println("drinking coffee..."); } }
// 代理增强类
public class CoffeeProxy { public void before(){ System.out.println("coffee with ice"); } }
</code></pre>
<pre><code class="language-xml">&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd
                           http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt;
    &lt;!-- 创建对象 --&gt;
    &lt;bean id="coffee" class="com.&lt;secret&gt;.spring5.aopxml.Coffee"&gt;&lt;/bean&gt;
    &lt;bean id="coffeeProxy" class="com.&lt;secret&gt;.spring5.aopxml.CoffeeProxy"&gt;&lt;/bean&gt;
    &lt;!-- 配置aop增强 --&gt;
    &lt;aop:config&gt;
        &lt;!-- 切入点 --&gt;
        &lt;aop:pointcut id="p" expression="execution(* com.???.spring5.aopxml.Coffee.drink(..))"/&gt;
        &lt;!-- 配置切面 --&gt;
        &lt;aop:aspect ref="coffeeProxy"&gt;
            &lt;!-- 增强作用在具体的方法上 --&gt;
            &lt;aop:before method="before" pointcut-ref="p"/&gt;
        &lt;/aop:aspect&gt;
    &lt;/aop:config&gt;
&lt;/beans&gt;
</code></pre>
<h3 id="underlying-principle">Underlying Principle</h3>
<p>AOP 工作流程：</p>
<ol>
<li>Spring 容器启动并读取所有切面配置 @Aspect 中的切入点 @Pointcut</li>
<li>初始化 bean 并判断 bean 对应的类中方法是否匹配到任意切入点
<ul>
<li>匹配失败时，获取 bean 并调用方法执行</li>
<li>匹配成功时，创建目标对象的代理对象，根据代理对象的运行模式运行原始方法与增强的内容</li>
</ul>
</li>
</ol>
<p>通过动态代理增强类的方法：</p>
<ul>
<li>在有接口情况下使用 JDK 动态代理：创建接口实现类代理对象</li>
<li>在没有接口情况下使用 CGLIB 动态代理：创建子类的代理对象</li>
</ul>
<pre><code class="language-java">public interface UserDao {
    public int add(int a,int b);
    public String update(String str);
}
</code></pre>
<pre><code class="language-java">public class UserDaoImpl implements UserDao{
    @Override
    public int add(int a, int b) {
        System.out.println("add方法执行了");
        return a+b;
    }

    @Override
    public String update(String str) {
        System.out.println("update方法执行了");
        return str;
    }
}
</code></pre>
<pre><code class="language-java">public class JDKProxy {
    public static void main(String[] args){
        Class[] interfaces = {UserDao.class};
        // 创建接口实现类的代理对象
        // 第三参数使用匿名内部类
//        Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces, new InvocationHandler() {
//            @Override
//            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
//                return null;
//            }
//        })
        UserDaoImpl userDao = new UserDaoImpl();
        // 接口等于实现类的代理对象
        UserDao dao = (UserDao)Proxy.newProxyInstance(JDKProxy.class.getClassLoader(),interfaces, new UserDaoProxy(userDao));
        int result = dao.add(1, 2);
        System.out.println(result);
    }
}

// 创建代理对象代码
class UserDaoProxy implements InvocationHandler{
    // 创建的是谁的代理对象,就将谁传递过来
    // 有参构造传递
    private Object obj;
    public UserDaoProxy(Object obj){
        this.obj = obj;
    }
    // 对象一创建,方法就调用
    // 增强的逻辑
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        // 方法之前
        System.out.println("方法前执行 =&gt; "+method.getName()+" =&gt; 传递参数 =&gt; "+ Arrays.toString(args));
        // 被增强的方法执行
        Object res = method.invoke(obj, args);
        // 方法之后
        System.out.println("方法后执行 =&gt; "+obj);
        return res;
    }
}
</code></pre>
<h3 id="aop-%E9%80%9A%E7%9F%A5%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE">AOP 通知获取数据</h3>
<p>获取切入点方法的参数：</p>
<ul>
<li>JointPont：适用于前置、后置、返回、抛出异常后通知</li>
<li>ProceedJointPoint：适用于环绕通知</li>
</ul>
<p>获取切入点方法返回值：</p>
<ul>
<li>@AfterReturning 中使用 returning（补充 value 属性）</li>
<li>@Around 标记的环绕通知中可以直接对原始方法调用获取返回值结果</li>
</ul>
<p>获取切入点异常信息：</p>
<ul>
<li>@AfterThrowing 中使用 throwing 形参接收异常对象</li>
<li>@Around 标记的环绕通知中使用 <code>try...catch</code> 对 proceed 块进行包裹</li>
</ul>
<h2 id="spring-%E4%BA%8B%E5%8A%A1%E6%93%8D%E4%BD%9C">Spring 事务操作</h2>
<p>事务本身常作用保障数据库操作的一致性，Spring 事务可在 service 层或 dao 层上进行开展。</p>
<p>注解式事务可以添加到具体的业务方法上，也可以添加到接口上来表示当前接口的所有方法都开启事务。</p>
<p>使用 Spring 事务管理注解 @Transactional 添加在业务层接口上而非业务层实现类中（解耦）。</p>
<pre><code class="language-java">public interface XxxService{
    @Transactional
    public void transfer(...)
}
</code></pre>
<p>设置事务管理器：使用 Spring 提供的标准接口 PlatformTransactionManager。</p>
<pre><code class="language-java">// 创建事务管理器对象
@Bean
public PlatformTransactionManager transactionManager(DataSource dataSource){
    DataSourceTransactionManager dstm = new DataSourceTransactionManager();
    dstm.setDataSource(dataSource);
    return dstm;
}
</code></pre>
<h3 id="%E6%B3%A8%E8%A7%A3%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86">注解声明式事务管理</h3>
<p>声明式事务管理底层使用 AOP 原理，其 API 是根据代表事务管理器的接口，针对不同框架提供的不同实现类 =&gt; PlatformTransactionManager。</p>
<pre><code class="language-java">@Configuration // @Configuration =&gt; 代表配置类
@ComponentScan(basePackages = "com.&lt;secret&gt;.spring5.txdemo") // @ComponentScan =&gt; 组件扫描
@EnableTransactionManagement // @EnableTransactionManagement =&gt; 开启事务
public class TxConfig {
    // 创建数据库连接池
    @Bean
    public DruidDataSource getDuridDataSource(){
        DruidDataSource dataSource = new DruidDataSource();
        dataSource.setDriverClassName("com.mysql.cj.jdbc.Driver");
        dataSource.setUrl("jdbc:mysql://localhost:3306/user_db");
        dataSource.setUsername("&lt;username&gt;");
        dataSource.setPassword("&lt;password&gt;");
        return dataSource;
    }
    // 创建jdbc模板对象
    @Bean
    public JdbcTemplate getJdbcTemplate(DataSource dataSource){
        JdbcTemplate jdbcTemplate = new JdbcTemplate();
        // 注入 dataSource
        // IOC 容器已存在 dataSource 对象,根据类型找到 dataSource 对象比创建对象更好
        // jdbcTemplate.setDataSource(getDuridDataSource());
        jdbcTemplate.setDataSource(dataSource);
        return jdbcTemplate;
    }
    // 创建事务管理器对象
    @Bean
    public DataSourceTransactionManager getDataSourceTransactionManager(DataSource dataSource){
        DataSourceTransactionManager transactionManager = new DataSourceTransactionManager();
        transactionManager.setDataSource(dataSource);
        return transactionManager;
    }
}
</code></pre>
<pre><code class="language-html">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd
                           http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd
"&gt;
    &lt;!-- 开启组件扫描 --&gt;
    &lt;context:component-scan base-package="com.&lt;secret&gt;.spring5.txdemo"&gt;&lt;/context:component-scan&gt;
    &lt;!-- 数据库连接池 --&gt;
    &lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource" destroy-method="close"&gt;
        &lt;property name="url" value="jdbc:mysql://localhost:3306/{yourdb}" /&gt;
        &lt;property name="username" value={yourusername} /&gt;
        &lt;property name="password" value={yourpassword} /&gt;
        &lt;property name="driverClassName" value="com.mysql.cj.jdbc.Driver" /&gt;
    &lt;/bean&gt;
    &lt;!-- jdbctemplate对象 --&gt;
    &lt;bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt;
        &lt;!-- 注入datasource --&gt;
        &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;
    &lt;/bean&gt;
    &lt;!-- 创建事务管理器 --&gt;
    &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;
        &lt;!-- 注入数据源 =&gt; 指定对哪个数据库进行事务管理 --&gt;
        &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;
    &lt;/bean&gt;
    &lt;!-- 开启事务注解 =&gt; 指定哪个事务管理器开启 --&gt;
    &lt;tx:annotation-driven transaction-manager="transactionManager"&gt;&lt;/tx:annotation-driven&gt;
&lt;/beans&gt;
</code></pre>
<p>事务方法即对数据库表数据进行变化的操作。有或无事务的方法互相调用的操作过程称为事务传播行为。<a href="https://www.baeldung.com/spring-transactional-propagation-isolation">事务的传播行为</a>可以由传播属性指定。</p>
<p>常见的事务传播行为：</p>
<ul>
<li>REQUIRED
<ul>
<li>有事务的 A 方法调用无事务方法 B 后，B 方法使用 A 方法中事务</li>
<li>无事务 A 方法调用无事务的 B 方法后，创建新事务</li>
</ul>
</li>
<li>REQUIRED_NEW
<ul>
<li>A 方法调用无事务的方法 B，不论方法 A 是否有事务都创建新事务</li>
</ul>
</li>
</ul>
<pre><code class="language-java">@Service
// 可以加在类上或方法上 =&gt; 前者表示所有方法都添加上了事务,后者只是此方法添加事务.
// 默认传播行为就是propagation.REQUIRED
// mysql 默认隔离级别是 REPEATABLE_READ
@Transactional(propagation = Propagation.REQUIRED,isolation = Isolation.REPEATABLE_READ,timeout = -1)
public class UserService {}
</code></pre>
<p>常见的事务相关配置：</p>
<ul>
<li>rollbackFor 设置事务回滚异常，解决部分异常不回滚的情况</li>
</ul>
<p>Spring 在遇见 Error 和 Runtime 异常时才会回滚，IO 异常不会进行回滚。</p>
<pre><code class="language-java">if(true) {throw new IOException();} // 事务不生效
</code></pre>
<p>在 @Transactional 中设置 <code>rollbackFor = {IOException.class}</code> 进行回滚。</p>
<pre><code class="language-java">@Transactional(rollbackFor = {IOException.class})
</code></pre>
<p>事务的隔离性是为解决在并发操作中产生的脏读、不可重复读、幻读等问题。脏读是一个未提交的事务读取了另一个未提交事务的数据；不可重复读表示一个未提交的事务读取到了另一个提交了事务修改的数据（数据不准确）；幻读是一个未提交事务读取到了另一个提交事务添加的数据。</p>
<p>事务需在超时时间 timeout 内进行提交，否则回滚，默认值 -1。</p>
<p>是否只读 readOnly 指是否可在查询的基础上进行添加修改，默认为 false。</p>
<p>回滚 rollbackFor 设置出现哪些异常进行事务回滚；不回滚 noRollBackFor 设置出现哪些异常不进行事务回滚。</p>
<h3 id="xml-%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86">XML 声明式事务管理</h3>
<p>配置事务管理器，配置通知，配置切入点与切面。</p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd
                           http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd
                           http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd
"&gt;
    &lt;!-- 开启组件扫描 --&gt;
    &lt;context:component-scan base-package="com.&lt;secret&gt;.spring5.txdemo"&gt;&lt;/context:component-scan&gt;
    &lt;!-- 数据库连接池 --&gt;
    &lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource" destroy-method="close"&gt;
        &lt;property name="url" value="jdbc:mysql://localhost:3306/user_db" /&gt;
        &lt;property name="username" value="&lt;username&gt;" /&gt;
        &lt;property name="password" value="&lt;password&gt;"/&gt;
        &lt;property name="driverClassName" value="com.mysql.cj.jdbc.Driver"/&gt;
    &lt;/bean&gt;
    &lt;!-- jdbctemplate对象 --&gt;
    &lt;bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt;
        &lt;!-- 注入datasource --&gt;
        &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;
    &lt;/bean&gt;
    &lt;!-- 创建事务管理器 --&gt;
    &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;
        &lt;!-- 注入数据源 =&gt; 指定对哪个数据库进行事务管理 --&gt;
        &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;
    &lt;/bean&gt;
    &lt;!-- 配置通知 --&gt;
    &lt;tx:advice id="txadvice"&gt;
        &lt;!-- 配置事务相关参数 --&gt;
        &lt;tx:attributes&gt;
            &lt;!-- 指定哪种规则的方法上添加事务 --&gt;
            &lt;!-- &lt;tx:method name="account*"/&gt; --&gt;
            &lt;tx:method name="accountMoney" propagation="REQUIRED"&gt;&lt;/tx:method&gt;
        &lt;/tx:attributes&gt;
    &lt;/tx:advice&gt;
    &lt;!-- 配置切入点和切面 --&gt;
    &lt;aop:config&gt;
        &lt;!-- 配置切入点 --&gt;
        &lt;aop:pointcut id="pt" expression="execution(* com.&lt;secret&gt;.spring5.txdemo.service.UserService.*(..))"/&gt;
        &lt;!-- 配置切面 =&gt; 事务加到具体方法上 --&gt;
        &lt;aop:advisor advice-ref="txadvice" pointcut-ref="pt"&gt;&lt;/aop:advisor&gt;
    &lt;/aop:config&gt;
&lt;/beans&gt;
</code></pre>
<h2 id="spring5-%E6%96%B0%E7%89%B9%E6%80%A7-%E5%85%B6%E4%BB%96">Spring5 新特性 &amp; 其他</h2>
<p>Spring5 框架基于 Java8 实现，运行时兼容 JDK9。其自带通用日志的封装，已移除 Log4jConfigListener，建议使用 Log4j2。</p>
<h3 id="log4j2">Log4j2</h3>
<ul>
<li>引入 jar 包</li>
</ul>
<pre><code>log4j-api-2.11.2.jar
log4j-core-2.11.2.jar
log4j-slf4j-impl-2.11.2.jar
slf4j-api-1.7.30.jar
</code></pre>
<ul>
<li>创建 Log4j2.xml 配置文件</li>
</ul>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!--日志级别以及优先级排序: OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt; ALL --&gt;
&lt;!--Configuration后面的status用于设置log4j2自身内部的信息输出，可以不设置，当设置成trace时，可以看到log4j2内部各种详细输出--&gt;
&lt;configuration status="DEBUG"&gt;
    &lt;!--先定义所有的appender--&gt;
    &lt;appenders&gt;
        &lt;!--输出日志信息到控制台--&gt;
        &lt;console name="Console" target="SYSTEM_OUT"&gt;
            &lt;!--控制日志输出的格式--&gt;
            &lt;PatternLayout pattern="%d{yyyy-MM-dd HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n"/&gt;
        &lt;/console&gt;
    &lt;/appenders&gt;
    &lt;!--然后定义logger，只有定义了logger并引入的appender，appender才会生效--&gt;
    &lt;!--root：用于指定项目的根日志，如果没有单独指定Logger，则会使用root作为默认的日志输出--&gt;
    &lt;loggers&gt;
        &lt;root level="info"&gt;
            &lt;appender-ref ref="Console"/&gt;
        &lt;/root&gt;
    &lt;/loggers&gt;
&lt;/configuration&gt;
</code></pre>
<ul>
<li>手动输出日志</li>
</ul>
<pre><code class="language-java">public class UserLog {
    private static final Logger log = LoggerFactory.getLogger(UserLog.class);
    public static void main(String[] args) {
        log.info("hello log4j2");
        log.warn("hello log4j2");
    }
}
</code></pre>
<h3 id="nullable-%E6%B3%A8%E8%A7%A3">@Nullable 注解</h3>
<p>@Nullable 注解可以使用在方法、属性、参数上，分别表示方法返回可以为空、属性值可以为空、参数值可以为空，常用来避免空指针异常。</p>
<h3 id="%E5%87%BD%E6%95%B0%E5%BC%8F%E9%A3%8E%E6%A0%BC">函数式风格</h3>
<p>Spring5 创建一个类的对象可以使用注解或者配置文件，若是手动 new 对象还需要在 Spring 中进行注册。新特性支持函数式风格创建对象，交给 Spring 管理。</p>
<pre><code class="language-java">public class GACACAC {
    @Test
    public void testGACAC(){
        // 创建 GenericApplicationContext
        GenericApplicationContext ctx = new GenericApplicationContext();
        // 调用context方法对象注册
        ctx.refresh();
        // new 出来的对象会在 spring5 完成注册
        ctx.registerBean("personName",Person.class,()-&gt;new Person());
        // 获取注册的对象
        // Person p = (Person)ctx.getBean("com.&lt;secret&gt;.spring5.txdemo.test.Person");
        Person p = (Person)ctx.getBean("personName");
        System.out.println(p);
    }
}
</code></pre>
<h3 id="%E6%95%B4%E5%90%88-junit45">整合 JUnit4|5</h3>
<ul>
<li>引入 Spring 针对测试依赖</li>
</ul>
<pre><code>spring-test-5.2.6.RELEASE.jar
</code></pre>
<ul>
<li>创建测试类，使用注解方式完成</li>
</ul>
<pre><code class="language-java">// JUnit4
@RunWith(SpringJUnit4ClassRunner.class) // 指定单元测试框架版本
@ContextConfiguration("classpath:xmlDeclarativeTxManager.xml") // 加载配置文件
public class JTest4 {
    @Autowired
    private UserService userService;
    @Test
    public void test1(){
        userService.accountMoney();
    }
}
// ---
// JUnit5
// 需引入 JUnit5 的 jar 包 =&gt; import org.junit.jupiter.api.Test;
// @ExtendWith(SpringExtension.class) // 注解引用
// @ContextConfiguration("classpath:xmlDeclarativeTxManager.xml")
@SpringJUnitConfig(locations = "classpath:xmlDeclarativeTxManager.xml") // 复合注解
public class JTest5 {
    @Autowired
    private UserService userService;
    @Test
    public void test1(){
        userService.accountMoney();
    }
}
</code></pre>
<h3 id="jdbctemplate">JdbcTemplate</h3>
<p>Spring 封装 Template 形式的模板类，便于操作 Redis、Mysql 等数据库。Service 通常存放业务操作，dao 则存放数据库操作，不写业务。service 注入 dao，dao 注入 jdbctemplate，jdbctemplate 注入 DataSource。</p>
<pre><code class="language-java">druid-1.1.9.jar
mysql-connector-java-8.0.29.jar
spring-jdbc-5.2.6.RELEASE-sources.jar
spring-tx-5.2.6.RELEASE-sources.jar
spring-orm-5.2.6.RELEASE.jar // 整合其他框架 mybatis hibernate
</code></pre>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt;
    &lt;!-- 开启组件扫描 --&gt;
    &lt;context:component-scan base-package="com.&lt;secret&gt;.spring5"&gt;&lt;/context:component-scan&gt;
    &lt;!-- 数据库连接池 --&gt;
    &lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource" destroy-method="close"&gt;
        &lt;property name="url" value="jdbc:mysql://localhost:3306/user_db" /&gt;
        &lt;property name="username" value="&lt;username&gt;" /&gt;
        &lt;property name="password" value="&lt;password&gt;"/&gt;
        &lt;property name="driverClassName" value="com.mysql.cj.jdbc.Driver"/&gt;
    &lt;/bean&gt;
    &lt;!-- jdbctemplate对象 --&gt;
    &lt;bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt;
        &lt;!-- 注入datasource =&gt; set 方法注入 --&gt;
        &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="language-java">public class Book {
    private String userId;
    private String username;
    private String ustatus;
    @Override
    public String toString() {...}
    &lt;GETTER...&gt;
    &lt;SETTER...&gt;
}
</code></pre>
<pre><code class="language-java">@Service
public class BookService {
    // 注入DAO
    @Autowired
    private BookDao bookDao;
    // 添加方法
    public void addBook(Book book){ bookDao.add(book); }
    // 修改方法
    public void updateBook(Book book){bookDao.updateBook(book); }
    // 删除方法
    public void deleteBook(String id){ bookDao.deleteBook(id); }
    // 查询表记录数
    public int findCount(){ return bookDao.selectCount(); }
    // 查询表记录
    public Book findOne(String id){ return bookDao.findBookInfo(id); }
    // 查询返回集合
    public List&lt;Book&gt; findAll(){ return bookDao.findAllBook(); }
    // 批量添加
    public void batchAdd(List&lt;Object[]&gt; batchArgs){ bookDao.batchAddBook(batchArgs); }
    // 批量修改
    public void batchUpdate(List&lt;Object[]&gt; batchArgs){ bookDao.batchUpdateBook(batchArgs); }
    // 批量删除
    public void batchDelete(List&lt;Object[]&gt; batchArgs){ bookDao.batchDeleteBook(batchArgs); }
}
</code></pre>
<pre><code class="language-java">public interface BookDao {
    // 添加的方法
    void add(Book book);
    void updateBook(Book book);
    void deleteBook(String id);
    int selectCount();
    Book findBookInfo(String id);
    List&lt;Book&gt; findAllBook();
    void batchAddBook(List&lt;Object[]&gt; batchArgs);
    void batchUpdateBook(List&lt;Object[]&gt; batchArgs);
    void batchDeleteBook(List&lt;Object[]&gt; batchArgs);
}
</code></pre>
<pre><code class="language-java">@Repository
public class BookDaoImpl implements BookDao{
    // 注入JDBC
    @Autowired
    private JdbcTemplate jdbcTemplate;

    @Override
    public void add(Book book) {
        // 调用jdbc template中的update方法实现添加操作
        String sql = "INSERT INTO t_book VALUES(?,?,?)";
        Object[] args = {book.getUserId(), book.getUsername(), book.getUstatus()};
        int update = jdbcTemplate.update(sql,args);
        System.out.println(update);
    }

    @Override
    public void updateBook(Book book) {
        String sql = "UPDATE t_book SET username=?,ustatus=? WHERE user_id=?";
        Object[] args = {book.getUsername(), book.getUstatus(),book.getUserId()};
        int update = jdbcTemplate.update(sql,args);
        System.out.println(update);
    }

    @Override
    public void deleteBook(String id) {
        String sql = "DELETE FROM t_book WHERE user_id = ?";
        int update = jdbcTemplate.update(sql, id);
        System.out.println(update);
    }

    // 查询表中的记录数
    @Override
    public int selectCount() {
        String sql = "SELECT COUNT(*) FROM t_book";
        Integer count = jdbcTemplate.queryForObject(sql, Integer.class);
        return count;
    }

    @Override
    public Book findBookInfo(String id) {
        String sql = "SELECT * FROM t_book WHERE user_id=?";
        // RowMapper是不同类型的接口,使用此接口实现类完成数据的封装
        Book book = jdbcTemplate.queryForObject(sql, new BeanPropertyRowMapper&lt;Book&gt;(Book.class), id);
        return book;
    }

    @Override
    public List&lt;Book&gt; findAllBook() {
        String sql = "SELECT * FROM t_book";
        List&lt;Book&gt; list = jdbcTemplate.query(sql, new BeanPropertyRowMapper&lt;Book&gt;(Book.class));
        return list;
    }

    @Override
    public void batchAddBook(List&lt;Object[]&gt; batchArgs) {
        String sql = "INSERT INTO t_book VALUES(?,?,?)";
        int[] ints = jdbcTemplate.batchUpdate(sql,batchArgs);
        System.out.println(Arrays.toString(ints));
    }

    @Override
    public void batchUpdateBook(List&lt;Object[]&gt; batchArgs) {
        String sql = "UPDATE t_book SET username=?,ustatus=? WHERE user_id=?";
        int[] ints = jdbcTemplate.batchUpdate(sql, batchArgs);
        System.out.println(ints);
    }

    @Override
    public void batchDeleteBook(List&lt;Object[]&gt; batchArgs) {
        String sql = "DELETE FROM t_book WHERE user_id = ?";
        int[] ints = jdbcTemplate.batchUpdate(sql, batchArgs);
        System.out.println(Arrays.toString(ints));
    }
}
</code></pre>
<pre><code class="language-java">public class TestBook {
    @Test
    public void testAdd(){
        ApplicationContext context = new ClassPathXmlApplicationContext("jdbcTemp1.xml");
        BookService bookService = context.getBean("bookService", BookService.class);
        // 添加
        Book book = new Book();
        book.setUserId("1");
        book.setUsername("java");
        book.setUstatus("a");
        bookService.addBook(book);
    }
    @Test
    public void testUpdate(){
        ApplicationContext context = new ClassPathXmlApplicationContext("jdbcTemp1.xml");
        BookService bookService = context.getBean("bookService", BookService.class);
        // 修改
        Book book = new Book();
        book.setUserId("1");
        book.setUsername("java");
        book.setUstatus("zs");
        bookService.updateBook(book);
    }
    @Test
    public void testDel(){
        ApplicationContext context = new ClassPathXmlApplicationContext("jdbcTemp1.xml");
        BookService bookService = context.getBean("bookService", BookService.class);
        // 删除
        bookService.deleteBook("1");
    }
    @Test
    public void testFindCount(){
        ApplicationContext context = new ClassPathXmlApplicationContext("jdbcTemp1.xml");
        BookService bookService = context.getBean("bookService", BookService.class);
        // 删除
        int count = bookService.findCount();
        System.out.println(count);
        System.out.println(count);
    }
    // 测试查询返回对象
    @Test
    public void testFindOne(){
        ApplicationContext context = new ClassPathXmlApplicationContext("jdbcTemp1.xml");
        BookService bookService = context.getBean("bookService", BookService.class);
        Book one = bookService.findOne("1");
        System.out.println(one);
    }

    @Test
    public void testfindAllBook(){
        ApplicationContext context = new ClassPathXmlApplicationContext("jdbcTemp1.xml");
        BookService bookService = context.getBean("bookService", BookService.class);
        List&lt;Book&gt; all = bookService.findAll();
        System.out.println(all);
    }
    @Test
    public void testAddBatchBooks(){
        ApplicationContext context = new ClassPathXmlApplicationContext("jdbcTemp1.xml");
        BookService bookService = context.getBean("bookService", BookService.class);
        List&lt;Object[]&gt; batchArgs = new ArrayList&lt;&gt;();
        Object[] o1 = {"2","javascript","ok"};
        Object[] o2 = {"3","nodejs","okk"};
        Object[] o3 = {"4","C++","okkk"};
        batchArgs.add(o1);
        batchArgs.add(o2);
        batchArgs.add(o3);
        bookService.batchAdd(batchArgs);
    }
    @Test
    public void testUpdateBatchBooks(){
        ApplicationContext context = new ClassPathXmlApplicationContext("jdbcTemp1.xml");
        BookService bookService = context.getBean("bookService", BookService.class);
        List&lt;Object[]&gt; batchArgs = new ArrayList&lt;&gt;();
        Object[] o1 = {"javascript","yes","2"};
        Object[] o2 = {"nodejs","ok","3"};
        Object[] o3 = {"C++","okk","4"};
        batchArgs.add(o1);
        batchArgs.add(o2);
        batchArgs.add(o3);
        bookService.batchUpdate(batchArgs);
    }
    @Test
    public void testDeleteBatchBooks(){
        ApplicationContext context = new ClassPathXmlApplicationContext("jdbcTemp1.xml");
        BookService bookService = context.getBean("bookService", BookService.class);
        List&lt;Object[]&gt; batchArgs = new ArrayList&lt;&gt;();
        Object[] o1 = {"4"};
        batchArgs.add(o1);
        bookService.batchDelete(batchArgs);
    }
}
</code></pre>
<h2 id="bugs-%E8%A7%A3%E5%86%B3">Bugs 解决</h2>
<ul>
<li>BeanDefinitionStoreException</li>
</ul>
<pre><code class="language-java">// 报错原文
org.springframework.beans.factory.BeanDefinitionStoreException: Unexpected exception parsing XML document from class path resource.
</code></pre>
<p>在开启组件扫描的 base-package 下，是否存在多个需要扫描的文件。若存在则需要进一步缩小扫描范围。</p>
<ul>
<li>Exception encountered during context initialization</li>
</ul>
<pre><code class="language-java">// 报错原文
WARNING: Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'xxxService': Unsatisfied dependency expressed through field 'xxxDao';
</code></pre>
<p>在测试类中进行进一步验证；概率性加载 xml 文件错误。</p>
<ul>
<li>UnsatisfiedDependencyException</li>
</ul>
<pre><code class="language-java">org.springframework.context.support.AbstractApplicationContext refresh
WARNING: Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'userDaoImpl': Unsatisfied dependency expressed through field 'jdbcTemplate'; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'getJdbcTemplate' defined in com.&lt;secret&gt;.spring5.txdemo.config.TxConfig: Unsatisfied dependency expressed through method 'getJdbcTemplate' parameter 0; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type 'javax.sql.DataSource' available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: {}
</code></pre>
<h2 id="%E7%BB%93%E6%9D%9F">结束</h2>
<p>本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh"> CC BY-SA 4.0 </a>协议，转载请注明出处！</p>


            </section>

        </article>
    </main>
    <footer class="page-footer">
            <amp-img class="site-icon" src="yourdomain.com/content/images/2021/07/ghost-orb.png" width="50" height="50" layout="fixed" alt="zairesinatra"></amp-img>
        <h3>zairesinatra</h3>
            <p>The best time to recognize yourself is ten years ago, followed by now.</p>
        <p><a href="../../index.html">Read more posts →</a></p>
        <a class="powered" href="https://ghost.org" target="_blank" rel="noopener"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 156 156"><g fill="none" fill-rule="evenodd"><rect fill="#15212B" width="156" height="156" rx="27"/><g transform="translate(36 36)" fill="#F6F8FA"><path d="M0 71.007A4.004 4.004 0 014 67h26a4 4 0 014 4.007v8.986A4.004 4.004 0 0130 84H4a4 4 0 01-4-4.007v-8.986zM50 71.007A4.004 4.004 0 0154 67h26a4 4 0 014 4.007v8.986A4.004 4.004 0 0180 84H54a4 4 0 01-4-4.007v-8.986z"/><rect y="34" width="84" height="17" rx="4"/><path d="M0 4.007A4.007 4.007 0 014.007 0h41.986A4.003 4.003 0 0150 4.007v8.986A4.007 4.007 0 0145.993 17H4.007A4.003 4.003 0 010 12.993V4.007z"/><rect x="67" width="17" height="17" rx="4"/></g></g></svg> Published with Ghost</a>
    </footer>
    
</body>
</html>
