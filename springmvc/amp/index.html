<!DOCTYPE html>
<html ⚡>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">

    <title>SpringMVC</title>

    <meta name="description" content="Spring 全家桶之 SpringMVC" />
    <link rel="icon" href="../../content/images/size/w256h256/2021/07/ghost-orb.png" type="image/png" />
    <link rel="canonical" href="../index.html" />
    <meta name="referrer" content="no-referrer-when-downgrade" />
    
    <meta property="og:site_name" content="zairesinatra" />
    <meta property="og:type" content="article" />
    <meta property="og:title" content="SpringMVC" />
    <meta property="og:description" content="Spring 全家桶之 SpringMVC" />
    <meta property="og:url" content="yourdomain.com/springmvc/" />
    <meta property="og:image" content="yourdomain.com/content/images/2022/06/coffeeBeans.jpg" />
    <meta property="article:published_time" content="2020-06-06T14:10:00.000Z" />
    <meta property="article:modified_time" content="2022-07-04T13:25:26.000Z" />
    <meta property="article:tag" content="Technology growth" />
    
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="SpringMVC" />
    <meta name="twitter:description" content="Spring 全家桶之 SpringMVC" />
    <meta name="twitter:url" content="yourdomain.com/springmvc/" />
    <meta name="twitter:image" content="yourdomain.com/content/images/2022/06/coffeeBeans.jpg" />
    <meta name="twitter:label1" content="Written by" />
    <meta name="twitter:data1" content="Ziyi Xie" />
    <meta name="twitter:label2" content="Filed under" />
    <meta name="twitter:data2" content="Technology growth" />
    <meta name="twitter:site" content="@xieziyi0422" />
    <meta property="og:image:width" content="1920" />
    <meta property="og:image:height" content="1080" />
    
    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "publisher": {
        "@type": "Organization",
        "name": "zairesinatra",
        "url": "yourdomain.com/",
        "logo": {
            "@type": "ImageObject",
            "url": "yourdomain.com/content/images/2021/07/zs-1.JPG",
            "width": 60,
            "height": 60
        }
    },
    "author": {
        "@type": "Person",
        "name": "Ziyi Xie",
        "image": {
            "@type": "ImageObject",
            "url": "yourdomain.com/content/images/2021/07/zs-2.JPG",
            "width": 1079,
            "height": 1079
        },
        "url": "yourdomain.com/author/ziyi/",
        "sameAs": []
    },
    "headline": "SpringMVC",
    "url": "yourdomain.com/springmvc/",
    "datePublished": "2020-06-06T14:10:00.000Z",
    "dateModified": "2022-07-04T13:25:26.000Z",
    "image": {
        "@type": "ImageObject",
        "url": "yourdomain.com/content/images/2022/06/coffeeBeans.jpg",
        "width": 1920,
        "height": 1080
    },
    "keywords": "Technology growth",
    "description": "Spring 全家桶之 SpringMVC",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "yourdomain.com/"
    }
}
    </script>

    <meta name="generator" content="Ghost 5.10" />
    <link rel="alternate" type="application/rss+xml" title="zairesinatra" href="../../rss/index.html" />

    <style amp-custom>
    *,
    *::before,
    *::after {
        box-sizing: border-box;
    }

    html {
        overflow-x: hidden;
        overflow-y: scroll;
        font-size: 62.5%;
        -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
    }

    body {
        min-height: 100vh;
        margin: 0;
        padding: 0;
        color: #3a4145;
        font-family: -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Open Sans,Helvetica Neue,sans-serif;
        font-size: 1.7rem;
        line-height: 1.55em;
        font-weight: 400;
        font-style: normal;
        background: #fff;
        scroll-behavior: smooth;
        overflow-x: hidden;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
    }

    p,
    ul,
    ol,
    li,
    dl,
    dd,
    hr,
    pre,
    form,
    table,
    video,
    figure,
    figcaption,
    blockquote {
        margin: 0;
        padding: 0;
    }

    ul[class],
    ol[class] {
        padding: 0;
        list-style: none;
    }

    img {
        display: block;
        max-width: 100%;
    }

    input,
    button,
    select,
    textarea {
        font: inherit;
        -webkit-appearance: none;
    }

    fieldset {
        margin: 0;
        padding: 0;
        border: 0;
    }

    label {
        display: block;
        font-size: 0.9em;
        font-weight: 700;
    }

    hr {
        position: relative;
        display: block;
        width: 100%;
        height: 1px;
        border: 0;
        border-top: 1px solid currentcolor;
        opacity: 0.1;
    }

    ::selection {
        text-shadow: none;
        background: #cbeafb;
    }

    mark {
        background-color: #fdffb6;
    }

    small {
        font-size: 80%;
    }

    sub,
    sup {
        position: relative;
        font-size: 75%;
        line-height: 0;
        vertical-align: baseline;
    }
    sup {
        top: -0.5em;
    }
    sub {
        bottom: -0.25em;
    }

    ul li + li {
        margin-top: 0.6em;
    }

    a {
        color: var(--ghost-accent-color, #1292EE);
        text-decoration-skip-ink: auto;
    }

    h1,
    h2,
    h3,
    h4,
    h5,
    h6 {
        margin: 0;
        font-weight: 700;
        color: #121212;
        line-height: 1.4em;
    }

    h1 {
        font-size: 3.4rem;
        line-height: 1.1em;
    }

    h2 {
        font-size: 2.4rem;
        line-height: 1.2em;
    }

    h3 {
        font-size: 1.8rem;
    }

    h4 {
        font-size: 1.7rem;
    }

    h5 {
        font-size: 1.6rem;
    }

    h6 {
        font-size: 1.6rem;
    }

    amp-img {
        height: 100%;
        width: 100%;
        max-width: 100%;
        max-height: 100%;
    }

    amp-img img {
        object-fit: cover;
    }

    .page-header {
        padding: 50px 5vmin 30px;
        text-align: center;
        font-size: 2rem;
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }

    .page-header a {
        color: #121212;
        font-weight: 700;
        text-decoration: none;
        font-size: 1.6rem;
        letter-spacing: -0.1px;
    }

    .post {
        max-width: 680px;
        margin: 0 auto;
    }

    .post-header {
        margin: 0 5vmin 5vmin;
        text-align: center;
    }

    .post-meta {
        margin: 1rem 0 0 0;
        text-transform: uppercase;
        color: #738a94;
        font-weight: 500;
        font-size: 1.3rem;
    }

    .post-image {
        margin: 0 0 5vmin;
    }

    .post-image img {
        display: block;
        width: 100%;
        height: auto;
    }

    .post-content {
        padding: 0 5vmin;
    }

    .post-content > * + * {
        margin-top: 1.5em;
    }

    .post-content [id]:not(:first-child) {
        margin: 2em 0 0;
    }

    .post-content > [id] + * {
        margin-top: 1rem;
    }

    .post-content [id] + .kg-card,
    .post-content blockquote + .kg-card {
        margin-top: 40px;
    }

    .post-content > ul,
    .post-content > ol,
    .post-content > dl {
        padding-left: 1.9em;
    }

    .post-content hr {
        margin-top: 40px;
    }

    .post .post-content hr + * {
        margin-top: 40px;
    }

    .post-content amp-img {
        background-color: #f8f8f8;
    }

    .post-content blockquote {
        position: relative;
        font-style: italic;
    }

    .post-content blockquote::before {
        content: "";
        position: absolute;
        left: -1.5em;
        top: 0;
        bottom: 0;
        width: 0.3rem;
        background: var(--ghost-accent-color, #1292EE);
    }

    .post-content blockquote.kg-blockquote-alt {
        font-size: 1.2em;
        font-style: italic;
        line-height: 1.6em;
        text-align: center;
        color: #738a94;
        padding: 0.75em 3em 1.25em;
    }

    .post-content blockquote.kg-blockquote-alt::before {
        display: none;
    }

    .post-content :not(.kg-card):not([id]) + .kg-card {
        margin-top: 40px;
    }

    .post-content .kg-card + :not(.kg-card) {
        margin-top: 40px;
    }

    .kg-card figcaption {
        padding: 1.5rem 1.5rem 0;
        text-align: center;
        font-weight: 500;
        font-size: 1.3rem;
        line-height: 1.4em;
        opacity: 0.6;
    }

    .kg-card figcaption strong {
        color: rgba(0,0,0,0.8);
    }

    .post-content :not(pre) code {
        vertical-align: middle;
        padding: 0.15em 0.4em 0.15em;
        border: #e1eaef 1px solid;
        font-weight: 400;
        font-size: 0.9em;
        line-height: 1em;
        color: #15171a;
        background: #f0f6f9;
        border-radius: 0.25em;
    }

    .post-content > pre {
        overflow: scroll;
        padding: 16px 20px;
        color: #fff;
        background: #1F2428;
        border-radius: 5px;
        box-shadow: 0 2px 6px -2px rgba(0,0,0,.1), 0 0 1px rgba(0,0,0,.4);
    }

    .kg-embed-card {
        display: flex;
        flex-direction: column;
        align-items: center;
        width: 100%;
    }

    .kg-image-card img {
        margin: auto;
    }

    .kg-gallery-card + .kg-gallery-card {
        margin-top: 0.75em;
    }

    .kg-gallery-container {
        position: relative;
    }

    .kg-gallery-row {
        display: flex;
        flex-direction: row;
        justify-content: center;
    }

    .kg-gallery-image {
        width: 100%;
        height: 100%;
    }

    .kg-gallery-row:not(:first-of-type) {
        margin: 0.75em 0 0 0;
    }

    .kg-gallery-image:not(:first-of-type) {
        margin: 0 0 0 0.75em;
    }

    .kg-bookmark-card,
    .kg-bookmark-publisher {
        position: relative;
    }

    .kg-bookmark-container,
    .kg-bookmark-container:hover {
        display: flex;
        flex-wrap: wrap;
        flex-direction: row-reverse;
        color: currentColor;
        background: rgba(255,255,255,0.6);
        font-family: -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Open Sans,Helvetica Neue,sans-serif;
        text-decoration: none;
        border-radius: 3px;
        box-shadow: 0 2px 6px -2px rgba(0, 0, 0, 0.1), 0 0 1px rgba(0, 0, 0, 0.4);
        overflow: hidden;
    }

    .kg-bookmark-content {
        flex-basis: 0;
        flex-grow: 999;
        padding: 20px;
        order: 1;
    }

    .kg-bookmark-title {
        font-weight: 600;
        font-size: 1.5rem;
        line-height: 1.3em;
    }

    .kg-bookmark-description {
        display: -webkit-box;
        max-height: 45px;
        margin: 0.5em 0 0 0;
        font-size: 1.4rem;
        line-height: 1.55em;
        overflow: hidden;
        opacity: 0.8;
        -webkit-line-clamp: 2;
        -webkit-box-orient: vertical;
    }

    .kg-bookmark-metadata {
        margin-top: 20px;
    }

    .kg-bookmark-metadata {
        display: flex;
        align-items: center;
        font-weight: 500;
        font-size: 1.3rem;
        line-height: 1.3em;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    .kg-bookmark-description {
        display: -webkit-box;
        -webkit-box-orient: vertical;
        -webkit-line-clamp: 2;
        overflow: hidden;
    }

    .kg-bookmark-metadata amp-img {
        width: 18px;
        height: 18px;
        max-width: 18px;
        max-height: 18px;
        margin-right: 10px;
    }

    .kg-bookmark-thumbnail {
        display: flex;
        flex-basis: 20rem;
        flex-grow: 1;
        justify-content: flex-end;
    }

    .kg-bookmark-thumbnail amp-img {
        max-height: 200px;
    }

    .kg-bookmark-author {
        white-space: nowrap;
        text-overflow: ellipsis;
        overflow: hidden;
    }

    .kg-bookmark-publisher::before {
        content: "•";
        margin: 0 .5em;
    }

    .kg-toggle-card-icon {
        display: none;
    }

    .kg-toggle-content {
        margin-top: 0.8rem;
    }

    .kg-product-card-container {
        background: transparent;
        padding: 20px;
        width: 100%;
        border-radius: 5px;
        box-shadow: inset 0 0 0 1px rgb(124 139 154 / 25%);
    }

    .kg-product-card-description p {
        margin-top: 1.5em;
    }

    .kg-product-card-description ul {
        margin-left: 24px;
    }

    .kg-product-card-title {
        font-size: 1.9rem;
        font-weight: 700;
    }

    .kg-product-card-rating-star {
        height: 28px;
        width: 20px;
        margin-right: 2px;
    }

    .kg-product-card-rating-star svg {
    width: 16px;
    height: 16px;
    fill: currentColor;
    opacity: 0.15;
    }

    .kg-product-card-rating-active.kg-product-card-rating-star svg {
    opacity: 1;
    }

    .kg-nft-card-container {
        position: relative;
        display: flex;
        flex: auto;
        flex-direction: column;
        text-decoration: none;
        font-family: -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Open Sans,Helvetica Neue,sans-serif;
        font-size: 1.4rem;
        font-weight: 400;
        box-shadow: 0 2px 6px -2px rgb(0 0 0 / 10%), 0 0 1px rgb(0 0 0 / 40%);
        width: 100%;
        max-width: 512px;
        color: #15212A;
        background: #fff;
        border-radius: 5px;
        transition: none;
        margin: 0 auto;
    }

    .kg-nft-metadata {
        padding: 2.0rem;
    }

    .kg-nft-image-container {
        position: relative;
    }

    .kg-nft-image {
        display: flex;
        border-radius: 5px 5px 0 0;
    }

    .kg-nft-header {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        gap: 20px;
    }

    .kg-nft-header h4.kg-nft-title {
        font-size: 1.9rem;
        font-weight: 700;
        margin: 0;
        color: #15212A;
    }

    .kg-nft-header amp-img {
        max-width: 114px;
        max-height: 26px;
    }

    .kg-nft-opensea-logo {
        margin-top: 2px;
        width: 100px;
    }

    .kg-nft-creator {
        font-family: inherit;
        color: #95A1AD;
    }

    .kg-nft-creator span {
        font-weight: 500;
        color: #15212A;
    }

    .kg-nft-card p.kg-nft-description {
        font-size: 1.4rem;
        line-height: 1.4em;
        margin: 2.0rem 0 0;
        color: #222;
    }

    .kg-button-card {
        display: flex;
        position: static;
        align-items: center;
        width: 100%;
        justify-content: center;
    }

    .kg-btn {
        display: flex;
        position: static;
        align-items: center;
        padding: 0 2.0rem;
        height: 4.0rem;
        line-height: 4.0rem;
        font-size: 1.65rem;
        font-weight: 600;
        text-decoration: none;
        border-radius: 5px;
        transition: opacity 0.2s ease-in-out;
    }

    .kg-btn:hover {
        opacity: 0.85;
    }

    .kg-btn-accent {
        background-color: var(--ghost-accent-color, #1292EE);
        color: #fff;
    }

    .kg-callout-card {
        display: flex;
        padding: 20px 28px;
        border-radius: 3px;
    }

    .kg-callout-card-grey {
        background: rgba(124, 139, 154, 0.13);
    }

    .kg-callout-card-white {
        background: transparent;
        box-shadow: inset 0 0 0 1px rgba(124, 139, 154, 0.25);
    }

    .kg-callout-card-blue {
        background: rgba(33, 172, 232, 0.12);
    }

    .kg-callout-card-green {
        background: rgba(52, 183, 67, 0.12);
    }

    .kg-callout-card-yellow {
        background: rgba(240, 165, 15, 0.13);
    }

    .kg-callout-card-red {
        background: rgba(209, 46, 46, 0.11);
    }

    .kg-callout-card-pink {
        background: rgba(225, 71, 174, 0.11);
    }

    .kg-callout-card-purple {
        background: rgba(135, 85, 236, 0.12);
    }

    .kg-callout-card-accent {
        background: var(--ghost-accent-color);
        color: #fff;
    }

    .kg-callout-card-accent a {
        color: #fff;
    }

    .kg-callout-emoji {
        padding-right: 16px;
        line-height: 1.3;
        font-size: 1.25em;
    }

    .kg-header-card {
        padding: 6em 3em;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        text-align: center;
    }

    .kg-header-card.kg-size-small {
        padding-top: 4em;
        padding-bottom: 4em;
    }

    .kg-header-card.kg-size-large {
        padding-top: 12em;
        padding-bottom: 12em;
    }

    .kg-header-card.kg-width-full {
        padding-left: 4em;
        padding-right: 4em;
    }

    .kg-header-card.kg-align-left {
        text-align: left;
        align-items: flex-start;
    }

    .kg-header-card.kg-style-dark {
        background: #15171a;
        color: #ffffff;
    }

    .kg-header-card.kg-style-light {
        color: #15171a;
        border: 1px solid rgba(124, 139, 154, 0.25);
        border-width: 1px 0;
    }

    .kg-header-card.kg-style-accent {
        background-color: var(--ghost-accent-color);
    }

    .kg-header-card.kg-style-image {
        background-color: #e7e7eb;
        background-size: cover;
        background-position: center center;
    }

    .kg-header-card h2 {
        font-size: 4em;
        font-weight: 700;
        line-height: 1.1em;
        margin: 0;
    }

    .kg-header-card h2 strong {
        font-weight: 800;
    }

    .kg-header-card.kg-size-small h2 {
        font-size: 3em;
    }

    .kg-header-card.kg-size-large h2 {
        font-size: 5em;
    }

    .kg-header-card h3 {
        font-size: 1.25em;
        font-weight: 500;
        line-height: 1.3em;
        margin: 0;
    }

    .kg-header-card h3 strong {
        font-weight: 600;
    }

    .kg-header-card.kg-size-small h3 {
        font-size: 1em;
    }

    .kg-header-card.kg-size-large h3 {
        font-size: 1.5em;
    }

    .kg-header-card:not(.kg-style-light) h2,
    .kg-header-card:not(.kg-style-light) h3 {
        color: #ffffff;
    }

    .kg-header-card a.kg-header-card-button {
        display: flex;
        position: static;
        align-items: center;
        padding: 0 1.2em;
        height: 2.4em;
        line-height: 1em;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", "Oxygen", "Ubuntu", "Cantarell", "Fira Sans", "Droid Sans", "Helvetica Neue", sans-serif;
        font-size: 0.95em;
        font-weight: 600;
        text-decoration: none;
        border-radius: 5px;
        transition: opacity 0.2s ease-in-out;
        background-color: var(--ghost-accent-color);
        color: #ffffff;
        margin: 1.75em 0 0;
    }

    .kg-header-card a.kg-header-card-button:hover {
        opacity: 0.85;
    }

    .kg-header-card.kg-size-large a.kg-header-card-button {
        margin-top: 2em;
    }

    .kg-header-card.kg-size-small a.kg-header-card-button {
        margin-top: 1.5em;
    }

    .kg-header-card.kg-style-image a.kg-header-card-button,
    .kg-header-card.kg-style-dark a.kg-header-card-button {
        background: #ffffff;
        color: #15171a;
    }

    .kg-header-card.kg-style-accent a.kg-header-card-button {
        background: #ffffff;
        color: var(--ghost-accent-color);
    }

    .kg-audio-card {
        display: flex;
        width: 100%;
        box-shadow: inset 0 0 0 1px rgba(124, 139, 154, 0.25);
    }

    .kg-audio-thumbnail {
        display: flex;
        justify-content: center;
        align-items: center;
        width: 80px;
        min-width: 80px;
        height: 80px;
        background: transparent;
        object-fit: cover;
        aspect-ratio: 1/1;
        border-radius: 3px 0 0 3px;
    }

    .kg-audio-thumbnail.placeholder {
        background: var(--ghost-accent-color);
    }

    .kg-audio-thumbnail.placeholder svg {
        width: 24px;
        height: 24px;
        fill: white;
    }

    .kg-audio-player-container {
        position: relative;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        width: 100%;
        --seek-before-width: 0%;
        --volume-before-width: 100%;
        --buffered-width: 0%;
    }

    .kg-audio-title {
        width: 100%;
        padding: 8px 12px 0;
        border: none;
        font-family: inherit;
        font-size: 1.1em;
        font-weight: 700;
        background: transparent;
    }

    .kg-audio-player {
        display: none;
    }

    .kg-width-full.kg-card-hascaption {
        display: grid;
        grid-template-columns: inherit;
    }

    .post-content table {
        border-collapse: collapse;
        width: 100%;
    }

    .post-content th {
        padding: 0.5em 0.8em;
        text-align: left;
        font-size: .75em;
        text-transform: uppercase;
    }

    .post-content td {
        padding: 0.4em 0.7em;
    }

    .post-content tbody tr:nth-child(2n + 1) {
        background-color: rgba(0,0,0,0.1);
        padding: 1px;
    }

    .post-content tbody tr:nth-child(2n + 2) td:last-child {
        box-shadow:
            inset 1px 0 rgba(0,0,0,0.1),
            inset -1px 0 rgba(0,0,0,0.1);
    }

    .post-content tbody tr:nth-child(2n + 2) td {
        box-shadow: inset 1px 0 rgba(0,0,0,0.1);
    }

    .post-content tbody tr:last-child {
        border-bottom: 1px solid rgba(0,0,0,.1);
    }

    .page-footer {
        padding: 60px 5vmin;
        margin: 60px auto 0;
        text-align: center;
        background-color: #f8f8f8;
    }

    .page-footer h3 {
        margin: 0.5rem 0 0 0;
    }

    .page-footer p {
        max-width: 500px;
        margin: 1rem auto 1.5rem;
        font-size: 1.7rem;
        line-height: 1.5em;
        color: rgba(0,0,0,0.6)
    }

    .powered {
        display: inline-flex;
        align-items: center;
        margin: 30px 0 0;
        padding: 6px 9px 6px 6px;
        border: rgba(0,0,0,0.1) 1px solid;
        font-size: 12px;
        line-height: 12px;
        letter-spacing: -0.2px;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", "Oxygen", "Ubuntu", "Cantarell", "Fira Sans", "Droid Sans", "Helvetica Neue", sans-serif;
        font-weight: 500;
        color: #222;
        text-decoration: none;
        background: #fff;
        border-radius: 6px;
    }

    .powered svg {
        height: 16px;
        width: 16px;
        margin: 0 6px 0 0;
    }

    @media (max-width: 600px) {
        body {
            font-size: 1.6rem;
        }
        h1 {
            font-size: 3rem;
        }

        h2 {
            font-size: 2.2rem;
        }
    }

    @media (max-width: 400px) {
        h1 {
            font-size: 2.6rem;
            line-height: 1.15em;
        }
        h2 {
            font-size: 2rem;
            line-height: 1.2em;
        }
        h3 {
            font-size: 1.7rem;
        }
    }

    :root {--ghost-accent-color: #15171A;}
    </style>

    <style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style><noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript>
    <script async src="https://cdn.ampproject.org/v0.js"></script>

    

</head>

<body class="amp-template">
    <header class="page-header">
        <a href="../../index.html">
                <amp-img class="site-icon" src="yourdomain.com/content/images/2021/07/ghost-orb.png" width="50" height="50" layout="fixed" alt="zairesinatra"></amp-img>
        </a>
    </header>

    <main class="content" role="main">
        <article class="post">

            <header class="post-header">
                <h1 class="post-title">SpringMVC</h1>
                <section class="post-meta">
                    Ziyi Xie -
                    <time class="post-date" datetime="2020-06-06">06 Jun 2020</time>
                </section>
            </header>
            <figure class="post-image">
                <amp-img src="yourdomain.com/content/images/2022/06/coffeeBeans.jpg" width="600" height="340" layout="responsive" 
                alt="coffee beans"
                ></amp-img>
            </figure>
            <section class="post-content">

                <h2 id="%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B">快速上手</h2>
<p>MVC 是一种架构思想，将软件按照模型、视图、控制器来划分。用作处理数据的 JavaBean 可看作模型层；与用户进行交互，展示数据的前端页面即视图层；接收请求和响应浏览器的 servlet 是控制层。</p>
<p>用户通过视图层发送请求到服务器，在服务器中请求被 controller 接收，并调用相应的 Model 层处理请求，处理完毕将结果返回到 Controller，Controller 再根据请求处理的结果找到相应的 View 视图，渲染数据后最终响应给浏览器。</p>
<p>SpringMVC 是为表述层，即前端和后台 Servlet，提供的一整套完备的解决方案。</p>
<h3 id="helloworld">HelloWorld</h3>
<p>前端控制器 DispatcherServlet 会处理符合 &lt;servlet-mapping&gt; 中 url-pattern 属性的请求，&lt;servlet-mapping&gt; 的作用是根据具体的 url 通知容器选择具体 Servlet。</p>
<p>前端控制器读取 springMVC 配置文件后，会通过扫描组件的方式搜寻控制器，并将请求地址和控制器中 <code>@RequestMapping</code> 注解的 value 属性值进行匹配。</p>
<p>若匹配成功，该注解所标识的控制器方法就是处理请求的方法。请求处理方法需返回一个字符串，该字符串作为视图名称被视图解析器解析，加上前缀和后缀组成视图的路径，通过 Thymeleaf 对视图进行渲染，最终<strong>转发</strong>到视图所对应页面。</p>
<ul>
<li>Maven 的传递性</li>
</ul>
<p>无需将所有需要的包全部配置依赖，而是配置最顶端的依赖，其他靠传递性导入。</p>
<pre><code class="language-xml">&lt;dependencies&gt;
    &lt;!-- SpringMVC --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
        &lt;version&gt;5.3.1&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- 日志 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
        &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;
        &lt;version&gt;1.2.3&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- ServletAPI --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
        &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
        &lt;version&gt;3.1.0&lt;/version&gt;
        &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;!-- Spring5和Thymeleaf整合包 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt;
        &lt;artifactId&gt;thymeleaf-spring5&lt;/artifactId&gt;
        &lt;version&gt;3.0.12.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<ul>
<li>配置 web.xml</li>
</ul>
<p>配置文件 &lt;servlet-name&gt;-servlet.xml 默认位于 WEB-INF 下，实际开发中通常将其放置于 resources 目录。</p>
<pre><code class="language-xml">&lt;!-- web.xml --&gt;
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0"&gt;
    &lt;!-- 配置springmvc的前端控制器,对浏览器发送的请求统一处理 --&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;!-- 配置SpringMVC配置文件的位置和名称 --&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;classpath:springMVC.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;!--servlet初始化默认在访问时初始化 =&gt; 影响访问速度--&gt;
        &lt;!--dispatcherServlet初始化时间提前到服务器启动时--&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;
        &lt;!-- /表示浏览器发送的所有请求,但是不包括jsp后缀 --&gt;
        &lt;!-- 不匹配 jsp 原因是其本质就是一个 servlet,需要服务器指定的 servlet 进行处理;就算能接收 jsp,那么也会当成普通请求处理,也不会找到其对应的 jsp 页面 --&gt;
        &lt;!-- /* 是表示所有请求,包括jsp --&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
&lt;/web-app&gt;
</code></pre>
<ul>
<li>controller</li>
</ul>
<p>RequestDispatcher 接口提供将请求转发送到另一资源的功能，即 html、servlet 或 jsp 等。从路由到控制器的方法需通过 <code>@RequestMapping</code> 指定请求与处理方法之间的映射。</p>
<pre><code class="language-java">// com.xxx.controller.HelloController
@Controller // 标识为控制层组件 =&gt; Controller控制层组件、Service 业务层组件、Component 普通组件、repository 持久层组件
// 注解加扫描才能作为 Bean 进行管理
public class HelloController {
    // SpringMVC还有视图解析器 =&gt; 负责页面跳转
    // / =&gt; /WEB-INF/template/index.html
    // 控制器方法是处理请求的方法
    @RequestMapping(value="/") // 请求映射注解 =&gt; 请求与方法创建控制器关系
    public String index(){
        // 返回视图名称 =&gt; 决定最终跳转的页面
        return "index";
    }
    @RequestMapping(value = "/target")
    public String toTarget(){
        return "target";
    }
}
</code></pre>
<ul>
<li>springMVC.xml</li>
</ul>
<pre><code class="language-xml">&lt;!-- springMVC.xml --&gt;
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd"&gt;
    &lt;!-- 扫描组件 --&gt;
    &lt;context:component-scan base-package="com.zszy.mvc.controller"&gt;&lt;/context:component-scan&gt;
    &lt;!-- 配置Thymeleaf视图解析器 --&gt;
    &lt;!-- 每当实现页面跳转时,若视图名称是符合条件的话,会被视图解析器解析,指派相对应的页面跳转 --&gt;
    &lt;bean id="viewResolver" class="org.thymeleaf.spring5.view.ThymeleafViewResolver"&gt;
        &lt;property name="order" value="1"/&gt;
        &lt;property name="characterEncoding" value="UTF-8"/&gt;
        &lt;property name="templateEngine"&gt;
            &lt;bean class="org.thymeleaf.spring5.SpringTemplateEngine"&gt;
                &lt;property name="templateResolver"&gt;
                    &lt;bean class="org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver"&gt;
                        &lt;!-- 视图前缀 --&gt;
                        &lt;property name="prefix" value="/WEB-INF/templates/"/&gt;
                        &lt;!-- 视图后缀 --&gt;
                        &lt;property name="suffix" value=".html"/&gt;
                        &lt;property name="templateMode" value="HTML5"/&gt;
                        &lt;property name="characterEncoding" value="UTF-8" /&gt;
                    &lt;/bean&gt;
                &lt;/property&gt;
            &lt;/bean&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<ul>
<li>视图层页面</li>
</ul>
<pre><code class="language-html">&lt;!-- index.html --&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;index&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;index page&lt;/h1&gt;
    &lt;!-- 解决浏览器解析的绝对路径 --&gt;
    &lt;a th:href="@{/target}"&gt;target page&lt;/a&gt;
&lt;/body&gt;
&lt;/html&gt;
&lt;!-- index.html --&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;target&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    hello target
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="requestmapping-%E6%B3%A8%E8%A7%A3">@RequestMapping 注解</h3>
<p>见名知意，@RequestMapping 将请求和处理请求的控制器方法进行关联映射。</p>
<ul>
<li>@RequestMapping 注解位置</li>
</ul>
<p><code>@RequestMapping</code> 注解标识一个类 =&gt; 设置映射请求路径的初始信息<br />
<code>@RequestMapping</code> 注解标识一个方法 =&gt; 设置映射请求路径的具体信息</p>
<ul>
<li>@RequestMapping 注解的 value 属性</li>
</ul>
<p><strong>必须设置</strong>的 value 属性通过请求的请求地址匹配请求映射，其值是一个字符串类型的<strong>数组</strong>，表示该请求映射能够匹配多个请求地址所对应的请求。</p>
<ul>
<li>@RequestMapping 注解的 method 属性</li>
</ul>
<p>通过请求方式匹配请求映射的 method 属性，其值是一个 <code>RequestMethod.??</code> 类型的数组，表示该请求映射能够匹配多种请求方式的请求。</p>
<p>若当前请求的请求地址满足请求映射的 value 属性，但请求方式不满足 method 属性，浏览器会报出 405 的错误 =&gt; <code>Request method 'POST' not supported</code>。</p>
<ul>
<li>@RequestMapping 注解的 params 属性</li>
</ul>
<p>params 属性通过请求参数匹配请求映射，其值是一个字符串类型的数组，可通过表达式形式设置请求参数和请求映射的匹配关系。</p>
<pre><code>param =&gt; 要求请求映射所匹配的请求必须携带param请求参数
!param =&gt; 要求请求映射所匹配的请求必须不能携带param请求参数
param=value =&gt; 要求请求映射所匹配的请求必须携带param请求参数且param=value
param!=value =&gt; 要求请求映射所匹配的请求必须携带param请求参数但是param!=value
</code></pre>
<ul>
<li>@RequestMapping 注解的 headers 属性</li>
</ul>
<p>headers 属性通过请求头信息匹配请求映射，其属性是一个字符串类型的数组，也可通过表达式设置请求头信息和请求映射的匹配关系。</p>
<pre><code>header =&gt; 要求请求映射所匹配的请求必须携带header请求头信息
!header =&gt; 要求请求映射所匹配的请求必须不能携带header请求头信息
header=value =&gt; 要求请求映射所匹配的请求必须携带header请求头信息且header=value
header!=value =&gt; 要求请求映射所匹配的请求必须携带header请求头信息且header!=value
</code></pre>
<p>若请求满足 value 和 method 属性，但不满足 headers 属性，此时页面显示 404 错误，即资源未找到。</p>
<ul>
<li>ant 风格路径（模糊匹配风格）</li>
</ul>
<pre><code>设置 requestmapping 中的 value 属性
？ =&gt; 表示任意的单个字符
* =&gt; 表示任意的0个或多个字符
/** =&gt; 表示任意的一层或多层目录 // 注意 =&gt; 在使用 /** 时，只能使用 /**/xxx 的方式
</code></pre>
<ul>
<li>路径占位符（重点）</li>
</ul>
<p>SpringMVC 路径中的占位符常用于 RESTful 风格中，当请求路径中将某些数据通过路径的方式传输到服务器中，就可以在相应的 @RequestMapping 注解的 value 属性中通过占位符 {xxx} 表示传输的数据，在通过 @PathVariable 注解，将占位符所表示的数据赋值给控制器方法的形参。</p>
<pre><code>原始方式 =&gt; /deleteUser?id=1
rest方式 =&gt; /deleteUser/1
</code></pre>
<pre><code class="language-java">@Controller
//@RequestMapping("/hello") // 加在类上用于不同模块控制器设置
public class RequestMappingController {
    @RequestMapping( // 不设置Method属性就是不以请求方式为条件,get、post都可以
            value={"/testRequestMapping","/test"}, // 处理多个请求
            method = {RequestMethod.GET,RequestMethod.POST}
    )
    public String success(){
        return "success";
    }
    @GetMapping("/testGetMapping") // 派生注解
    public String testgetMapping(){
        return "success";
    }
    @RequestMapping(value = "/testPut", method = RequestMethod.PUT)
    public String testPut(){
        return "success";
    }
    @RequestMapping(value = "/testParamsAndHeaders",params={"username","password!=123"},headers = {"Host=localhost:8080"})
    public String testParamsAndHeaders(){
        return "success";
    }
    @RequestMapping("/a?a/testAnt")
    public String testAnt(){
        return "success";
    }
    @RequestMapping("/testPath/{id}")
    public String testPath(@PathVariable("id") Integer id){ // 修饰房钱形参注解
        System.out.println(id);
        return "success";
    }
}
</code></pre>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Index&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;首页&lt;/h1&gt;
&lt;a th:href="@{/hello/testRequestMapping}"&gt;测试testRequestMapping注解位置&lt;/a&gt;&lt;br&gt;
&lt;a th:href="@{/test}"&gt;测试testRequestMapping注解value属性 =&gt; test&lt;/a&gt;&lt;br&gt;
&lt;a th:href="@{/testRequestMapping}"&gt;测试testRequestMapping注解value属性 =&gt; testRequestMapping&lt;/a&gt;&lt;br&gt;
&lt;a th:href="@{/testRequestMapping}"&gt;测试testRequestMapping注解Method属性 =&gt; Get&lt;/a&gt;&lt;br&gt;
&lt;form th:action="@{/test}" method="post"&gt;
    &lt;input type="submit" value="测试testRequestMapping注解的Method属性 =&gt; post"&gt;
&lt;/form&gt;
&lt;a th:href="@{/testGetMapping}"&gt;测试GetMapping注解 =&gt; /testGetMapping&lt;/a&gt;&lt;br&gt;
&lt;!--form若请求方式非get、post一律按get请求算--&gt;
&lt;form th:action="@{/testPut}" method="put"&gt;
    &lt;input type="submit" value="测试form表单能否发送put或delete请求 =&gt; put"&gt;
&lt;/form&gt;
&lt;!-- 属性想要给thymeleaf解析加上th --&gt;
&lt;!--&lt;a th:href="@{/testParamsAndHeaders?username=admin}"&gt;测试RequestMapping注解的mparams属性 =&gt; /testparamsAndheaders&lt;/a&gt;--&gt;
&lt;a th:href="@{/testParamsAndHeaders(username='admin',password=12345)}"&gt;测试RequestMapping注解的mparams属性 =&gt; /testparamsAndheaders&lt;/a&gt;&lt;br&gt;
&lt;a th:href="@{/aaa/testAnt}"&gt;测试requestMapping注解的ant风格 =&gt; /testAnt&lt;/a&gt;
&lt;a th:href="@{/testPath/1}"&gt;测试requestMapping注解支持路径中的占位符 =&gt; /testPath&lt;/a&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="language-xml">&lt;!-- web.xml 配置解决中文乱码 --&gt;
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app ...&gt;
    &lt;!--配置springMVC的编码过滤器--&gt;
    &lt;filter&gt;
        &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;
        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
        &lt;init-param&gt;
            &lt;!-- 设置请求编码 --&gt;
            &lt;param-name&gt;encoding&lt;/param-name&gt;
            &lt;param-value&gt;UTF-8&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;init-param&gt;
            &lt;!-- 设置响应编码 =&gt; 这里可以不写,但是建议写上 --&gt;
            &lt;param-name&gt;forceResponseEncoding&lt;/param-name&gt;
            &lt;param-value&gt;true&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
    &lt;!-- 注册前端控制器 --&gt;
    ...
&lt;/web-app&gt;
</code></pre>
<h2 id="%E8%8E%B7%E5%8F%96%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0">获取请求参数</h2>
<p>在能匹配到请求的基础上，就能通过 SpringMVC 获取参数，并在控制器方法中处理请求。dispatcherServlet 底层中调用的控制器方法，会根据当前控制器方法的形参，注入不同类型的值。</p>
<h3 id="%E9%80%9A%E8%BF%87%E5%8E%9F%E7%94%9F-servletapi-%E8%8E%B7%E5%8F%96">通过原生 ServletAPI 获取</h3>
<p>将 HttpServletRequest 作为控制器方法的形参，此时 HttpServletRequest 类型的参数表示封装了当前请求的请求报文的对象。</p>
<h3 id="%E6%8E%A7%E5%88%B6%E5%99%A8%E6%96%B9%E6%B3%95%E7%9A%84%E5%BD%A2%E5%8F%82%E8%8E%B7%E5%8F%96%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0">控制器方法的形参获取请求参数</h3>
<p>在控制器方法的形参位置，设置和请求参数同名的形参，当浏览器发送请求，匹配到请求映射时，在 DispatcherServlet 中就会将请求参数赋值给相应的形参。</p>
<p>若请求所传输的请求参数中有多个同名的请求参数，可在控制器方法的形参中设置字符串数组或者字符串类型的形参接收此请求参数。前者类型的形参数组中包含了每一个数据，后者参数的值为每个数据中间使用逗号拼接的结果。</p>
<h3 id="%E9%80%9A%E8%BF%87%E6%B3%A8%E8%A7%A3%E8%8E%B7%E5%8F%96">通过注解获取</h3>
<ul>
<li>@RequestParam</li>
</ul>
<p>@RequestParam 将请求参数和控制器方法的形参创建映射关系，其中属性 value 指定为形参赋值的请求参数的参数名。</p>
<p>属性 required 设置是否必须传输此请求参数，默认值为 true，即要求请求必须传输。当没有传输该请求参数，且未设置 defaultValue 属性时，页面会出现 400 报错，即 <code>Required String parameter 'xxx' is not present</code>。</p>
<p>属性 defaultValue 不管 required 属性值为 true 或 false，当 value 所指定的请求参数没有传输或传输的值为 "" 时，使用默认值为形参赋值。</p>
<ul>
<li>@RequestHeader</li>
</ul>
<p>@RequestHeader 将请求头信息和控制器方法的形参创建映射关系。此注解的属性和用法同 @RequestParam。</p>
<ul>
<li>@CookieValue</li>
</ul>
<p>在首次执行 <code>getSession()</code> 方法时，JSESSIONID 的 Cookie 会存在于响应报文中，经此之后存在于请求报文。</p>
<p>@CookieValue 将 cookie 数据和控制器方法的形参创建映射关系。此注解的属性和用法同 @RequestParam。</p>
<h3 id="%E9%80%9A%E8%BF%87-pojo-%E8%8E%B7%E5%8F%96">通过 POJO 获取</h3>
<p>在控制器方法的形参位置设置一个实体类类型的形参，若浏览器传输的请求参数的参数名和实体类中的属性名一致，那么请求参数就会为此属性赋值。</p>
<h3 id="%E6%80%BB%E7%BB%93%E4%BB%A3%E7%A0%81">总结代码</h3>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;testparams&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;testparams&lt;/h1&gt;
&lt;a th:href="@{/testServletAPI(username='admin',password=12345)}"&gt;测试使用ServletAPI获取请求参数&lt;/a&gt;
&lt;a th:href="@{/testParam(username='admin',password=12345)}"&gt;测试使用控制器的形参获取请求参数&lt;/a&gt;
&lt;form th:action="@{/testParam}" method="post"&gt;
    用户名：&lt;input type="text" name="user_name"&gt;&lt;br&gt;
    密码：&lt;input type="password" name="password"&gt;&lt;br&gt;
    补充：&lt;input type="checkbox" name="hobby" value="a"&gt;a
    &lt;input type="checkbox" name="hobby" value="b"&gt;b
    &lt;input type="checkbox" name="hobby" value="c"&gt;c&lt;br&gt;
    &lt;input type="submit" value="测试使用控制器的形参获取请求参数"&gt;
&lt;/form&gt;
&lt;form th:action="@{/testBean}" method="post"&gt;
    用户名：&lt;input type="text" name="username"&gt;&lt;br&gt;
    密码：&lt;input type="password" name="password"&gt;&lt;br&gt;
    性别：&lt;input type="radio" name="sex" value="男"&gt;男&lt;input type="radio" name="sex" value="女"&gt;女&lt;br&gt;
    年龄：&lt;input type="text" name="age"&gt;&lt;br&gt;
    邮箱：&lt;input type="text" name="email"&gt;&lt;br&gt;
    &lt;input type="submit" value="使用pojo实体类接收请求参数"&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="language-java">@Controller
public class ParamController {
    @RequestMapping("/testServletAPI")
    // 原生 servlet 获取请求参数
    // 在控制器方法中如果写了 request 对象类型的参数,那么这个参数就是表示当前的请求!
    public String testServletAPI(HttpServletRequest req){ // 这个方法是dispathcerServlet调用
        HttpSession session = req.getSession();
        String username = req.getParameter("username");
        String password = req.getParameter("password");
        System.out.println("username: "+ username+", password "+ password);
        return "success";
    }
    // springmvc 获取请求参数
    @RequestMapping("/testParam")
    public String testParam(
            // 通过注解解决请求参数与形参名不相同的问题 =&gt; 前后端不是你改就是我改lol =&gt; 第二个属性表示是否传输所对应的请求参数 =&gt; 第三个参数在开发中使用最多
            @RequestParam(value="user_name",required=false,defaultValue = "defaultvalue") String username, // @RequestParam将请求参数与形参创建映射关系
            String password,
            String[] hobby,
            @RequestHeader(value="Host",required=false,defaultValue = "defaultvalue") String host,
            @CookieValue("JSESSIONID") String JSESSIONID){ // 保证当前控制器方法的形参和当前的请求参数名相同即可自动赋值
        // 多请求参数中出现多个同名的请求参数可以使用 String 或者 String[] 接收.
        // 若使用字符串类型的形参,最终结果为请求参数的每一个值之间使用逗号进行拼接的结果.
        System.out.println("username: "+ username+", password "+ password + ", hobby "+ Arrays.toString(hobby));
        System.out.println("host: "+ host);
        System.out.println("JSESSIONID: "+ JSESSIONID);
        return "success";
        // 若传递多个同名的请求参数
    }
    @RequestMapping("/testBean")
    public String testBean(User user){
        System.out.println(user);
        return "success";
    }
}
</code></pre>
<h2 id="%E5%9F%9F%E5%AF%B9%E8%B1%A1%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE">域对象共享数据</h2>
<p>在能获取请求参数的情况下，下一步处理请求的过程应该是将请求参数作为条件去调用 service 的业务逻辑，service 业务逻辑又会调用 dao 操作数据库，最后再将结果通过返回给业务层传递到控制层。该过程中若有数据发往页面，那么应将这些数据在域对象中进行共享。</p>
<p>请求域 request、会话域 session、应用域 servletcontext 组成的域对象里，后者使用频率远小于前两者，原因是范围太大而较少有使用的必要。数据一直处于变化的状态，故在选择域对象的时候，要选择能实现功能且范围最小的域。开发中所常见的查询列表、表单回显数据都会放在会请求域，当然放在更大的域中也是可行的。</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;index&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;index page&lt;/h1&gt;
    &lt;a th:href="@{/testRequestByServletAPI}"&gt;通过servletAPI向域共享数据&lt;/a&gt;&lt;br&gt;
    &lt;a th:href="@{/testModelAndView}"&gt;通过ModelAndView向域共享数据&lt;/a&gt;&lt;br&gt;
    &lt;a th:href="@{/testModel}"&gt;通过Model向域共享数据&lt;/a&gt;&lt;br&gt;
    &lt;a th:href="@{/testMap}"&gt;通过Map向域共享数据&lt;/a&gt;&lt;br&gt;
    &lt;a th:href="@{/testModelMap}"&gt;通过Map向域共享数据&lt;/a&gt;&lt;br&gt;
    &lt;a th:href="@{/testSession}"&gt;通过原生 servletAPI HttpSession向session域共享数据&lt;/a&gt;&lt;br&gt;
    &lt;a th:href="@{/testApplication}"&gt;通过原生 servletAPI 向Application域共享数据&lt;/a&gt;&lt;br&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="%E5%90%91-request-%E5%9F%9F%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE">向 request 域共享数据</h3>
<ul>
<li>ServletAPI 向 request 域对象共享数据</li>
</ul>
<pre><code class="language-java">/* ScopeController */
@Controller
public class ScopeController {
    // 使用servletAPI 向 request 域对象共享数据
    @RequestMapping("/testRequestByServletAPI")
    public String testRequestByServletAPI(HttpServletRequest req){
        // 原生方法
        req.setAttribute("testRequestScope","hello,servletAPI");
        return "success"; // 转发 =&gt; webINF下的资源重定向访问不了的 =&gt; 就是转发
    }
}
</code></pre>
<ul>
<li>ModelAndView 向 request 域对象共享数据</li>
</ul>
<pre><code class="language-java">/* ScopeController */
@Controller
public class ScopeController {
    // 使用 ModelAndView 向 request 域对象共享数据
    @RequestMapping("/testModelAndView")
    public ModelAndView testModelAndView(){ // 返回值必须是ModelAndView
        ModelAndView mav = new ModelAndView();
        // 处理模型数据,向请求域共享数据
        mav.addObject("testRequestScope","hello ModelAndView");
        // 设置视图名称 =&gt; 相当于返回的字符串
        mav.setViewName("success");
        return mav; // ModelAndView 实例必作为该方法的返回值返回
    }
}
</code></pre>
<ul>
<li>Model 向 request 域对象共享数据</li>
</ul>
<pre><code class="language-java">/* ScopeController */
@Controller
public class ScopeController {
    // Model 向 request 域对象共享数据
    @RequestMapping("/testModel")
    public String testModel(Model model){
        model.addAttribute("testRequestScope","hello model");
        System.out.println(model.getClass().getName()); // 全类名 =&gt; BindingAwareModelMap
        return "success";
    }
}
</code></pre>
<ul>
<li>map 向 request 域对象共享数据</li>
</ul>
<pre><code class="language-java">/* ScopeController */
@Controller
public class ScopeController {
    // 使用 map 向 request 域对象共享数据
    @RequestMapping("/testMap")
    public String testMap(Map&lt;String, Object&gt; map){
        map.put("testRequestScope", "hello Map");
        System.out.println(map);
        return "success";
    }
}
</code></pre>
<ul>
<li>ModelMap 向 request 域对象共享数据</li>
</ul>
<pre><code class="language-java">/* ScopeController */
@Controller
public class ScopeController {
    // ModelMap 向 request 域对象共享数据
    @RequestMapping("/testModelMap")
    public String testModelMap(ModelMap modelMap){ // ModelMap是Map的实现类（继承自LinkedHashMap）
        // ModelMap继承自Map,同时addAttribute内部调用了put方法.
        modelMap.addAttribute("testRequestScope", "hello ModelMap");
        System.out.println(modelMap);
        return "success";
    }
}
</code></pre>
<ul>
<li>Model、ModelMap、Map的关系</li>
</ul>
<p>Model、ModelMap、Map 类型的参数其实本质上都是 BindingAwareModelMap 类型。总而言之，三者的实际实例化的全类名是 BindingAwareModelMap。</p>
<pre><code class="language-java">public interface Model{}
public class ModelMap extends LinkedHashMap&lt;String, Object&gt; {}
public class ExtendedModelMap extends ModelMap implements Model {}
public class BindingAwareModelMap extends ExtendedModelMap {}
xxx.getClass().getName() =&gt; BindingAwareModelMap
</code></pre>
<h3 id="%E5%90%91-session-%E5%9F%9F%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE">向 session 域共享数据</h3>
<ul>
<li>Session 的钝化与活化</li>
</ul>
<p>session 中的数据与服务器是否关闭无关，只和浏览器是否关闭有关。</p>
<p>session 的钝化 =&gt; 当服务器关闭，浏览器未关闭时，会话仍然继续，此时 session 中的数据会经过序列化存储到磁盘上。</p>
<p>session 的活化 =&gt; 若浏览器持续未关闭而服务器重新开启，此时会将钝化的文件内容重写读取入 session 中。</p>
<pre><code class="language-java">/* ScopeController */
@Controller
public class ScopeController {
    // 向 session 域共享数据
    @RequestMapping("/testSession")
    public String testSession(HttpSession session){
        session.setAttribute("testSessionScope", "hello session");
        return "success";
    }
}
</code></pre>
<h3 id="%E5%90%91-application-%E5%9F%9F%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE">向 application 域共享数据</h3>
<pre><code class="language-java">/* ScopeController */
@Controller
public class ScopeController {
    // 向 application 域共享数据
    @RequestMapping("/testApplication")
    public String testApplication(HttpSession session){
        ServletContext application = session.getServletContext();
        application.setAttribute("testApplicationScope", "hello application");
        return "success";
    }
}
</code></pre>
<h2 id="springmvc-%E7%9A%84%E8%A7%86%E5%9B%BE">SpringMVC 的视图</h2>
<p>SpringMVC 中的视图是 View 接口，用作渲染数据，将模型 Model 中的数据展示给用户，其种类默认有转发视图和重定向视图。</p>
<p>若工程引入 jstl 的依赖，转发视图会自动转换为 JstlView；若使用的视图技术为 Thymeleaf 并配置完成后，由此视图解析器解析所得是 ThymeleafView。</p>
<h3 id="thymeleafview">ThymeleafView</h3>
<p>当控制器方法中所设的视图名称无任何前缀时，该视图名称会被配置文件中的视图解析器解析，视图名称拼接视图前缀和视图后缀所得的最终路径，将通过转发的方式实现跳转。</p>
<h3 id="%E8%BD%AC%E5%8F%91%E8%A7%86%E5%9B%BE-internalresourceview">转发视图 InternalResourceView</h3>
<p>当控制器方法中所设视图名称以 <code>forward:</code> 为前缀，创建转发视图。此时视图名不会被配置文件所设视图解析器解析，而是将前缀 <code>forward:</code> 去掉，剩余部分作为最终路径以<u>转发</u>的方式实现跳转。</p>
<h3 id="%E9%87%8D%E5%AE%9A%E5%90%91%E8%A7%86%E5%9B%BE-redirectview">重定向视图 RedirectView</h3>
<p>当控制器方法中所设视图名称以 <code>redirect:</code> 为前缀，创建重定向视图，此时视图名不会被配置文件所设的视图解析器解析，而是将前缀 <code>redirect:</code> 去掉，剩余部分作为最终路径通过<u>重定向</u>的方式实现跳转</p>
<p>重定向视图在解析时，会先将 <code>redirect:</code> 前缀去掉，然后判断剩余部分是否以 <code>/</code> 开头，是则自动拼接上下文路径。</p>
<pre><code class="language-java">@Controller
public class ViewController {
    @RequestMapping("/testThymeleafView")
    public String testThymeleafView(){
        return "success";
    }
    @RequestMapping("/testForward")
    public String testForward(){
        return "forward:/testThymeleafView";
    }
    @RequestMapping("/testRedirect")
    public String testRedirect(){
        return "redirect:/testThymeleafView";
    }
}
</code></pre>
<h3 id="%E8%A7%86%E5%9B%BE%E6%8E%A7%E5%88%B6%E5%99%A8-view-controller">视图控制器 view-controller</h3>
<p>控制器方法<u>仅用来实现页面跳转</u>，那么只需要设置视图名称，可将处理器方法以 view-controller 标签进行表示。</p>
<p>设置任何一个 view-controller 时，其他控制器中的请求映射将全部失效，此时需要在核心配置文件中设置开启 mvc 注解驱动的标签 &lt;mvc:annotation-driven /&gt;。</p>
<pre><code class="language-xml">&lt;!-- springMVC.xml --&gt;
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:mvc="http://www.springframework.org/schema/mvc"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd"&gt;
    &lt;!-- 扫描组件--&gt;
    &lt;context:component-scan base-package="com.zszy.mvc.controller"&gt;&lt;/context:component-scan&gt;
    &lt;!-- 配置视图解析器 --&gt;
    &lt;!-- 配置Thymeleaf视图解析器 --&gt;
    &lt;bean id="viewResolver" class="org.thymeleaf.spring5.view.ThymeleafViewResolver"&gt;
        &lt;property name="order" value="1"/&gt;
        &lt;property name="characterEncoding" value="UTF-8"/&gt;
        &lt;property name="templateEngine"&gt;
            &lt;bean class="org.thymeleaf.spring5.SpringTemplateEngine"&gt;
                &lt;property name="templateResolver"&gt;
                    &lt;bean class="org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver"&gt;
                        &lt;!-- 视图前缀 --&gt;
                        &lt;property name="prefix" value="/WEB-INF/templates/"/&gt;
                        &lt;!-- 视图后缀 --&gt;
                        &lt;property name="suffix" value=".html"/&gt;
                        &lt;property name="templateMode" value="HTML5"/&gt;
                        &lt;property name="characterEncoding" value="UTF-8" /&gt;
                    &lt;/bean&gt;
                &lt;/property&gt;
            &lt;/bean&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
    &lt;!-- 当前控制器方法没有其他请求处理过程,那么可以设置视图名称|红色但是不影响 --&gt;
    &lt;!-- 若只在springMVC配置文件中设置viewcontroller,那么请求控制器中映射全部失效 =&gt; 必须开启mvc注解驱动 --&gt;
    &lt;mvc:view-controller path="/" view-name="index"&gt;&lt;/mvc:view-controller&gt;
    &lt;mvc:view-controller path="/test_rest" view-name="test_rest"&gt;&lt;/mvc:view-controller&gt;
    &lt;!-- 开启MVC的注解驱动 =&gt; 使得其他请求控制器中映射恢复 --&gt;
    &lt;mvc:annotation-driven /&gt;
&lt;/beans&gt;
</code></pre>
<h2 id="restful-%E8%A1%A8%E7%8E%B0%E5%B1%82%E8%B5%84%E6%BA%90%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB">RESTful 表现层资源状态转移</h2>
<p>REST 风格提倡 url 地址的使用统一，从前到后各个单词使用斜杠分开作为地址的一部分，不使用问号键值对方式携带请求参数。</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>传统方式</th>
<th>REST风格</th>
</tr>
</thead>
<tbody>
<tr>
<td>查询操作</td>
<td>getUserById?id=1</td>
<td>user/1--&gt;get请求方式</td>
</tr>
<tr>
<td>保存操作</td>
<td>saveUser</td>
<td>user--&gt;post请求方式</td>
</tr>
<tr>
<td>删除操作</td>
<td>deleteUser?id=1</td>
<td>user/1--&gt;delete请求方式</td>
</tr>
<tr>
<td>更新操作</td>
<td>updateUser</td>
<td>user--&gt;put请求方式</td>
</tr>
</tbody>
</table>
<h3 id="hiddenhttpmethodfilter">HiddenHttpMethodFilter</h3>
<p>SpringMVC 提供 HiddenHttpMethodFilter 帮助将 POST 请求转换为 DELETE 或 PUT 请求，以解决浏览器只支持发送 GET 和 POST 的请求方式。</p>
<ul>
<li>HiddenHttpMethodFilter 处理 put 和 delete 请求的条件</li>
</ul>
<p>当前请求的请求方式必须为 post；请求必须传输请求参数 _method。</p>
<p>当满足条件时，HiddenHttpMethodFilter 过滤器就会将当前请求的请求方式转换为请求参数 _method 的值，因此请求参数 _method 的值才是最终的请求方式。</p>
<ul>
<li>在 web.xml 中注册 HiddenHttpMethodFilter</li>
</ul>
<p>CharacterEncodingFilter 和 HiddenHttpMethodFilter 过滤器，在 web.xml 中注册时，必须先注册前者，再注册后者。</p>
<p>原因是前者通过 <code>request.setCharacterEncoding(encoding)</code> 设置字符集的方法要求在此前不能有任何获取请求参数的操作，而后者恰有一个获取请求参数（方式）的操作 <code>request.getParameter(this.methodParam)</code>。</p>
<pre><code class="language-xml">&lt;!-- web.xml --&gt;
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app ...&gt;
    &lt;!-- 多个过滤器是按照 filter-mapping 的顺序 --&gt;
    &lt;!-- 配置编码过滤器 =&gt; 设置编码之前不能获取任何的请求参数 --&gt;
    &lt;filter&gt;
        &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;
        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
        &lt;!-- 处理请求编码 --&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;encoding&lt;/param-name&gt;
            &lt;param-value&gt;UTF-8&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;!-- 处理响应编码 --&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;forceResponseEncoding&lt;/param-name&gt;
            &lt;param-value&gt;true&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
    &lt;!-- 配置 HiddenHttpMethodFilter 过滤器 --&gt;
    &lt;filter&gt;
        &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt;
        &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;

    &lt;!-- 配置springMVC前端控制器dispatcherServlet --&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;!-- 改变 dispatcher 默认位置和名称 --&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;classpath:springMVC.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;!-- 将servlet初始化时间提前到服务器启动时 --&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
&lt;/web-app&gt;
</code></pre>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;rest&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;a th:href="@{/user}"&gt;查询所有用户信息&lt;/a&gt;
    &lt;a th:href="@{/user/1}"&gt;根据id查询用户信息&lt;/a&gt;
    &lt;form th:action="@{/user}" method="post"&gt;
        用户名：&lt;input type="text" name="username"&gt;&lt;br&gt;
        密码：&lt;input type="password" name="password"&gt;&lt;br&gt;
        &lt;input type="submit" value="添加"&gt;&lt;br&gt;
    &lt;/form&gt;
    &lt;form th:action="@{/user}" method="POST"&gt;
        &lt;!-- 隐藏域 =&gt; 不让用户看见 --&gt;
        &lt;input type="hidden" name="_method" value="PUT"&gt;&lt;br&gt;
        用户名：&lt;input type="text" name="username"&gt;&lt;br&gt;
        密码：&lt;input type="password" name="password"&gt;&lt;br&gt;
        &lt;input type="submit" value="修改"&gt;&lt;br&gt;
    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="language-java">@Controller
public class UserController {
    // 使用restful模拟用户资源增删改查
    @RequestMapping(value="/user",method = RequestMethod.GET)
    public String getAllUser(){
        System.out.println("查询所有用户信息");
        return "success";
    }
    @RequestMapping(value="/user/{id}",method = RequestMethod.GET)
    public String getUserById(){
        System.out.println("根据id查询用户信息");
        return "success";
    }
    @RequestMapping(value="/user",method = RequestMethod.POST)
    public String insertUser(String username,String password){
        System.out.println("添加用户信息成功 =&gt; "+username+"-"+password);
        return "success";
    }
    @RequestMapping(value="/user",method = RequestMethod.PUT)
    public String updateUser(String username,String password){
        System.out.println("修改用户信息成功 =&gt; "+username+"-"+password);
        return "success";
    }
}
</code></pre>
<h2 id="httpmessageconverter">HttpMessageConverter</h2>
<p>HttpMessageConverter 报文信息转换器将请求报文转换为 Java 对象，或将 Java 对象转换为响应报文。</p>
<p>该类提供了两个注解和类型 @RequestBody、<u>@ResponseBody</u>、RequestEntity、<br />
<u>ResponseEntity</u>。Entity 作为实体表示整个报文。</p>
<pre><code class="language-xml">&lt;!-- web.xml --&gt;
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0"&gt;
    &lt;!-- 多个过滤器是按照 filter-mapping 的顺序 --&gt;
    &lt;!-- 配置编码过滤器 =&gt; 设置编码之前不能获取任何的请求参数 --&gt;
    &lt;filter&gt;
        &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;
        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
        &lt;!-- 处理请求编码 --&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;encoding&lt;/param-name&gt;
            &lt;param-value&gt;UTF-8&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;!-- 处理响应编码 --&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;forceResponseEncoding&lt;/param-name&gt;
            &lt;param-value&gt;true&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
    &lt;!-- 配置 HiddenHttpMethodFilter 过滤器 --&gt;
    &lt;filter&gt;
        &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt;
        &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;

    &lt;!-- 配置springMVC前端控制器dispatcherServlet --&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;!-- 改变 dispatcher 默认位置和名称 --&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;classpath:springMVC.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;!-- 将servlet初始化时间提前到服务器启动时 --&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
&lt;/web-app&gt;
</code></pre>
<pre><code class="language-xml">&lt;!-- springMVC.xml --&gt;
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:mvc="http://www.springframework.org/schema/mvc"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd"&gt;
    &lt;!-- 扫描组件--&gt;
    &lt;context:component-scan base-package="com.zszy.mvc.controller"&gt;&lt;/context:component-scan&gt;
    &lt;!-- 配置视图解析器 --&gt;
    &lt;!-- 配置Thymeleaf视图解析器 --&gt;
    &lt;bean id="viewResolver" class="org.thymeleaf.spring5.view.ThymeleafViewResolver"&gt;
        &lt;property name="order" value="1"/&gt;
        &lt;property name="characterEncoding" value="UTF-8"/&gt;
        &lt;property name="templateEngine"&gt;
            &lt;bean class="org.thymeleaf.spring5.SpringTemplateEngine"&gt;
                &lt;property name="templateResolver"&gt;
                    &lt;bean class="org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver"&gt;
                        &lt;!-- 视图前缀 --&gt;
                        &lt;property name="prefix" value="/WEB-INF/templates/"/&gt;
                        &lt;!-- 视图后缀 --&gt;
                        &lt;property name="suffix" value=".html"/&gt;
                        &lt;property name="templateMode" value="HTML5"/&gt;
                        &lt;property name="characterEncoding" value="UTF-8" /&gt;
                    &lt;/bean&gt;
                &lt;/property&gt;
            &lt;/bean&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
    &lt;mvc:view-controller path="/" view-name="index"&gt;&lt;/mvc:view-controller&gt;
    &lt;mvc:view-controller path="/file" view-name="file"&gt;&lt;/mvc:view-controller&gt;
    &lt;mvc:default-servlet-handler&gt;&lt;/mvc:default-servlet-handler&gt;
    &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;
    &lt;!-- 文件上传解析器 =&gt; 将上传的文件封装为 MutipartFile =&gt; 必须设置id,根据id获取 --&gt;
    &lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt;&lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="language-html">&lt;!-- index.html --&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;index&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;index&lt;/h1&gt;
    &lt;form th:action="@{/testRequestBody}" method="post"&gt;
        &lt;input type="text" name="username"&gt;
        &lt;input type="password" name="password"&gt;
        &lt;input type="submit" value="测试@RequestBody"&gt;
    &lt;/form&gt;
    &lt;form th:action="@{/testRequestEntity}" method="post"&gt;
        &lt;input type="text" name="username"&gt;
        &lt;input type="password" name="password"&gt;
        &lt;input type="submit" value="测试@RequestEntity"&gt;
    &lt;/form&gt;
    &lt;a th:href="@{/testResponse}"&gt;通过servletAPI的response对象响应浏览器数据&lt;/a&gt;
    &lt;a th:href="@{/testResponseBody}"&gt;通过@ResponseBody对象响应浏览器数据&lt;/a&gt;&lt;br&gt;
    &lt;a th:href="@{/testResponseUser}"&gt;通过@ResponseBody对象响应浏览器User对象&lt;/a&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="requestbody">@RequestBody</h3>
<p>获取请求体数据需要在控制器方法中设置一个形参，使用 @RequestBody 进行标识，当前请求的请求体就会为当前注解所标识的形参赋值。</p>
<pre><code class="language-java">/* com.zszy.mvc.controller */
@Controller
public class HttpController {
    @RequestMapping("/testRequestBody")
    public String testRequestBody(@RequestBody String requestBody){
        System.out.println(requestBody);
        return "success";
    }
}
</code></pre>
<h3 id="requestentity">RequestEntity</h3>
<p>获取请求报文数据需在控制器方法的形参中设置该类型的形参，当前请求报文就会赋值给该形参，可通过 <code>getHeaders()</code> 获取请求头信息，<code>getBody()</code> 获取请求体信息。</p>
<pre><code class="language-java">/* com.zszy.mvc.controller */
@Controller
public class HttpController {
    @RequestMapping("/testRequestEntity")
    public String testRequestEntity(RequestEntity&lt;String&gt; requestEntity){
        System.out.println("requestHeader:"+requestEntity.getHeaders());
        System.out.println("requestBody:"+requestEntity.getBody());
        return "success";
    }
}
</code></pre>
<h3 id="responsebody">@ResponseBody</h3>
<p>此注解标识的控制器方法可将方法的返回值直接作为响应报文的响应体响应到浏览器。</p>
<pre><code class="language-java">/* com.zszy.mvc.controller */
@Controller
public class HttpController {
    @RequestMapping("/testResponse")
    public void testResponse(HttpServletResponse response) throws IOException {
        response.getWriter().print("hello response");
    }
    @RequestMapping("/testResponseBody")
    @ResponseBody // 标识当前控制器方法 =&gt; 有 @ResponseBody 则作为响应的数据; 无 @ResponseBody 则作为视图名称
    public String testResponseBody(){
        return "success by zs";
    }
}
</code></pre>
<h3 id="springmvc-%E5%A4%84%E7%90%86-json">SpringMVC 处理 json</h3>
<ul>
<li>导入 jackson 依赖</li>
</ul>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
    &lt;version&gt;2.12.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<ul>
<li>在 SpringMVC 的核心配置文件中开启 mvc 的注解驱动</li>
</ul>
<pre><code class="language-xml">&lt;!-- 开启mvc注解驱动 --&gt;
&lt;!-- 简洁版 --&gt;
&lt;mvc:annotation-driven /&gt;
&lt;!-- 开发版 --&gt;
&lt;mvc:annotation-driven&gt;
    &lt;mvc:message-converters&gt;
        &lt;!-- 处理响应中文内容乱码 --&gt;
        &lt;bean class="org.springframework.http.converter.StringHttpMessageConverter"&gt;
            &lt;property name="defaultCharset" value="UTF-8" /&gt;
            &lt;property name="supportedMediaTypes"&gt;
                &lt;list&gt;
                    &lt;value&gt;text/html&lt;/value&gt;
                    &lt;value&gt;application/json&lt;/value&gt;
                &lt;/list&gt;
            &lt;/property&gt;
        &lt;/bean&gt;
    &lt;/mvc:message-converters&gt;
&lt;/mvc:annotation-driven&gt;
</code></pre>
<p>配置文件开启<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-servlet-config"> mvc 注解驱动</a>后，会在 HandlerAdaptor 中自动装配一个消息转换器 MappingJackson2HttpMessageConverter，此举可以将响应到浏览器的 Java 对象转换为 Json 格式的字符串。</p>
<ul>
<li>在处理器方法上使用 @ResponseBody 注解进行标识</li>
</ul>
<p>此时将 Java 对象直接作为控制器方法的返回值返回，就会自动转换为 Json 格式的字符串。</p>
<pre><code class="language-java">/* com.zszy.mvc.controller */
@Controller
public class HttpController {
    @RequestMapping("/testResponseUser")
    @ResponseBody
    public User testResponseUser(){ return new User(1001,"admin","12345",23,"male"); }
}
</code></pre>
<h3 id="springmvc-%E5%A4%84%E7%90%86-ajax">SpringMVC 处理 ajax</h3>
<ul>
<li>在前端页面追加超链接以及 vue 与 axios 处理的点击事件</li>
</ul>
<pre><code class="language-html">&lt;!-- index.html --&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;index&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;index&lt;/h1&gt;
    &lt;!-- ...追加上述 index.html --&gt;
    &lt;div id="app"&gt;
        &lt;a th:href="@{/testAxios}" @click="testAxios"&gt;testAxios&lt;/a&gt;&lt;br&gt;
    &lt;/div&gt;
    &lt;script type="text/javascript" th:src="@{/js/vue.js}"&gt;&lt;/script&gt;
    &lt;script type="text/javascript" th:src="@{/js/axios.min.js}"&gt;&lt;/script&gt;
    &lt;script type="text/javascript"&gt;
        var vue = new Vue({
            el:"#app",
            methods:{
                testAxios:function (event) {
                    axios({
                        method:"post",
                        url:event.target.href,
                        params:{
                            username:"admin",
                            password:"12345"
                        }
                    }).then(function (response) {
                        alert(response.data);
                    });
                    event.preventDefault();
                }
            }
        });
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="language-java">/* com.zszy.mvc.controller */
@Controller
public class HttpController {
    @RequestMapping("/testAxios")
    @ResponseBody
    public String testAxios(String username,String password){
        System.out.println(username+","+password);
        return "hello axios";
    }
}
</code></pre>
<h3 id="restcontroller%E6%B3%A8%E8%A7%A3">@RestController注解</h3>
<p>@RestController 是标识在控制器类上的复合注解，相当于为类添加 @Controller 注解，并且为其中的每个方法添加了 @ResponseBody 注解。</p>
<h3 id="responseentity">ResponseEntity</h3>
<p>ResponseEntity 用于控制器方法的返回值类型，该控制器方法的返回值就是响应到浏览器的响应报文。应用见下文的文件上传与下载。</p>
<h2 id="%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD">文件上传和下载</h2>
<h3 id="%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD">文件下载</h3>
<ul>
<li>使用 ResponseEntity 实现下载文件的功能</li>
</ul>
<pre><code class="language-java">/* FileUpAndDownController */
@Controller
public class FileUpAndDownController {
    @RequestMapping("/testDown")
    public ResponseEntity&lt;byte[]&gt; testResponseEntity(HttpSession session) throws IOException {
        // 获取ServletContext对象
        ServletContext servletContext = session.getServletContext();
        // 获取服务器中文件的真实路径
        String realPath = servletContext.getRealPath("/static/img/Neon80S.jpg");
        // 创建输入流
        InputStream is = new FileInputStream(realPath);
        //创建字节数组
        byte[] bytes = new byte[is.available()]; // 输入流所有字节数
        // 将流读到字节数组中
        is.read(bytes);
        // 创建HttpHeaders对象设置响应头信息
        MultiValueMap&lt;String, String&gt; headers = new HttpHeaders();
        //设置要下载方式以及下载文件的名字
        headers.add("Content-Disposition", "attachment;filename=Neon80S.jpg");
        // 设置响应状态码
        HttpStatus statusCode = HttpStatus.OK;
        //创建ResponseEntity对象
        ResponseEntity&lt;byte[]&gt; responseEntity = new ResponseEntity&lt;&gt;(bytes, headers, statusCode);
        // 关闭输入流
        is.close();
        return responseEntity;
    }
}
</code></pre>
<h3 id="%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0">文件上传</h3>
<p>文件上传要求表单请求方式必为 post，并添加属性 <code>enctype="multipart/form-data"</code>，SpringMVC 中将上传的文件封装到 MultipartFile 对象中，通过此对象可以获取文件相关信息。</p>
<ul>
<li>添加依赖</li>
</ul>
<pre><code class="language-xml">&lt;!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;
    &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;
    &lt;version&gt;1.3.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<ul>
<li>在 SpringMVC 的配置文件中添加配置</li>
</ul>
<pre><code class="language-xml">&lt;!-- 必须通过文件解析器的解析才能将文件转换为MultipartFile对象 --&gt;
&lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt;&lt;/bean&gt;
</code></pre>
<ul>
<li>实现上传文件的功能</li>
</ul>
<pre><code class="language-java">/* FileUpAndDownController */
@Controller
public class FileUpAndDownController {
    @RequestMapping("/testUp")
    public String testUp(MultipartFile photo, HttpSession session) throws IOException {
        // photo.getName 是获取表单上传设置的 name 属性值 photo
        // 获取上传的文件的文件名
        String fileName = photo.getOriginalFilename();
        // 处理文件重名问题 =&gt; UUID =&gt; 32位不重复随机序列
        String suffixName = fileName.substring(fileName.lastIndexOf("."));
        fileName = UUID.randomUUID().toString() + suffixName;
        // 获取服务器中photo目录的路径
        ServletContext servletContext = session.getServletContext();
        String photoPath = servletContext.getRealPath("photo");
        File file = new File(photoPath);
        if(!file.exists()){
            file.mkdir();
        }
        String finalPath = photoPath + File.separator + fileName;
        // 实现上传功能
        photo.transferTo(new File(finalPath));
        return "success";
    }
}
</code></pre>
<h2 id="%E6%8B%A6%E6%88%AA%E5%99%A8%E4%B8%8E%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%99%A8">拦截器与异常处理器</h2>
<p>过滤器 ServletFilter 过滤从浏览器发送的所有请求，作用于 DispatcherServlet 之前。DispatcherServlet 对请求进行处理，根据请求信息与 <code>@RequestMapping</code> 匹配。请求映射所对应的控制器方法 Controllers 就是处理请求的方法。拦截器用于拦截控制器方法前后，需要实现 HandlerInterceptor。</p>
<h3 id="%E6%8B%A6%E6%88%AA%E5%99%A8%E7%9A%84%E4%B8%89%E4%B8%AA%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95">拦截器的三个抽象方法</h3>
<p>preHandle =&gt; 控制器方法执行前调用，其返回值的类型表示拦截或放行，返回 true 为放行，即调用控制器方法；返回 false 表示拦截，即不调用控制器方法</p>
<p>postHandle =&gt; 控制器方法执行之后执行</p>
<p>afterCompletion =&gt; 处理完视图和模型数据，渲染视图完毕之后执行</p>
<h3 id="%E5%A4%9A%E4%B8%AA%E6%8B%A6%E6%88%AA%E5%99%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F">多个拦截器的执行顺序</h3>
<ul>
<li>每个拦截器的 <code>preHandle()</code> 都返回 true</li>
</ul>
<p>此时多个拦截器的执行顺序和拦截器在配置文件的配置顺序有关，<code>preHandle()</code> 会按照配置的顺序执行，而 <code>postHandle()</code> 和 <code>afterCompletion()</code> 会按照配置的反序执行。</p>
<ul>
<li>若某个拦截器的 <code>preHandle()</code> 返回 false</li>
</ul>
<p>返回 false 的拦截器和之前拦截器中 <code>preHandle()</code> 都会执行，<code>postHandle()</code> 都不执行，返回 false 的拦截器之前的拦截器的 <code>afterCompletion()</code> 会执行。</p>
<p>源码中拦截器放在 interceptorList，在 <code>applyPreHandle</code> 中以 i++ 形式执行，在 <code>applyPostHandle</code> 中以 i-- 形式执行。interceptorList 包括一个 Springmvc 内置的拦截器。mappedhandler 是执行链。</p>
<h3 id="%E6%8B%A6%E6%88%AA%E5%99%A8%E4%BD%BF%E7%94%A8">拦截器使用</h3>
<ul>
<li>配置文件设置拦截器</li>
</ul>
<p>将 bean 写入 &lt;mvc:interceptors&gt; 表示这一类型的 bean 是拦截器，这种方式的配置会导致所有的请求被拦截。</p>
<p>ref 引用当前 IOC 容器中某个 bean 的 id，故可将 ref 写入 &lt;mvc:interceptors&gt; 完成相同的效果，注意此方法的使用前提是将拦截器交给 IOC 容器管理。</p>
<p>值得注意的是 <code>&lt;mvc:view-controller path="/" view-name="index" /&gt;</code> 也会被拦截器所拦截。</p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans ...
       xmlns:mvc="http://www.springframework.org/schema/mvc"
       xsi:schemaLocation="...http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd"&gt;
    ...
    &lt;!--配置拦截器--&gt;
    &lt;mvc:interceptors&gt;
        &lt;ref bean="firstInterceptor"&gt;&lt;/ref&gt;
        &lt;ref bean="secondInterceptor"&gt;&lt;/ref&gt;
        &lt;!-- 通过配置一个bean的方式配置拦截器,那么所有请求都会进行拦截 --&gt;
        &lt;!-- &lt;bean class="com.zszy.mvc.interceptors.FirstInterceptor"&gt;&lt;/bean&gt; --&gt;
        &lt;!-- 同上默认对所有请求进行拦截 --&gt;
        &lt;!-- &lt;ref bean="firstInterceptor"&gt;&lt;/ref&gt; --&gt;
        &lt;!-- ref 和 bean 拦截所有路径请求 --&gt;
        &lt;!-- 指定具体的拦截规则 --&gt;
&lt;!--        &lt;mvc:interceptor&gt;--&gt;
&lt;!--            &amp;lt;!&amp;ndash; mapping 设置拦截的路径 =&gt; /* 一层目录; /** 所有目录 &amp;ndash;&amp;gt;--&gt;
&lt;!--            &lt;mvc:mapping path="/**"/&gt;--&gt;
&lt;!--            &amp;lt;!&amp;ndash; exclude-mapping 设置不拦截的路径 &amp;ndash;&amp;gt;--&gt;
&lt;!--            &lt;mvc:exclude-mapping path="/"/&gt;--&gt;
&lt;!--            &amp;lt;!&amp;ndash; 指明使用具体的拦截器 &amp;ndash;&amp;gt;--&gt;
&lt;!--            &lt;ref bean="firstInterceptor"&gt;&lt;/ref&gt;--&gt;
&lt;!--        &lt;/mvc:interceptor&gt;--&gt;
    &lt;/mvc:interceptors&gt;
    &lt;!-- 配置异常处理 --&gt;
    ...
&lt;/beans&gt;
</code></pre>
<ul>
<li>设置拦截器</li>
</ul>
<p>类似于过滤器 FilterChain 的 doFilter 方法，拦截器也需要放行使得完全访问控制器方法。</p>
<pre><code class="language-java">@Component // 标识组件的方式将拦截器交给 ioc 容器管理 =&gt; 使用 ref 的前提
public class FirstInterceptor implements HandlerInterceptor {

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        System.out.println("FirstInterceptor--&gt;preHandle");
        return true; // 返回的布尔类型表示是否放行
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        System.out.println("FirstInterceptor--&gt;postHandle");
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        System.out.println("FirstInterceptor--&gt;afterCompletion");
    }
}
</code></pre>
<ul>
<li>测试代码</li>
</ul>
<pre><code class="language-java">/* TestController */
@Controller
public class TestController {
    @RequestMapping("/**/testInterceptor")
    public String testInterceptor(){
        return "success";
    }
}
</code></pre>
<h3 id="%E5%9F%BA%E4%BA%8E%E9%85%8D%E7%BD%AE%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86">基于配置的异常处理</h3>
<p>处理控制器方法执行中出现异常的顶层接口 HandlerExceptionResolver 实现类有 DefaultHandlerExceptionResolver 和 SimpleMappingExceptionResolver。</p>
<ul>
<li>自定义的异常处理器 SimpleMappingExceptionResolver 使用方式</li>
</ul>
<p>若在控制器方法执行中出现<u>指定的异常</u>，那么可返回一个新的 ModelAndView。</p>
<pre><code class="language-xml">&lt;bean class="org.springframework.web.servlet.handler.SimpleMappingExceptionResolver"&gt;
    &lt;property name="exceptionMappings"&gt;
        &lt;props&gt;
        	&lt;!-- properties的键表示处理器方法执行过程中出现的异常; properties的值表示若出现指定异常时，设置一个新的视图名称，跳转到指定页面 --&gt;
            &lt;prop key="java.lang.ArithmeticException"&gt;error&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
    &lt;!-- exceptionAttribute属性设置一个属性名, 将出现的异常信息在请求域中进行共享 --&gt;
    &lt;property name="exceptionAttribute" value="ex"&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<pre><code class="language-java">/* ExceptionHandler */
@Controller
public class TestController {
    @RequestMapping("/testExceptionHandler")
    public String testExceptionHandler(){
        System.out.println(1/0);
        return "success";
    }
}
</code></pre>
<pre><code class="language-html">&lt;!-- error.html --&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;ExceptionTest&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
出现错误
&lt;p th:text="${ex}"&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86">基于注解的异常处理</h3>
<pre><code class="language-java">//@ControllerAdvice将当前类标识为异常处理的组件
@ControllerAdvice
public class ExceptionController {
    // @ExceptionHandler 用于设置所标识方法处理的异常
    @ExceptionHandler(value = {ArithmeticException.class, NullPointerException.class})
    // ex 表示当前请求处理中出现的异常对象
    public String testException(Exception ex, Model model){
        model.addAttribute("ex", ex);
        return "error";
    }
}
</code></pre>
<h2 id="%E6%B3%A8%E8%A7%A3%E9%85%8D%E7%BD%AE-springmvc">注解配置 SpringMVC</h2>
<p>使用配置类和注解代替 web.xml 和 SpringMVC 配置文件。Servlet3.0 中容器会在类路径 src、resource 中查找实现 javax.servlet.ServletContainerInitializer 接口的类，若能找到就用其来配置 Servlet 容器，即 Tomcat 服务器。</p>
<p>Spring 提供此接口的实现 SpringServletContainerInitializer，这个类会查找实现 WebApplicationInitializer 的类并将配置的任务交其完成。</p>
<p>Spring3.2 中引入接口 WebApplicationInitializer 的基础实现，当类扩展了此实现并将其部署到 Servlet3.0 容器时，容器会自动检测，并用其配置 Servlet 上下文。</p>
<p>AbstractAnnotationConfigDispatcherServletInitializer</p>
<p>除在服务器启动时自动调用 servlet、filter、listener，WebInit 类也会被自动加载和执行。</p>
<ul>
<li>初始化 WebInit 类代替 web.xml</li>
</ul>
<pre><code class="language-java">/* web 工程初始化类,用来代替 web.xml */
public class WebInit extends AbstractAnnotationConfigDispatcherServletInitializer {
    /* 指定spring的配置类 */
    @Override
    protected Class&lt;?&gt;[] getRootConfigClasses() {
        return new Class[]{SpringConfig.class};
    }
    /* 指定springmvc的配置类 */
    @Override
    protected Class&lt;?&gt;[] getServletConfigClasses() {
        return new Class[]{WebConfig.class};
    }
    /* 指定dispatcherServlet的映射规则,即 URL—pattern */
    @Override
    protected String[] getServletMappings() {
        return new String[]{"/"};
    }
    /* 注册过滤器 */
    @Override
    protected Filter[] getServletFilters() {
        CharacterEncodingFilter characterEncodingFilter = new CharacterEncodingFilter();
        characterEncodingFilter.setEncoding("UTF-8");
        characterEncodingFilter.setForceResponseEncoding(true);
        HiddenHttpMethodFilter hiddenHttpMethodFilter = new HiddenHttpMethodFilter();
        return new Filter[]{characterEncodingFilter,hiddenHttpMethodFilter};
    }
}
</code></pre>
<ul>
<li>WebConfig 类代替 SpringMVC 的配置文件</li>
</ul>
<pre><code class="language-java">/* 代替 springMVC 的配置文件 =&gt; 扫描组件、视图解析器、view-controller、default-servlet-handler、mvc 注解驱动、文件上传解析器、异常处理、拦截器 */
@Configuration // 配置类
@ComponentScan("com.zszy.mvc.controller") // 扫描组件
@EnableWebMvc // 开启MVC注解驱动
public class WebConfig implements WebMvcConfigurer {
    // default-servlet-handler
    @Override
    public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {
        configurer.enable();
    }

    // 拦截器
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        TestInterceptor testInterceptor = new TestInterceptor();
        registry.addInterceptor(testInterceptor).addPathPatterns("/**");
    }

    // view-controller
    @Override
    public void addViewControllers(ViewControllerRegistry registry) {
        registry.addViewController("/hello").setViewName("hello");
    }

    // 文件上传解析器
    @Bean
    public MultipartResolver multipartResolver(){
        CommonsMultipartResolver commonsMultipartResolver = new CommonsMultipartResolver();
        return commonsMultipartResolver;
    }

    // 异常处理
    @Override
    public void configureHandlerExceptionResolvers(List&lt;HandlerExceptionResolver&gt; resolvers) {
        SimpleMappingExceptionResolver exceptionResolver = new SimpleMappingExceptionResolver();
        Properties properties = new Properties();
        properties.setProperty("java.lang.ArithmeticException","error");
        exceptionResolver.setExceptionMappings(properties);
        exceptionResolver.setExceptionAttribute("exception");
        resolvers.add(exceptionResolver);
    }

    // 配置生成模板解析器
    @Bean
    public ITemplateResolver templateResolver() {
        WebApplicationContext webApplicationContext = ContextLoader.getCurrentWebApplicationContext();
        // ServletContextTemplateResolver需要一个ServletContext作为构造参数，可通过WebApplicationContext 的方法获得
        ServletContextTemplateResolver templateResolver = new ServletContextTemplateResolver(webApplicationContext.getServletContext());
        templateResolver.setPrefix("/WEB-INF/templates/");
        templateResolver.setSuffix(".html");
        templateResolver.setCharacterEncoding("UTF-8");
        templateResolver.setTemplateMode(TemplateMode.HTML);
        return templateResolver;
    }

    // 生成模板引擎并为模板引擎注入模板解析器
    @Bean
    public SpringTemplateEngine templateEngine(ITemplateResolver templateResolver) {
        SpringTemplateEngine templateEngine = new SpringTemplateEngine();
        templateEngine.setTemplateResolver(templateResolver);
        return templateEngine;
    }

    // 生成视图解析器并未解析器注入模板引擎
    @Bean
    public ViewResolver viewResolver(SpringTemplateEngine templateEngine) {
        ThymeleafViewResolver viewResolver = new ThymeleafViewResolver();
        viewResolver.setCharacterEncoding("UTF-8");
        viewResolver.setTemplateEngine(templateEngine);
        return viewResolver;
    }
}
</code></pre>
<ul>
<li>Spring 配置类、Controller 层以及前端页面和拦截器</li>
</ul>
<pre><code class="language-java">@Configuration
public class SpringConfig { }
</code></pre>
<pre><code class="language-java">@Controller
public class TestController {
    @RequestMapping("/")
    public String index(){
        return "index";
    }
}
</code></pre>
<pre><code class="language-html">&lt;!-- index --&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;index&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;h1&gt;index&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;
&lt;!-- hello --&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;hello&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;h1&gt;hello by zs&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="language-java">public class TestInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        System.out.println("TestInterceptor =&gt; preHandle");
        return true;
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        HandlerInterceptor.super.postHandle(request, response, handler, modelAndView);
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        HandlerInterceptor.super.afterCompletion(request, response, handler, ex);
    }
}
</code></pre>
<h2 id="springmvc-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B">SpringMVC 执行流程</h2>
<p>同志，还没总结的，别卷了，谢谢。</p>
<h2 id="bugs-%E5%A4%84%E7%90%86">Bugs 处理</h2>
<ul>
<li>Maven 的 pom.xml 注入依赖飘红</li>
</ul>
<p>刷新 pom.xml 与 maven，可查看到 IntelliJ 右下角正在下载 Jar 包。</p>
<ul>
<li>HTTP 状态 404 未找到</li>
</ul>
<pre><code>// 异常报告
消息 The requested resource [/springMVC/hello/testRequestMapping] is not available
描述 源服务器未能找到目标资源的表示或者是不愿公开一个已经存在的资源表示。
</code></pre>
<p>因在配置 web.xml 的前端控制器时，未配置 &lt;url-pattern&gt; 标签内的值。&lt;servlet-mapping&gt; 标签声明与该 servlet 相应的匹配规则，每个 &lt;url-pattern&gt; 标签代表一个匹配规则。当浏览器发起请求到 servlet 容器时，容器先会将请求的路径去除当前应用上下文的路径后，作为 servlet 的映射 url。</p>
<ul>
<li>在 Maven 模块 src 目录的 main 下创建 webapp 无蓝标</li>
</ul>
<p>在 project structure 中选择 Facets 栏，为新增的模块增加 web。</p>
<pre><code class="language-java">// Deployment Descriptors 为项目描述符 =&gt; web.xml
/Users/&lt;username&gt;/IdeaProjects/idea-maven-repo/springMVC/springMVC-demo02/src/main/webapp/WEB-INF/web.xml
// web resource directories 为 web 资源目录 =&gt; 指明 webapp
/Users/&lt;username&gt;/IdeaProjects/idea-maven-repo/springMVC/springMVC-demo02/src/main/webapp
</code></pre>
<ul>
<li>启动 Tomcat 没有 artifacts</li>
</ul>
<p>在 project structure 中选择 artifacts 栏，加上一个 web application exploded。</p>
<ul>
<li>导入项目文件夹并设置为 maven 项目</li>
</ul>
<p>右键导入模块的 pom.xml 文件，选择 Add as Maven Project。</p>
<ul>
<li>IntelliJ 项目中模块消失，只剩 iml 文件。</li>
</ul>
<p>Project Structure =&gt; Modules =&gt; 加号 =&gt; import module。</p>
<ul>
<li>解决获取请求参数的乱码问题</li>
</ul>
<p>SpringMVC 提供的编码过滤器 CharacterEncodingFilter 可解决获取请求参数的乱码问题，但必须在 web.xml 中进行注册。监听器、过滤器及 servlet 应依次加载。</p>
<ul>
<li>静态资源被 SpringMVC 框架拦截</li>
</ul>
<pre><code>No mapping found for HTTP request with URI [static/css/index.css] in DispatcherServlet
</code></pre>
<p>Servlet 的 RequestDispatcher 通过名称而不是路径来检索，即 SpringMVC 将接收到的<u>所有</u>请求都看作是一个普通的请求，包括对于静态资源的请求。那么所有对静态资源的请求都会被看作是一个普通的后台控制器请求，导致 @RequestMapping 无法成功匹配。</p>
<p>解决方案是在配置文件增加 &lt;mvc:default-servlet-handler /&gt; 标签。</p>
<p>DefaultServletHttpRequestHandler 会于 Web 容器启动时在上下文进行定义。其会对 DispatcherServlet 的请求进行处理。</p>
<p>若请求存在相应 @requestMapping =&gt; 后台对应的处理程序</p>
<p>若请求没有相应的 @requestMapping =&gt; 应用服务器默认的 Servlet 处理</p>
<ul>
<li>自定义拦截器实现 HandlerInterceptor 接口时没有 @override 提示</li>
</ul>
<p>总所周知，在接口中只能定义方法，而不能对方法进行具体的实现。接口中定义的方法必须在接口的非抽象子类中进行具体的实现。HandlerInterceptor 里 default 方法能在接口内部包含一些默认的方法实现，故 IntelliJ 不出现 @Override 提示。</p>
<p>建议复制 HandlerInterceptor 接口的方法，在重写时将类访问修饰符范围扩大。</p>
<h2 id="%E7%BB%93%E6%9D%9F">结束</h2>
<p>本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh"> CC BY-SA 4.0 </a>协议，转载请注明出处！</p>


            </section>

        </article>
    </main>
    <footer class="page-footer">
            <amp-img class="site-icon" src="yourdomain.com/content/images/2021/07/ghost-orb.png" width="50" height="50" layout="fixed" alt="zairesinatra"></amp-img>
        <h3>zairesinatra</h3>
            <p>The best time to recognize yourself is ten years ago, followed by now.</p>
        <p><a href="../../index.html">Read more posts →</a></p>
        <a class="powered" href="https://ghost.org" target="_blank" rel="noopener"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 156 156"><g fill="none" fill-rule="evenodd"><rect fill="#15212B" width="156" height="156" rx="27"/><g transform="translate(36 36)" fill="#F6F8FA"><path d="M0 71.007A4.004 4.004 0 014 67h26a4 4 0 014 4.007v8.986A4.004 4.004 0 0130 84H4a4 4 0 01-4-4.007v-8.986zM50 71.007A4.004 4.004 0 0154 67h26a4 4 0 014 4.007v8.986A4.004 4.004 0 0180 84H54a4 4 0 01-4-4.007v-8.986z"/><rect y="34" width="84" height="17" rx="4"/><path d="M0 4.007A4.007 4.007 0 014.007 0h41.986A4.003 4.003 0 0150 4.007v8.986A4.007 4.007 0 0145.993 17H4.007A4.003 4.003 0 010 12.993V4.007z"/><rect x="67" width="17" height="17" rx="4"/></g></g></svg> Published with Ghost</a>
    </footer>
    
</body>
</html>
