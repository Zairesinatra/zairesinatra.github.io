<!DOCTYPE html>
<html lang="en">
<head>

    <title>Webpack</title>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="stylesheet" type="text/css" href="../assets/built/screen.css%3Fv=5751b4c87c.css" />

    <meta name="description" content="Webpack is a free and open-source module bundler for JavaScript.">
    <link rel="icon" href="../content/images/size/w256h256/2021/07/ghost-orb.png" type="image/png">
    <link rel="canonical" href="index.html">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <link rel="amphtml" href="amp/index.html">
    
    <meta property="og:site_name" content="zairesinatra">
    <meta property="og:type" content="article">
    <meta property="og:title" content="Webpack">
    <meta property="og:description" content="Webpack is a free and open-source module bundler for JavaScript.">
    <meta property="og:url" content="https://zairesinatra.github.io//webpack/">
    <meta property="og:image" content="https://zairesinatra.github.io//content/images/2023/04/MickeyMouse.jpg">
    <meta property="article:published_time" content="2021-03-08T13:55:00.000Z">
    <meta property="article:modified_time" content="2023-07-28T09:48:47.000Z">
    <meta property="article:tag" content="Technology growth">
    
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Webpack">
    <meta name="twitter:description" content="Webpack is a free and open-source module bundler for JavaScript.">
    <meta name="twitter:url" content="https://zairesinatra.github.io//webpack/">
    <meta name="twitter:image" content="https://zairesinatra.github.io//content/images/2023/04/MickeyMouse.jpg">
    <meta name="twitter:label1" content="Written by">
    <meta name="twitter:data1" content="Ziyi Xie">
    <meta name="twitter:label2" content="Filed under">
    <meta name="twitter:data2" content="Technology growth">
    <meta name="twitter:site" content="@xieziyi0422">
    <meta property="og:image:width" content="1920">
    <meta property="og:image:height" content="1080">
    
    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "publisher": {
        "@type": "Organization",
        "name": "zairesinatra",
        "url": "https://zairesinatra.github.io//",
        "logo": {
            "@type": "ImageObject",
            "url": "https://zairesinatra.github.io//content/images/2021/07/zs-1.JPG",
            "width": 60,
            "height": 60
        }
    },
    "author": {
        "@type": "Person",
        "name": "Ziyi Xie",
        "image": {
            "@type": "ImageObject",
            "url": "https://zairesinatra.github.io//content/images/2021/07/zs-2.JPG",
            "width": 1079,
            "height": 1079
        },
        "url": "https://zairesinatra.github.io//author/ziyi/",
        "sameAs": []
    },
    "headline": "Webpack",
    "url": "https://zairesinatra.github.io//webpack/",
    "datePublished": "2021-03-08T13:55:00.000Z",
    "dateModified": "2023-07-28T09:48:47.000Z",
    "image": {
        "@type": "ImageObject",
        "url": "https://zairesinatra.github.io//content/images/2023/04/MickeyMouse.jpg",
        "width": 1920,
        "height": 1080
    },
    "keywords": "Technology growth",
    "description": "Webpack is a free and open-source module bundler for JavaScript.",
    "mainEntityOfPage": "https://zairesinatra.github.io//webpack/"
}
    </script>

    <meta name="generator" content="Ghost 5.53">
    <link rel="alternate" type="application/rss+xml" title="zairesinatra" href="../rss/index.html">
    <script defer src="https://cdn.jsdelivr.net/ghost/portal@~2.33/umd/portal.min.js" data-i18n="false" data-ghost="https://zairesinatra.github.io//" data-key="f5d74add11f1d16d3e59c12945" data-api="https://zairesinatra.github.io//ghost/api/content/" crossorigin="anonymous"></script><style id="gh-members-styles">.gh-post-upgrade-cta-content,
.gh-post-upgrade-cta {
    display: flex;
    flex-direction: column;
    align-items: center;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
    text-align: center;
    width: 100%;
    color: #ffffff;
    font-size: 16px;
}

.gh-post-upgrade-cta-content {
    border-radius: 8px;
    padding: 40px 4vw;
}

.gh-post-upgrade-cta h2 {
    color: #ffffff;
    font-size: 28px;
    letter-spacing: -0.2px;
    margin: 0;
    padding: 0;
}

.gh-post-upgrade-cta p {
    margin: 20px 0 0;
    padding: 0;
}

.gh-post-upgrade-cta small {
    font-size: 16px;
    letter-spacing: -0.2px;
}

.gh-post-upgrade-cta a {
    color: #ffffff;
    cursor: pointer;
    font-weight: 500;
    box-shadow: none;
    text-decoration: underline;
}

.gh-post-upgrade-cta a:hover {
    color: #ffffff;
    opacity: 0.8;
    box-shadow: none;
    text-decoration: underline;
}

.gh-post-upgrade-cta a.gh-btn {
    display: block;
    background: #ffffff;
    text-decoration: none;
    margin: 28px 0 0;
    padding: 8px 18px;
    border-radius: 4px;
    font-size: 16px;
    font-weight: 600;
}

.gh-post-upgrade-cta a.gh-btn:hover {
    opacity: 0.92;
}</style>
    <script defer src="https://cdn.jsdelivr.net/ghost/sodo-search@~1.1/umd/sodo-search.min.js" data-key="f5d74add11f1d16d3e59c12945" data-styles="https://cdn.jsdelivr.net/ghost/sodo-search@~1.1/umd/main.css" data-sodo-search="https://zairesinatra.github.io//" crossorigin="anonymous"></script>
    
    <link href="https://zairesinatra.github.io//webmentions/receive/" rel="webmention">
    <script defer src="../public/cards.min.js%3Fv=5751b4c87c"></script>
    <link rel="stylesheet" type="text/css" href="../public/cards.min.css%3Fv=5751b4c87c.css">
    <script defer src="../public/member-attribution.min.js%3Fv=5751b4c87c"></script>
    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-NXZH6Q3K52"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-NXZH6Q3K52');
</script>

<!-- Ghost Init -->
<style>
.post-template .gh-head,
.page-template .gh-head {
  background: #000000 !important;
}
.site-footer {
  background: #000000 !important;
}
.post-card-tags {
  color: var(--color-secondary-text) !important;
}
.gh-portal-triggerbtn-container.with-label::before {
  display: none !important;
}
/* 需提前，否则闪烁 */
.footer-cta,
a.gh-head-button {
  display: none;
}
/* 更多内容去除外边距 */
.footer-cta + .read-more-wrap {
  margin-top: unset;
}
</style>

<!-- Resize Pre Area in PrismJS -->
<style>
    pre[class*="language-"].line-numbers{
		font-size: 0.8em;
        background-color: #202324;
    }
    code[class*="language-"] {
        background-color: transparent !important;
    }
</style>

<!-- TOC -->
<style>
    .toc > .toc-list li:first-child {
      margin-top: 8px;
    }
    .toc-list a {
      color: #000000 !important;
      text-decoration: none;
      word-break: break-word;
    }
    .toc > ol, .toc > li{
      font-size: 1.4rem;
    }
    
    .toc.active > .toc-list li:first-child {
      margin-top: 8px;
    }
    .toc.active .toc-list a {
      color: #FFFFFF !important;
      text-decoration: none;
      word-break: break-word;
    }
    .toc.active > ol, .toc.active > li{
      font-size: 1.4rem;
    }
</style>

<!-- ghost style by wkzs -->
<style>
.gh-content > [id]:not(:first-child) {
  margin: 1.5em 0 0;
}
.gh-content > hr + *, .gh-content > blockquote + * {
  margin-top: max(1.1rem, 16px) !important;
}
.gh-content > [id]:not(:first-child) {
  margin: 1em 0 0;
}
.gh-content > * + * {
  margin-top: max(1.6vmin, 16px);
  margin-bottom: 0;
}
.gh-content > blockquote:not([class]), .gh-content > ol, .gh-content > ul, .gh-content > dl, .gh-content > p {
    font-family: var(--font-serif);
    font-weight: 400;
    font-size: 1.4rem !important;
  	line-height: 1.8em !important;
    margin-top: 1.6rem;
}
</style>

<!-- Theme Change -->
<style>
/* 主题按钮样式 */
html {
  transition: all 0.3s ease-in-out;
}
html.dark {
  background-color: #333;
}
.toggle {
  position: relative;
  height: 22px;
  width: 42px;
  border-radius: 15px;
  border: 1px solid #474747;
  background-color: #f1f1f1;
  box-shadow: 0 5px 10px rgba(0, 0, 0, 0.1);
  cursor: pointer;
}
.dark-mode .toggle {
  background-color: #2f2f2f;
}
/*
.toggle:hover {
  border-color: #8e8e8e;
}
*/
.toggle::before {
  content: "";
  position: absolute;
  height: 16px;
  width: 16px;
  background-color: #ffffff;
  border-radius: 50%;
  top: 50%;
  left: 2px;
  transform: translateY(-50%);
  transition: all 0.3s ease-in-out;
}
.toggle.active::before {
  background-color: #1a1a1a;
  left: calc(100% - 18px);
}
/* For Switch And Icons */
.switch-icon {
  display: grid;
  grid-template-columns: auto auto; /* 定义两列 */
}
.switch-icon svg {
  position: relative;
  z-index: 1; /* 设置较高的层叠顺序值 */
  top: 35%;
  left: 20%;
  height: 12px;
}
.dark-mode .switch-icon svg {
  fill: rgba(255, 255, 255, 0.87);
  transition: opacity 0.25s;
}
.switch-appearance-moon,
.dark-mode .switch-appearance-sun {
  opacity: 0;
}
.dark-mode .switch-appearance-moon {
  opacity: 1;
  
}
.switch-appearance-sun {
  opacity: 1;

}
/* 移动端主题按钮出现效果 */
@keyframes slideUp {
  from {
    bottom: 20px;
    opacity: 0;
  }
  to {
    bottom: 0;
    opacity: 1;
  }
}
@media (max-width: 767px) {
  .gh-head-open .toggle {
    animation: slideUp 1s ease-in-out forwards;
  }
}
</style>

<!-- Drak Theme Ghost CSS -->
<style>
/* 暗色下 blockquote 应为白色 */
.dark-mode .gh-content > blockquote:not([class])::before {
  background: #FFFFFF;
}
</style>

<!-- Arrow up -->
<style>
.arrowup {
  position: fixed;
  width: 50px;
  height: 50px;
  left: 35px;
  bottom: 3.1rem;
  z-index: 99;
  background-color: #15171a;
  display: flex;
  justify-content: center;
  align-items: center;
  border-radius: 10px;
  cursor: pointer;
  display: none;
}
.arrowup svg {
  fill: #ffffff;
}
.arrowup:hover {
  opacity: 0.8;
}
</style>

<!-- 2023 => prismjs -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zairesinatra/GhostCDN@1.0.0/prism.css"/>

<!-- tocbot -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.18.2/tocbot.css">

<!-- docsearch -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@docsearch/css@3"/></pre></li><style>:root {--ghost-accent-color: #15171A;}</style>

</head>
<body class="post-template tag-technology-growth is-head-left-logo has-cover">
<div class="viewport">

    <header id="gh-head" class="gh-head outer">
        <div class="gh-head-inner inner">
            <div class="gh-head-brand">
                <a class="gh-head-logo" href="../index.html">
                        <img src="../content/images/2021/07/zs-1.JPG" alt="zairesinatra">
                </a>
                <button class="gh-search gh-icon-btn" onclick="docSearchFuncMobile()"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" width="20" height="20"><path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path></svg></button>
                <button class="gh-burger"></button>
            </div>

            <nav class="gh-head-menu">
                <ul class="nav">
    <li class="nav-home"><a href="../index.html">Home</a></li>
    <li class="nav-welcome"><a href="../welcome/index.html">Welcome</a></li>
    <li class="nav-author"><a href="../selfintro/index.html">Author</a></li>
    <li class="nav-tags"><a href="../tags/index.html">Tags</a></li>
</ul>

            </nav>

            <div class="gh-head-actions">
                <div class="gh-head-actions">
                    <div class="toggle">
                        <span class="switch-icon">
                            <svg
                            xmlns="http://www.w3.org/2000/svg"
                            aria-hidden="true"
                            focusable="false"
                            viewBox="0 0 24 24"
                            class="switch-appearance-sun"
                            >
                            <path
                                d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"
                            ></path>
                            <path
                                d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"
                            ></path>
                            <path
                                d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"
                            ></path>
                            <path
                                d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"
                            ></path>
                            <path
                                d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"
                            ></path>
                            <path
                                d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"
                            ></path>
                            <path
                                d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"
                            ></path>
                            <path
                                d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"
                            ></path>
                            <path
                                d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"
                            ></path>
                            </svg>
                            <svg
                            xmlns="http://www.w3.org/2000/svg"
                            aria-hidden="true"
                            focusable="false"
                            viewBox="0 0 24 24"
                            class="switch-appearance-moon"
                            >
                            <path
                                d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"
                            ></path>
                            </svg>
                        </span>
                    </div>
                </div>
                    <button class="gh-search gh-icon-btn" onclick="docSearchFuncMobile()"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" width="20" height="20"><path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path></svg></button>
                    <div class="gh-head-members">
                                <a class="gh-head-link" href="index.html#/portal/signin" data-portal="signin">Sign in</a>
                                <a class="gh-head-button" href="index.html#/portal/signup" data-portal="signup">Subscribe</a>
                    </div>
            </div>
        </div>
    </header>

    <div class="site-content">
        



<main id="site-main" class="site-main">
<article class="article post tag-technology-growth image-small">

    <header class="article-header gh-canvas">

        <div class="article-tag post-card-tags">
                <span class="post-card-primary-tag">
                    <a href="../tag/technology-growth/index.html">Technology growth</a>
                </span>
        </div>

        <h1 class="article-title">Webpack</h1>

            <p class="article-excerpt">Webpack is a free and open-source module bundler for JavaScript.</p>

        <div class="article-byline">
        <section class="article-byline-content">

            <ul class="author-list">
                <li class="author-list-item">
                    <a href="../author/ziyi/index.html" class="author-avatar">
                        <img class="author-profile-image" src="../content/images/size/w100/2021/07/zs-2.JPG" alt="Ziyi Xie" />
                    </a>
                </li>
            </ul>

            <div class="article-byline-meta">
                <h4 class="author-name"><a href="../author/ziyi/index.html">Ziyi Xie</a></h4>
                <div class="byline-meta-content">
                    <time class="byline-meta-date" datetime="2021-03-08">Mar 8, 2021</time>
                        <span class="byline-reading-time"><span class="bull">&bull;</span> 34 min read</span>
                </div>
            </div>

        </section>
        </div>

            <figure class="article-image">
                <img
                    srcset="../content/images/size/w2000/2023/04/MickeyMouse.jpg 2000w"
                    sizes="(min-width: 1400px) 1400px, 92vw"
                    src="../content/images/size/w2000/2023/04/MickeyMouse.jpg"
                    alt="Mickey Mouse"
                />
                    <figcaption>Mickey Mouse</figcaption>
            </figure>

    </header>

    <section class="gh-content gh-canvas">
        <aside class="toc-container">
            <div class="toc"></div>
        </aside>
        <!--kg-card-begin: markdown--><h2 id="gettingstarted">Getting Started</h2>
<h3 id="introtowebpack">Intro to Webpack</h3>
<blockquote>
<p>Webpack takes modules with dependencies and generates static assets representing those modules.</p>
</blockquote>
<p>webpack-cli 是一个与 webpack 相关的命令行工具，用于在终端中执行指定命令，解析命令行参数，并把这些参数传递给 webpack。</p>
<p>注意，webpack 本身并没有内置命令行工具，如果没有安装 webpack-cli，直接在终端里执行 webpack 命令时会报错。</p>
<pre><code class="language-shell">$ npx webpack --entry ./src/main.js --output-path ./build --mode=development
</code></pre>
<p><code>npx</code> 可理解为使用本地的模块，实际上是运行当前项目中 <code>node_modules/.bin</code> 下的可执行文件。</p>
<p><code>package.json</code> 文件的 <code>scripts</code> 字段不需要在命令的前面加上 <code>npx</code>。与 <code>webpack.config.js</code> 一样，<code>package.json</code> 中的 <code>scripts</code> 字段可以直接使用本地安装的模块或全局安装的命令。</p>
<pre><code class="language-json">{
  &quot;scripts&quot;: {
    &quot;build&quot;: &quot;webpack --entry ./src/main.js --output-path ./build --mode=development&quot;
  }
}
</code></pre>
<p><code>npm run</code> 会在当前目录下新建一个 Shell，并将当前目录下的 <code>node_modules/.bin</code> 加入 <code>PATH</code> 变量，使得在执行脚本命令时可以直接引用该目录下的可执行文件。在执行结束以后，路径变量会恢复原样，以保证环境变量的稳定性。这就是 <code>npm run</code> 能够执行项目本地安装的 CLI 工具的原因。</p>
<p>除上述方法外，项目中更多见的是使用 <code>webpack.config.js</code> 之流的配置文件进行打包的相关设置。</p>
<pre><code class="language-javascript">const { resolve } = require(&quot;path&quot;);
module.exports = { 
  entry: &quot;./src/main.js&quot;, // 入口文件可以是相对路径
  output: {
  	filename: &quot;bundle.js&quot;,
  	path: resolve(__dirname, &quot;./build&quot;) // 输出文件路径必须是绝对路径
  },
  mode: &quot;development&quot;
};
</code></pre>
<pre><code class="language-shell">$ npx webpack --config webpack.config.js
</code></pre>
<pre><code class="language-json">&quot;scripts&quot;: {
  &quot;build&quot;: &quot;webpack --config webpack.config.js&quot;
}
</code></pre>
<p>webpack 通常使用 CommonJS 模块化规范来读取配置文件，即配置文件中通过 <code>module.exports</code> 导出一个对象，对象中包含了各种打包配置信息。注意，配置文件须放在项目根目录下。</p>
<p>通过读取项目里的配置文件，解析代码中模块引用关系，可将这些模块打包成一个或多个 JS bundle 文件。这些 bundle 文件包含了应用中的所有代码、样式、图片等资源。</p>
<p>通过将这些资源打包成 bundle，可以减少浏览器加载资源的请求次数，提高页面性能和加载速度：</p>
<ul>
<li>在 HTTP/1.1 协议下，打包文件可以减少客户端发起请求的次数，降低 TCP 连接的占用</li>
<li>在 HTTP/2 协议下，代码分割可以将应用代码拆分成多个小块，进一步提升页面加载速度</li>
</ul>
<blockquote>
<p>HTTP/1.1 协议规定，在客户端发起请求时会建立一个 TCP 连接，在该连接上进行请求和响应。在此期间，不管请求的文件大小是多少，都会占用该连接，直到响应完成才会释放连接。</p>
</blockquote>
<blockquote>
<p>HTTP/2 协议支持多路复用，即一个 TCP 连接可以同时发送多个请求和响应。因此，使用 HTTP/2 协议时，每个文件的请求和响应都可以独立完成，不会相互影响。同时，HTTP/2 还支持服务器推送，即在客户端请求一个资源时，服务器可以主动推送与该资源相关的其他资源。</p>
</blockquote>
<p>在打包时默认会将所有直接或间接被引入到入口文件中的模块都打包，包括那些被引用的但实际上并未被使用的模块。摇树优化可以通过静态代码分析，识别出哪些模块中的代码是无用的，并将其从打包结果中移除，从而减小打包文件的体积。</p>
<p>总的来说，Webpack 是一种静态打包工具，通过在本地将所有代码和资源打包到一个或多个 bundle 之中，并且可以在构建过程中对代码进行一系列的优化，如代码压缩、摇树优化、代码分割等，最终生成优化后的打包文件。Webpack 缺点是构建速度较慢，尤其是在大型项目中，构建时间的可能会很长。</p>
<blockquote>
<p>Vite is built on top of Snowpack, a lightweight alternative to Webpack. Vite leverages the native ES module support in modern browsers, employs an on-demand compilation packaging approach, and dynamically compiles code at runtime without the need to pre-bundle all content. This enables Vite to start up and rebuild applications more quickly.</p>
</blockquote>
<p>应用程序启动和重新加载过程中常见的名词解释：</p>
<ul>
<li>热重载或热更新：程序运行时，无需停止或重启应用即可动态更新代码或资源文件</li>
<li>冷启动：在应用的首次启动时，需要重新加载所有必要的资源和配置文件</li>
<li>热启动：在应用已经启动并运行时，再次启动该应用程序（应用的许多资源已在内存中加载）</li>
<li>温启动：在应用已经启动并运行时，重新加载已经被关闭或过期的组件</li>
</ul>
<h3 id="basicloaders">Basic Loaders</h3>
<p>Loaders 用于对模块的源代码进行转换，将一种形式的源代码转换为另一种形式的源代码，以此满足特定的需求。</p>
<pre><code class="language-shell"># 因缺乏相应 loader 而导致的解析失败
Module parse failed: Unexpected token. You may need an appropriate loader to handle this file type.
</code></pre>
<p>配置文件中 <code>module.rules</code> 字段对应的值是数组 <code>[Rule]</code>。数组中存放一个或多个 Rule 对象，Rule 对象中具有 <code>test</code> 和 <code>use</code> 属性。</p>
<ul>
<li><code>test</code> 字段用于对资源进行匹配，通常设置成正则表达式</li>
<li><code>use</code> 字段值是一个 <code>[UseEntry]</code> 数组，其中 <code>UseEntry</code> 对象又具有以下属性
<ul>
<li><code>loader</code> 必选属性，对应的值是一个字符串</li>
<li><code>options</code> 可选属性，值是字符串或者对象，通常会传入到 loader 中</li>
</ul>
</li>
</ul>
<p>基础样式资源的打包通常需要 <a href="https://webpack.js.org/loaders/css-loader/?ref=localhost">css-loader</a> 和 <a href="https://webpack.js.org/loaders/style-loader/?ref=localhost">style-loader</a>。</p>
<ul>
<li>css-loader 处理 <code>@import</code> 和 <code>url()</code>，将 CSS 文件解析成样式字符串的 CJS 模块加载至 JS</li>
<li>style-loader 创建 <code>style</code> 标签并将 JS 里的样式添加到 <code>head</code> 元素（插入 DOM 树）</li>
</ul>
<pre><code class="language-shell">$ npm i css-loader style-loader less-loader less -D
</code></pre>
<p>通常 <code>use</code> 属性的值是一个字符串数组，这是使用了 <code>loader</code> 属性的简写方式。也有将 <code>use</code> 属性省略掉的时候，直接写上 <code>loader</code> 属性，但这只适用于一个 loader 的情况。</p>
<pre><code class="language-javascript">module: { // 不同文件必须配置不同 loader 处理
  rules: [
    {
      test: /\.css$/,
      use: [ 'style-loader', 'css-loader' ] // 语法糖
    },
    { 
      test: /\.less$/, 
      use: [ 'style-loader', 'css-loader', 'less-loader' ] // less-loader 将 less 文件编译成 css 
    } 
  ] 
}
</code></pre>
<p>在 Concepts 下 Loaders 中除 Configuration 外，还有一种 <a href="https://webpack.js.org/concepts/loaders/?ref=localhost#inline">Inline</a> 内联的方式使用 loaders。多个 loader 的执行顺序是从后往前的。</p>
<p><a href="https://github.com/browserslist/browserslist?ref=localhost">browserslist</a> 是一款用于配置项目中目标浏览器的工具，可以在不同的工具之间共享信息。</p>
<blockquote>
<p>browserslist is used in: Autoprefixer, Babel, postcss-preset-env, eslint-plugin-compat, stylelint-no-unsupported-browser-features, postcss-normalize, obsolete-webpack-plugin...</p>
</blockquote>
<p>通过 browserslist 指定一系列的浏览器及其版本，可以通知其他工具应该如何生成代码，以适配指定的目标浏览器（自动添加 CSS 前缀、使用相应的 Polyfill、转换 ES6+ 语法等）。</p>
<pre><code class="language-shell">$ npx browserslist &quot;&gt;1%, last 2 version, not dead&quot;
</code></pre>
<p>browserslist 的配置可以写在项目根目录下的 <code>.browserslistrc</code> 中，也可以写在 <code>package.json</code> 文件中的 <code>browserslist</code> 字段，支持的浏览器版本可以使用通配符以及范围来配置。</p>
<pre><code class="language-javascript">// package.json
&quot;browserslist&quot;: { 
  &quot;development&quot;: [ 
    // 兼容最近的浏览器版本
    &quot;last 1 chrome version&quot;, 
    &quot;last 1 firefox version&quot;,
    &quot;last 1 safari version&quot; 
  ],
  &quot;production&quot;: [ 
    &quot;&gt;0.2%&quot;,
    &quot;not dead&quot;,
    &quot;not op_mini all&quot; 
  ]
}
</code></pre>
<p>通常情况下，在使用 Webpack 进行项目开发时，会默认安装 browserslist 这个库，因为很多 Webpack 插件和 loader 都会使用 browserslist 来进行浏览器兼容性检查和自动添加前缀等操作。而 browserslist 内部使用了 caniuse-lite 数据库来进行浏览器的兼容性查询。</p>
<p>PostCSS 是一个用 JavaScript 实现的 CSS 处理器，通过解析 CSS 并以抽象语法树 AST 的形式存储，从而可以在 AST 层面上对 CSS 进行操作，例如添加前缀、处理嵌套、转换 CSS 语法等。如果需要单独在命令行中使用，应该额外再安装一个 postcss-cli 工具。</p>
<p>同时有很多优秀的插件也是基于 PostCSS 诞生的，如 PreCSS、CSSNext、cssnano、Autoprefixer 等。</p>
<pre><code class="language-js">{
  test: /\.css$/,
  use: [
    &quot;style-loader&quot;,
    &quot;css-loader&quot;,
    {
      loader: &quot;postcss-loader&quot;,
      options: {
        postcssOptions: {
          plugins: [
            require(&quot;autoprefixer&quot;)
          ]
        }
      }
    }
  ]
}
</code></pre>
<p>事实上，在配置 postcss-loader 时，更多的会使用 postcss-preset-env。postcss-preset-env 将一些现代 CSS 特性转换为大多数浏览器都能理解的 CSS，并自动添加所需的 polyfill。此外，postcss-preset-env 还自动集成了 Autoprefixer 插件，因此不需要单独配置 Autoprefixer。</p>
<pre><code class="language-js">{
  test: /\.css$/,
  use: [
    &quot;style-loader&quot;,
    &quot;css-loader&quot;,
    {
      loader: &quot;postcss-loader&quot;,
      options: {
        postcssOptions: {
          plugins: [
            require(&quot;postcss-preset-env&quot;)
          ]
        }
      }
    }
  ]
}
</code></pre>
<p>此外，也完全可以将 postcss-loader 的配置移到 <code>postcss.config.js</code> 文件中，代码如下。</p>
<pre><code class="language-javascript">// postcss.config.js
module.exports = {
  plugins: [
    require(&quot;postcss-preset-env&quot;)
  ]
}
</code></pre>
<pre><code class="language-javascript">use: [ &quot;style-loader&quot;, &quot;css-loader&quot;, &quot;postcss-loader&quot; ]
</code></pre>
<p>如果有在 CSS 文件中通过 <code>@import</code> 导入其他的 CSS 文件，那么这些导入的 CSS 可能不会被 postcss-loader 或者 less-loader 等处理，因为 Webpack 只会对直接引入的 CSS 文件应用 loaders，而不会递归地处理引入的 CSS 文件。</p>
<p>此时可以在使用 css-loader 时配置 <code>importLoaders</code> 选项。<code>importLoaders</code> 选项控制在处理 CSS 文件时，css-loader 应该使用几个额外的 loader 来处理 <code>@import</code> 引入的其他 CSS 文件。例如，在 css-loader 中设置 <code>importLoaders: 1</code>，那么在处理 CSS 文件时，css-loader 将同时使用 postcss-loader 来处理 <code>@import</code> 导入的 CSS 文件。</p>
<pre><code class="language-js">{
  test: /\.css$/,
  use: [
    'style-loader',
    {
      loader: 'css-loader',
      options: {
        importLoaders: 1 // 这里设置为 1
      }
    },
    'postcss-loader'
  ]
}
</code></pre>
<pre><code class="language-js">{
  test: /\.less$/,
  use: [
    'style-loader',
    {
      loader: 'css-loader',
      options: {
        importLoaders: 2 // 这里设置为 2
      }
    },
    'postcss-loader',
    'less-loader'
  ]
}

</code></pre>
<p>使用图片时，常见的两种方式是 <code>img</code> 元素的 <code>src</code> 属性和 CSS 中的 <code>background-image</code> 属性。</p>
<blockquote>
<p>The file-loader resolves <code>import/require()</code> on a file into a url and emits the file into the output dir.</p>
</blockquote>
<blockquote>
<p>The url-loader works like file-loader, but can return a DataURL if a file is smaller than a byte limit.</p>
</blockquote>
<p>file-loader 会根据文件的内容使用 MD4 算法生成文件名。但是在某些情况下，可能需要使用占位符来自定义生成的文件名，以确保每张图片都有一个明确的对应关系。此时应考虑 <a href="https://v4.webpack.js.org/loaders/file-loader/?ref=localhost#placeholders">placeholders</a>。</p>
<pre><code class="language-js">{
  test: /\.(png|jpg|gif)$/i,
  loader: 'file-loader',
  options: {
    name: '[name]-[hash].[ext]',
    outputPath: 'images/'
  }
}
</code></pre>
<p>开发中，较大的图片文件往往会被存放在单独的目录，通过异步加载的方式来减少页面的加载时间。较小的图片通常会使用 Base64 数据直接嵌入到 HTML 或 CSS 文件，而不作为单独的文件加载。</p>
<p>url-loader 可以将指定大小以下的图片文件转换成 Base64 数据，直接嵌入到生成的 bundle.js 中，从而减少了额外的网络请求，提高页面的性能和加载速度。</p>
<pre><code class="language-js">{
  test: /\.(png|jpe?g|gif)$/i,
  use: [
    {
      loader: 'url-loader',
      options: {
        limit: 100 * 1024, // 100KB
        name: 'images/[name]-[hash:6].[ext]'
      }
    }
  ]
}
</code></pre>
<p>url-loader 默认使用 ESM，而 html-loader 默认使用 CommonJS。如果在使用 url-loader 时，解析出现了 <code>[object Module]</code> 的问题，可能是由于 url-loader 默认使用了 ESM 模块系统，而配置文件中存在与 ESM 不兼容的语法或模块系统。为解决这个问题尝试关闭 url-loader 的 ESM，改为使用 CJS 模块系统解析文件。</p>
<pre><code class="language-javascript">rules: [ 
  {
    test: /\.(jpg|png|gif)$/, // 默认处理不了 html 中 img 图片
    loader: &quot;url-loader&quot;, // 仅使用一个 loader 可以不需要 use
    options: {
      limit: 8 * 1024, // 图片大小小于 8kb =&gt; 被 base64 处理
      esModule: false, 
      name: &quot;[hash:10].[ext]&quot; // 重命名 =&gt; [hash:10] 取图片的 hash 的前 10 位
    }
  },
  {
    test: /\.html$/, // 处理图片除样式引入外的 html 标签引入
    loader: &quot;html-loader&quot; 
  } 
]
</code></pre>
<p>在 webpack 5 中，可以使用 <a href="https://webpack.js.org/guides/asset-modules/?ref=localhost#root">Asset Modules</a> 替代之前的 url-loader、file-loader 等加载资源的方式。</p>
<p>Asset Modules 可通过 <code>type</code> 属性来指定资源的类型，webpack 会自动将其转换成合适的模块类型。</p>
<pre><code class="language-js">module.exports = {
  //...
  module: {
    rules: [
      {
        test: /\.(png|jpe?g|gif)$/i,
        type: &quot;asset&quot;,
        generator: {
          filename: &quot;images/[name]-[hash][ext]&quot;
        },
        parser: {
          dataUrlCondition: {
            maxSize: 100 * 1024 // 100kb
          }
        }
      }
    ]
  }
}
</code></pre>
<p>在处理特殊字体的资源时，可以使用 file-loader 或者 Asset Modules。</p>
<p>在 Asset Modules 中的 <code>[ext]</code> 占位符会自动包含文件名里的扩展名。故在文件名模板中不需要再显式地添加点号，即可以省略 <code>[ext]</code> 前面的点号，如：<code>[name]-[hash]</code>。但对于其他情况，如使用 file-loader 或 url-loader 时，文件名模板需要显式地添加点号。比如：<code>[name].[ext]</code>。</p>
<pre><code class="language-js">rules: [
  {
    test: /\.(eot|ttf|woff2?)$/i,
    type: &quot;asset/resource&quot;,
    generator: {
      filename: &quot;font/[name]_[hash:6][ext]&quot; // 此处为 filename 中写目录
    }
  }
]
</code></pre>
<h3 id="generalplugins">General Plugins</h3>
<blockquote>
<p>While loaders are used to transform certain types of modules, plugins can be leveraged to perform a wider range of tasks like bundle optimization, asset management and injection of env variables.</p>
</blockquote>
<p>在不清空构建目录的情况下，虽然打包所生成的文件会直接覆盖构建目录中的同名文件，但是仍然会有残余的文件被保留下来。可以使用 clean-webpack-plugin 来自动删除构建目录。</p>
<pre><code class="language-js">const { CleanWebpackPlugin } = require(&quot;clean-webpack-plugin&quot;); // 引入类

module.exports = {
  ...
  plugins: [ new CleanWebpackPlugin() ]
}
</code></pre>
<p>html-webpack-plugin 可以根据打包后的结果自动生成 HTML，并自动引入打包后的 JS 和 CSS 文件。</p>
<pre><code class="language-javascript">const HtmlWebpackPlugin = require('html-webpack-plugin');

plugins: [
  ...
  new HtmlWebpackPlugin({
    title: &quot;webpack title&quot;,
    template: './src/index.html'
  })
]
</code></pre>
<p>html-webpack-plugin 默认使用 ejs 模板引擎来生成 HTML 文件。在自定义模板数据填充时，可以使用 DefinePlugin 在编译时创建全局常量。DefinePlugin 是 Webpack 内置的一个插件。</p>
<pre><code class="language-javascript">const webpack = require('webpack');
const HtmlWebpackPlugin = require('html-webpack-plugin');

module.exports = {
  // ...
  plugins: [
    new webpack.DefinePlugin({
      APP_TITLE: JSON.stringify('My App'),
      APP_VERSION: JSON.stringify('1.0.0'),
    }),
    new HtmlWebpackPlugin({
      template: 'src/index.ejs',
      filename: 'index.html',
      inject: true,
    }),
  ],
};
</code></pre>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;&lt;%= APP_TITLE %&gt; - &lt;%= APP_VERSION %&gt;&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<blockquote>
<p>The copy-webpack-plugin copies individual files or entire dirs, which already exist, to the build dir.</p>
</blockquote>
<p>copy-webpack-plugin 会根据 <code>output.path</code> 配置项指定的输出目录自动计算出正确的构建目录，因此在 <code>patterns</code> 中的 <code>to</code> 配置项里可以写相对路径，例如 <code>./</code> 表示输出目录的根目录。若不设置 <code>to</code> 配置项 copy-webpack-plugin 会默认将文件复制到输出目录的根目录下。</p>
<pre><code class="language-javascript">const CopyWebpackPlugin = require('copy-webpack-plugin');

module.exports = {
  // ...
  plugins: [
    new CopyWebpackPlugin({
      patterns: [
        {
          from: 'src/assets',
          to: './',
          globOptions: {
            ignore: [
              '**/index.html', // 忽略 src/assets 目录及其子目录下的所有 index.html 文件
              'src/assets/images', // 忽略 src/assets/images 目录及其子目录
            ],
          },
        },
      ],
    }),
  ],
};
</code></pre>
<h3 id="modularsupport">Modular Support</h3>
<p>webpack 的模块化本质上就是为每个模块创建了一个独立的函数作用域。</p>
<p>在加载模块时，会先根据模块的路径生成一个 <code>moduleId</code>，并将其传递给 <code>__webpack_require__</code> 函数。<code>__webpack_require__</code> 函数会使用这个 <code>moduleId</code> 来获取对应的模块工厂函数，然后调用这个函数来获取模块的导出值。</p>
<p>默认 webpack 会为每个模块生成一个独立的模块工厂函数，并将其存储在 <code>__webpack_modules__</code> 对象（可理解为模块映射）中，键名是模块的路径，值是包装了模块代码的函数。</p>
<pre><code class="language-javascript">// 模块工厂函数加载执行模块
__webpack_modules__[moduleId](module, module.exports, __webpack_require__)
</code></pre>
<h3 id="sourcemap">Source Map</h3>
<p>webpack 中可以通过配置 <a href="https://webpack.js.org/configuration/devtool/?ref=localhost">devtool</a> 选项来生成 source-map。source-map 是一种映射关系，可以将编译后的代码映射回原始源码，使得在浏览器控制台中准确地显示出错误和警告的位置，方便定位和调试问题。</p>
<p>webpack 在 <code>mode: &quot;development&quot;</code> 模式下默认设置 <code>devtool: &quot;eval&quot;</code>。这会将每个模块的源代码转换成字符串，并使用 <code>eval</code> 函数对其执行。利用 <code>eval</code> 包裹代码的末尾注释，可以标记每个模块的位置信息、依赖信息以及代码映射关系等，方便在开发者工具中进行调试。</p>
<p>这些注释被称为 sourceURL 和 sourceMappingURL 注释。其中，sourceURL 注释用于标记 <code>eval</code> 包裹的代码对应的源文件路径和行号信息，而 sourceMappingURL 注释用于标记生成的 source map 文件路径。</p>
<p><code>source-map</code> 会生成独立的 source-map，并在打包文件中生成指向 source-map 文件的注释，这个注释通常以 <code>//# sourceMappingURL=</code> 开头，后面跟着 source-map 文件的 URL。这个注释会被浏览器解析，然后自动下载对应的 source-map 文件。</p>
<p><code>eval-source-map</code> 生成的 source-map 是以 DataUrl 的形式添加到 <code>eval</code> 函数后面，而不是作为单独的文件存在。</p>
<p><code>inline-source-map</code> 会将生成的 source-map 以 DataUrl 的形式添加到打包文件的尾部。</p>
<p><code>cheap-source-map</code> 中的 cheap 表示低开销，其生成的 source-map 不包含列映射信息，只包含行映射信息。开发中一般使用行映射信息即可定位异常。</p>
<p><code>cheap-module-source-map</code> 会比 <code>cheap-source-map</code> 包含更多的信息，特别是对于使用了 loader 处理的代码，可以提供更加完整的源代码映射。</p>
<p>常规来说 <code>devtool</code> 的组合规则可以按照如下格式，其中，<code>[inline-|hidden-|eval-]</code> 表示 source map 的嵌入方式，选项 <code>[nosource-]</code> 表示不包含源代码信息，选项 <code>[cheap-[module-]]</code> 表示在仅包含行映射的条件下，是否使用对 loader 转换后的源代码进行更完整信息的显示，最后 <code>source-map</code> 表示生成独立的 source map 文件。</p>
<pre><code class="language-javascript">[inline-|hidden-|eval-][nosource-][cheap-[module-]]source-map
</code></pre>
<p>开发和测试阶段推荐选择 <code>source-map</code> 与 <code>cheap-module-source-map</code>。</p>
<p>为提高代码运行效率和减小文件体积，打包阶段通常不包含源代码映射，推荐缺省或 <code>false</code>。</p>
<h3 id="babel">Babel</h3>
<p><a href="https://babeljs.io/docs/en/?ref=localhost">巴别塔 Babel</a> 是一个工具链，可以将 ECMAScript 2015+ 代码转换为支持在当前和旧版本浏览器环境中运行的 JavaScript 版本（向后兼容）。</p>
<p>在开发环境依赖中安装 Babel 核心模块 @babel/core 和命令行工具 @babel/cli。</p>
<ul>
<li>@babel/core 提供了 Babel 的编译功能，包括解析源码、转换和生成目标代码等</li>
<li>@babel/cli 提供了在命令行中使用 Babel 的能力，可以通过命令行参数指定相关的操作</li>
</ul>
<pre><code class="language-shell">$ npm install --save-dev @babel/core @babel/cli
</code></pre>
<p>使用 Babel 来转换箭头函数和块级作用域时，需要额外安装两个插件 @babel/plugin-transform-arrow-functions 和 @babel/plugin-transform-block-scoping。</p>
<pre><code class="language-shell">$ npm install --save-dev @babel/plugin-transform-arrow-functions @babel/plugin-transform-block-scoping
</code></pre>
<pre><code class="language-shell">$ npx babel src --out-dir dist --plugins=@babel/plugin-transform-arrow-functions, @babel/plugin-transform-block-scoping
</code></pre>
<p><a href="https://babeljs.io/docs/en/babel-preset-env?ref=localhost">@babel/preset-env</a> 是一个预设插件集合，提供了根据当前的环境自动确定需要使用哪些插件来进行语法转换的能力。@babel/preset-env 预设插件集合在使用时，可以通过设置 <code>targets</code> 选项来指定转换的目标执行环境。这个选项可以是一个对象，也可以是一个字符串。</p>
<pre><code class="language-shell">$ npm install --save-dev @babel/preset-env 
</code></pre>
<pre><code class="language-shell">$ npx babel src --out-dir dist --presets=@babel/preset-env --targets '{&quot;chrome&quot;: &quot;58&quot;, &quot;ie&quot;: &quot;11&quot;}'
</code></pre>
<p>除 <code>targets</code> 以外，@babel/preset-env 还提供了一些其他的选项，用于控制预设插件集合的行为。其中比较常用的有：根据目标环境自动导入所需的 polyfill 的 <code>useBuiltIns</code> 和在控制台输出详细的调试信息，包括每个插件的名称、版本和选项的 <code>debug</code>。<code>.babelrc</code> 或 <code>babel.config.js</code> 中添如下。</p>
<pre><code class="language-javascript">{
  &quot;presets&quot;: [
    [
      &quot;@babel/preset-env&quot;,
      {
        &quot;useBuiltIns&quot;: &quot;usage&quot;, // 自动根据使用的特性来决定是否导入 polyfill
        &quot;corejs&quot;: 3,
        &quot;debug&quot;: true
      }
    ]
  ]
}
</code></pre>
<p>@babel/polyfill 是一个 JavaScript lib，提供对 ECMAScript 新特性的 polyfill 支持，以使这些特性在旧版浏览器中也可以生效。其包含两个主要的部分：core-js 和 regenerator-runtime。</p>
<p>core-js 是一个模块化的标准库，为 ECMAScript 的各种特性提供 polyfills，以解决不同浏览器之间的兼容性问题。包括 Promise、Map、Set、Reflect、Proxy、Symbol 等。</p>
<pre><code class="language-shell">npm install core-js@3 --save
# or
npm install core-js@2 --save
</code></pre>
<p>regenerator-runtime 是一个运行时库，提供了对于 ECMAScript 6 generators 和 async/await 语法的支持。通常用来处理生成器和异步函数。</p>
<p>提示：@babel/polyfill 在 Babel 7.4.0 中已经被弃用了，建议使用 @babel/preset-env 中的 useBuiltIns 选项来引入需要的 polyfill。只需指定 corejs 版本，不需要额外指定 regenerator-runtime。</p>
<p>插件 @babel/plugin-transform-runtime 可以将代码中使用到的一些辅助函数进行替换，以实现在不污染全局命名空间的情况下使用（如 Object.assign、Promise、Symbol 等）。这可以解决 polyfill 机制中将新增的静态方法和实例方法直接添加到全局变量或全局变量原型上的问题（与第三方库产生冲突）。</p>
<pre><code class="language-shell">yarn add @babel/plugin-transform-runtime -D
</code></pre>
<pre><code class="language-javascript">{
  &quot;presets&quot;: [
    [
      &quot;@babel/preset-env&quot;,
      {
        &quot;useBuiltIns&quot;: &quot;usage&quot;, // 如果 @babel/plugin-transform-runtime 配置了 corejs:3 =&gt; preset-env 的 useBuiltIns 就不会生效
        &quot;debug&quot;: true,
        &quot;targets&quot;: {
          &quot;ie&quot;: 10
        },
        &quot;comments&quot;: false // 不产生注释
      }
    ]
  ],
  &quot;plugins&quot;: [
    [
      // 转换为引用 babel-runtime/regenerator 和 babel-runtime/core-js 模块中的方法
      &quot;@babel/plugin-transform-runtime&quot;,
      {
        &quot;corejs&quot;: 3 // 指定 runtime-corejs 的版本 =&gt; 目前有 2、3
      }
    ]
  ]
}
</code></pre>
<p>Babel 的执行过程其实和很多编译器的工作原理是类似的。</p>
<ul>
<li>解析：使用解析器 Parser 将源码解析成 AST 抽象语法树</li>
<li>转换：使用转换器 Transformer 对 AST 进行修改，并应用插件 Plugins 对特定的语法进行转化</li>
<li>生成：使用生成器 Generator 将修改后的 AST 转换为目标代码，可以被 V8 引擎解释执行</li>
</ul>
<p>解析一般包括词法分析和语法分析两个阶段。词法分析会将源代码转换成记号流，而语法分析会分析这些 tokens 流并将其转换成一颗抽象语法树 AST。</p>
<p>当需要将 TypeScript 转换为 JavaScript 时，可以结合使用 babel-loader 与 tsc，以弥补这两者各自的不足。babel-loader 在编译时不会对类型错误进行检测，仅使用 tsc 会缺少解决兼容性问题的 polyfill。</p>
<p>具体可以在 <code>package.json</code> 中添加脚本 <code>&quot;type-check-watch&quot;: &quot;tsc --noEmit --watch&quot;</code> 来开启类型检查，在 webpack 中使用 babel-loader 进行编译转换和解决兼容性的问题。</p>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><h2 id="advancedsupport">Advanced Support</h2>
<h3 id="transitionsforvuesfc">Transitions for Vue SFC</h3>
<p>在将 Vue 单文件组件转换为 JavaScript 模块时，需要借助 vue-loader 与 vue-template-compiler。前者可以将一个 <code>.vue</code> 文件转换为 JavaScript 对象。后者会将 <code>.vue</code> 文件中的 <code>&lt;template&gt;</code> 标签编译为渲染函数，最终生成实际的 DOM 结构并进行渲染，以便在浏览器中可以显示相关的组件。</p>
<pre><code class="language-shell">$ npm install vue-loader vue-template-compiler -D
</code></pre>
<p>配置 vue-loader 时需要在 webpack 的配置文件中使用 <code>VueLoaderPlugin</code> 插件。具体来说，需要在配置文件中的 <code>plugins</code> 数组中创建一个 <code>VueLoaderPlugin</code> 的实例，并将其作为插件添加进去。</p>
<pre><code class="language-javascript">const VueLoaderPlugin = require('vue-loader/lib/plugin');

module.exports = {
  // ...其他配置
  module: {
    rules: [
      {
        test: /\.vue$/,
        loader: 'vue-loader'
      },
      // ...其他规则
    ]
  },
  plugins: [
    new VueLoaderPlugin()
  ]
};
</code></pre>
<h3 id="devserverandhmr">DevServer and HMR</h3>
<p>通常在开发阶段需要频繁地修改和测试代码，如果每次都通过手动编译和刷新浏览器，那么开发效率就会受到影响，此时可以使用 devServer 在内存中编译打包，并提供一个自动刷新浏览器的开发环境。</p>
<p>虽然使用 <code>watch</code> 参数或者 live-server 插件也可以实现代码修改后的页面更新，但效率不如 devServer 高。因为 <code>watch</code> 参数或者 live-server 插件都是直接刷新整个页面，而 devServer 是通过 HMR 热模块替换技术实现了页面的局部更新，从而避免了刷新整个页面的开销。</p>
<pre><code class="language-javascript">...
module.exports = {
  mode: 'development',
  devServer: {
    contentBase: resolve(__dirname, 'build'), // 项目构建后路径
    compress: true, // 启动 gzip 压缩
    port: 3000, // 端口号 
    open: true // 自动打开浏览器 
  } 
};
</code></pre>
<p>需要<a href="https://stackoverflow.com/questions/40379139/cannot-find-module-webpack-bin-config-yargs?ref=localhost">注意的是 webpack-cli 的版本</a>，webpack-cli 4 已经将 devServer 的实现方式进行了重构，需要使用 <code>webpack serve</code> 来启动开发服务器，而 webpack-cli 4 以前的版本，使用 <code>webpack-dev-server</code>。</p>
<p>webpack-dev-middleware 是一个 Express 中间件，可以将 webpack 打包的文件传递给服务器，并且可以将打包结果缓存到内存中，以便在文件发生变化时自动重新构建。</p>
<pre><code class="language-javascript">const express = require('express');
const webpack = require('webpack');
const webpackDevMiddleware = require('webpack-dev-middleware');

const app = express();
const config = require('./webpack.config.js');
const compiler = webpack(config);

app.use(webpackDevMiddleware(compiler, {
  publicPath: config.output.publicPath
}));

app.listen(3000, function () {
  console.log('App listening on port 3000!\n');
});
</code></pre>
<p>如果没有在入口文件中通过 <code>module.hot.accept</code> 函数来指定需要开启 HMR 的模块，那么默认情况下只有在根模块发生变化时，整个应用程序才会被热更新，而其他模块则会触发完整刷新。<a href="https://webpack.js.org/api/hot-module-replacement/?ref=localhost">点此查看</a></p>
<pre><code class="language-javascript">if (module.hot) {
  module.hot.accept('./your-module', function() {
    // 当 './your-module' 模块更新后执行的逻辑
  })
}
</code></pre>
<p>在使用 Vue 或 React 框架开发时，社区已经提供了比较成熟的 HMR 解决方案，<a href="https://webpack.js.org/guides/hot-module-replacement/?ref=localhost#other-code-and-frameworks">点此查看</a>。注意 React Hot Loader 现已被官方弃用，改为 <a href="https://github.com/facebook/react/issues/16604?ref=localhost">react-refresh</a> 方案。</p>
<p>HMR 热更新的实现原理是 webpack-dev-server 或 webpack-dev-middleware 将打包好的文件传递给服务器 Express，同时建立一个长连接的 socket 服务，监听文件的变化事件。当某个模块的代码发生变化时，webpack 会重新打包这个模块的代码，然后通过 socket 服务推送给客户端的浏览器。</p>
<h3 id="codesplitting">Code Splitting</h3>
<p>代码分割作为一种常规的优化手段，可以将打包后的代码拆分成多个小块，然后可以按需加载或并行加载这些文件。</p>
<p>在使用入口起点的方式进行代码分割时，每个入口文件都会被单独的打包。同时，还可以使用的<a href="https://webpack.docschina.org/concepts/under-the-hood/?ref=localhost#output">占位符</a>来指明打包后的 bundle 文件名。</p>
<pre><code class="language-javascript">module.exports = {
  entry: {
    app: './src/app.js',
    vendor: './src/vendor.js'
  },
  output: {
    filename: '[name].[contenthash:8].js',
    path: __dirname + '/dist'
  }
};
</code></pre>
<p>当多个入口文件使用了相同的第三方包时，如果不进行处理，这些第三方包可能会被重复打包，导致打包后的文件体积过大。为避免这种情况，可使用 <a href="https://webpack.js.org/configuration/entry-context/?ref=localhost"><code>Entry dependencies</code></a> 和 <a href="https://webpack.js.org/plugins/split-chunks-plugin/?ref=localhost"><code>SplitChunksPlugin</code></a>。</p>
<p><a href="https://webpack.docschina.org/plugins/split-chunks-plugin/?ref=localhost#splitchunkschunks"><code>optimization.splitChunks.chunks</code></a> 的默认值是 <code>async</code>，这意味着在 webpack 中，异步或动态导入的文件会被打包成一个独立的 chunk。</p>
<p>注意，该 chunk 的名称是自动生成的 chunk id，具体生成规则受到 <a href="https://webpack.docschina.org/configuration/optimization/?ref=localhost#optimizationchunkids"><code>optimization.chunkIds</code></a> 配置的影响。可以通过 <code>webpackChunkName</code> 这种 magic comments 来自定义生成的 chunk 名称。</p>
<pre><code class="language-javascript">import(
  /* webpackChunkName: &quot;utils&quot; */
  &quot;./utils&quot;
).then({default: utils}) =&gt; { utils(); });
</code></pre>
<h3 id="treeshaking">Tree Shaking</h3>
<blockquote>
<p>Tree shaking is a term commonly used in the JavaScript context for dead-code elimination. It relies on the static structure of ES2015 module syntax, i.e. import and export. The name and concept have been popularized by the ES2015 module bundler rollup. <a href="https://webpack.docschina.org/guides/tree-shaking/?ref=localhost">More</a>.</p>
</blockquote>
<p>当 <code>optimization.usedExports</code> 设置为 <code>true</code> 时，Webpack 会在编译过程中生成一些帮助 Terser 进行代码优化的注释。例如，当模块中有某个函数被导出，但是并没有在项目里被实际的使用到，那么会产生 <code>unused harmony export ...</code> 注释。</p>
<p>然而，要使 Tree Shaking 真正的生效，还需要配置 <a href="https://webpack.docschina.org/configuration/optimization/?ref=localhost#optimizationminimize"><code>optimization.minimize: true</code></a>，否则，虽然注释已经生成，但 <code>optimization.minimizer</code> 中的插件没有被启用，Terser 就不会进行代码优化。</p>
<p>在进行上述配置后，仍然可能存在一些残余代码，例如在打包文件中存在无意义的导入。此时，可以通过设置 package.json 中的 <a href="https://webpack.docschina.org/guides/tree-shaking/?ref=localhost#mark-the-file-as-side-effect-free"><code>&quot;sideEffects&quot;</code></a> 属性来标记哪些模块具有副作用，进一步优化摇树效果。</p>
<p>CSS Tree Shaking 可以选择 <a href="https://www.npmjs.com/package/purgecss-webpack-plugin?ref=localhost">PurgeCSS</a>，早期的 PurifyCSS 方案现已不再维护。</p>
<h3 id="uglifyjsvsterser">UglifyJS VS Terser</h3>
<p>Terser 和 UglifyJS 都是压缩和混淆 JavaScript 代码的工具，用于在构建过程中减小代码体积。Terser 在 UglifyJS 的基础上进行了改进和优化，并且支持 ES6+ 语法，可以处理箭头函数、模板字符串、解构赋值等新特性。此外，精确 Tree Shaking 以及并发压缩也让 Terser 更好地支持现代项目。</p>
<h3 id="httphtmlcomp">HTTP &amp; HTML COMP</h3>
<p>HTTP compression 可以减小 Server 与 Client 之间的数据量。Client 请求资源时携带 Accept-Encoding 请求头，表明支持哪些压缩算法。如果服务端支持其中一种压缩算法并且有配置为压缩响应，就可以在响应中包含一个 Content-Encoding 响应头，以指示响应已被压缩。</p>
<p>webpack 中，可以通过 <a href="https://webpack.docschina.org/plugins/compression-webpack-plugin/?ref=localhost">compression-webpack-plugin</a> 插件来启用 HTTP 压缩。compression-webpack-plugin 会在编译时自动检测所有的资源文件，将其压缩后输出，并在响应中添加 Content-Encoding。</p>
<p>对 HTML 文件进行压缩可以使用 HtmlWebpackPlugin 插件中的 <code>minify</code> 属性。如果需要将 chunk 出来的模块（如运行时代码）内联到 HTML，可以使用 react-dev-utils 中的 InlineChunkHtmlPlugin。</p>
<pre><code class="language-javascript">const HtmlWebpackPlugin = require('html-webpack-plugin');
const InlineChunkHtmlPlugin = require('react-dev-utils/InlineChunkHtmlPlugin');

module.exports = {
  // 其他配置项
  plugins: [
    new HtmlWebpackPlugin({
      template: './src/index.html',
      // 压缩 HTML 代码
      minify: {
        removeComments: true, // 移除注释
        collapseWhitespace: true, // 折叠空白字符
        removeRedundantAttributes: true, // 移除冗余的属性
        useShortDoctype: true, // 使用短的 &lt;!DOCTYPE html&gt; 声明
        removeEmptyAttributes: true, // 移除 HTML 元素中的空属性
        removeStyleLinkTypeAttributes: true, // 移除 type=&quot;text/css&quot; 属性
        keepClosingSlash: true, // 保留自闭合标签的末尾斜杠
        minifyJS: true, // 压缩内联 JS
        minifyCSS: true, // 压缩内联 CSS
        minifyURLs: true, // 压缩 URL
      },
    }),
    // 将 chunk 内联到 HTML 中
    new InlineChunkHtmlPlugin(HtmlWebpackPlugin, [/runtime.*\.js/]),
  ],
};
</code></pre>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><h2 id="tipsandhints">Tips and Hints</h2>
<h3 id="operatorsand">Operators &amp;&amp; and &amp;</h3>
<p>&amp;&amp; 运算符会将两个命令连接起来，并当第一个命令执行成功后再执行第二个命令。</p>
<p>&amp; 运算符是将两个命令同时执行，不需要等待第一个命令的执行完毕，常用于同时执行多个任务。</p>
<h3 id="publicpathinoutputanddevserver">publicPath in output and devServer</h3>
<p>配置项 <code>output.publicPath</code> 和 <code>devServer.publicPath</code> 都是相对于打包输出目录的 URL，这个选项会成为引用静态资源时的前缀。两者的区别是客户端访问静态资源和访问开发服务器上的静态资源。</p>
<h3 id="entryandcontext">Entry and Context</h3>
<blockquote>
<p>The <a href="https://webpack.js.org/configuration/entry-context/?ref=localhost#context">context</a> is the base directory, an absolute path, for resolving entry points and loaders from the configuration.</p>
</blockquote>
<p><code>entry</code> 通常使用相对路径，并且相对于配置中的 <code>context</code> 属性。<code>context</code> 属性是一个用于解析相对路径的绝对路径，这个绝对路径可以是任何存在的目录，但通常会选择项目的根目录作为上下文。</p>
<h3 id="filenameandchunkfilename">Filename and ChunkFilename</h3>
<p><code>output.filename</code> 用于指定入口起点生成的 bundle 文件名，而 <code>output.chunkFilename</code> 用于指定非入口起点生成的文件名，例如懒加载这种动态导入的代码块的文件名格式。注意，<code>webpackChunkName</code> 优先级高于 <code>output.chunkFilename</code> 高于默认的 chunk id。</p>
<h3 id="hashchunkhashcontenthash">Hash &amp; ChunkHash &amp; ContentHash</h3>
<p><code>hash</code> 是通过 webpack 编译过程中的一些信息（如打包时的模块内容、打包时间等）计算得出的。</p>
<p><code>chunkhash</code> 是通过 chunk 内容计算的，当 chunk 内容发生变化时，该哈希值才会发生变化。</p>
<p><code>contenthash</code> 是通过文件内容计算的。当文件内容发生变化时，该哈希值才会发生变化。</p>
<p><code>fullhash</code> 是通过整个项目的内容计算得到的，只有在项目内容发生变化时才会生成新的文件名。</p>
<p>注意，<code>chunkhash</code> 会随着引入的模块内容变化而发生改变，<code>contenthash</code> 常应用于静态资源的文件名，以避免不必要的缓存失效。因需要计算所有资源的哈希值，<code>fullhash</code> 的生成速度要比 <code>hash</code> 慢很多（<code>fullhash</code> 会计算静态资源的哈希值，但是 <code>hash</code> 不会）。</p>
<h3 id="webpackdevserver">webpack-dev-server 兼容问题</h3>
<p>运行<code>webpack-dev-server</code>出现如下报错</p>
<pre><code class="language-javascript">&gt; webpack-dev-server

internal/modules/cjs/loader.js:883
  throw err;
  ^

Error: Cannot find module 'webpack-cli/bin/config-yargs'
</code></pre>
<p>报错内容为找不到 webpack-cli 中对应模块。报错时项目相应 webpack 配置如下：</p>
<pre><code class="language-javascript">&quot;webpack&quot;: &quot;^5.24.3&quot;,
&quot;webpack-cli&quot;: &quot;^4.5.0&quot;,
&quot;webpack-dev-server&quot;: &quot;^3.11.2&quot;
</code></pre>
<p>解决方案：</p>
<ul>
<li>方法一：重装 <code>webpack-cli</code> 与 <code>webpack-dev-server</code> 兼容的版本</li>
<li>方法二：添加 <code>&quot;dev&quot;:&quot;webpack serve --open Chrome&quot;</code> 到 <code>package.json</code> 中的 <code>&quot;script&quot;</code> 选项</li>
</ul>
<h3 id="gzipcompression">Gzip Compression</h3>
<p>设置 <code>devServer.compress: true</code> 可以启用开发服务器的 Gzip 压缩功能，但这并不会影响打包后的资源文件。为了在生产环境中也能使用 Gzip 压缩，可以借助 <code>compression-webpack-plugin</code> 插件。</p>
<pre><code class="language-shell">npm install compression-webpack-plugin --save-dev
</code></pre>
<pre><code class="language-js">// vue.config.js
const CompressionPlugin = require('compression-webpack-plugin');

module.exports = defineConfig({
  configureWebpack: {
    plugins: [
      new CompressionPlugin({
        test: /\.(js|css|html|svg|json|ico|woff|ttf)$/, // 需要压缩的文件类型
        threshold: 10240, // 10KB 以上的文件才会被压缩
      }),
    ],
  },
});
</code></pre>
<p>发送请求时，<code>Accept-Encoding</code> 字段会由浏览器自动设置。当服务端返回压缩的资源时，也通常会在响应头中设置 <code>Content-Encoding: gzip</code>，告知浏览器该资源已被压缩。在 Express 中启用 Gzip 压缩可以使用 compression 中间件。Nginx 可以在配置文件中通过 <code>location</code> 来指定哪些请求需要启用 Gzip 压缩。</p>
<pre><code class="language-markdown">gzip on;
gzip_min_length 1000;
gzip_types text/plain application/xml application/javascript;
</code></pre>
<p>然而，并不是所有的项目都需要启用压缩。当项目非常小，并且没有大量的静态资源需要传输，那么启用压缩可能并不会带来显著的性能提升。相反，甚至会增加服务器的 CPU 负担。</p>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><h2 id="blackboxanalysis">Black Box Analysis</h2>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><h2 id="deprecatedconfiguration">Deprecated Configuration</h2>
<h3 id="dynamiclinkinglibrary">Dynamic Linking Library</h3>
<p>DDL 动态链接库通过 DllPlugin 插件来实现。该插件会将指定的模块打包成一个动态链接库，并生成一个 manifest 文件，用于描述动态链接库的内容和对应的模块名称。</p>
<p>在项目根目录下，创建一个名为 <code>webpack.dll.config.js</code> 的配置文件，并在其中配置 DllPlugin 插件，指定需要打包为动态链接库的模块。</p>
<pre><code class="language-js">const path = require('path');
const { DllPlugin } = require('webpack');

module.exports = {
  mode: 'production',
  entry: {
    vendor: ['react', 'react-dom', 'lodash'], // 需要打包为动态链接库的模块
  },
  output: {
    filename: '[name].dll.js',
    path: path.resolve(__dirname, 'dll'),
    library: '[name]',
  },
  plugins: [
    new DllPlugin({
      name: '[name]',
      path: path.resolve(__dirname, 'dll/[name].manifest.json'),
    }),
  ],
};
</code></pre>
<p>然后，在 package.json 中添加一个脚本命令，用于执行构建 DDL 动态链接库的任务。</p>
<p>运行 <code>npm run build:dll</code> 会执行构建动态链接库的操作，根据配置文件 <code>webpack.dll.config.js</code>，将指定的模块打包成一个名为 <code>vendor.dll.js</code> 的动态链接库，并生成一个 <code>vendor.manifest.json</code> 的 manifest 文件。</p>
<pre><code class="language-JS">{
  &quot;scripts&quot;: {
    &quot;build:dll&quot;: &quot;webpack --config webpack.dll.config.js&quot;
  }
}
</code></pre>
<p>在项目的主配置文件中，使用 DllReferencePlugin 插件引用刚刚生成的动态链接库。</p>
<pre><code class="language-JS">const path = require('path');
const { DllReferencePlugin } = require('webpack');

module.exports = {
  mode: 'development',
  entry: {
    main: './src/index.js', // 项目的入口文件
  },
  output: {
    filename: 'bundle.js',
    path: path.resolve(__dirname, 'dist'),
  },
  plugins: [
    new DllReferencePlugin({
      context: __dirname,
      manifest: require('./dll/vendor.manifest.json'),
    }),
  ],
};
</code></pre>
<p>最后，在项目的入口文件 index.js 中，可以正常引用 DDL 动态链接库中的模块。</p>
<pre><code class="language-jsx">import React from 'react';
import ReactDOM from 'react-dom';

ReactDOM.render(&lt;App /&gt;, document.getElementById('root'));
</code></pre>
<p>除开 Webpack 提供的 DllPlugin 和 DllReferencePlugin 插件，配置选项 Externals 也可以避免将某些外部依赖库打包进业务代码，而通过 <code>script</code> 标签或者其他方式在运行时从外部引入这些依赖。</p>
<p>假设有一个大型的项目，项目依赖了很多第三方库，例如 react、react-dom、lodash、axios 等。这些第三方库的版本比较稳定，不经常变动。在这种情况下，可以考虑使用 DllPlugin 和 DllReferencePlugin 将这些库预先打包成 DLL 文件。这样在每次构建项目时，Webpack 不需要重新解析和打包这些库，从而大大缩短构建时间。而对于简单的小型项目，可能只需要引入一个或两个第三方库，或者直接使用 CDN 的方式引入一些库，这时可以选择使用 Externals 将这些库排除在构建过程之外，减小输出文件的体积。</p>
<h3 id="happypack">HappyPack</h3>
<p>HappyPack 是一个可以将 Webpack 的任务分解成多个子进程并行处理的插件，更高效地利用多核 CPU。然而，随着 Webpack 的不断发展和优化，HappyPack 已经不再被推荐使用了。</p>
<p>如果希望进一步优化构建性能，可以通过 <a href="https://webpack.js.org/loaders/thread-loader/?ref=localhost#root">thread-loader</a> 来替代 HappyPack。thread-loader 将耗时较长的 Loader（如 Babel 或 TypeScript）放入单独的 worker 池中，并在 worker 池中使用多线程并行处理这些任务。</p>
<p>通过 NPM 安装 thread-loader，并将 thread-loader 添加到耗时较长的 Loader 配置之前。</p>
<pre><code class="language-shell">npm install thread-loader --save-dev
</code></pre>
<pre><code class="language-js">module.exports = {
  module: {
    rules: [
      {
        test: /\.js$/,
        // 将 thread-loader 添加到 babel-loader 之前
        use: ['thread-loader', 'babel-loader'],
        exclude: /node_modules/,
      },
      // ...其他规则
    ],
  },
  // ...其他配置
};
</code></pre>
<p>有需要可以在 thread-loader 中配置 worker 池的大小，即并行处理任务的线程数，默认为 <code>os.cpus().length</code>。</p>
<pre><code class="language-js">module.exports = {
  module: {
    rules: [
      {
        test: /\.js$/,
        use: [
          {
            loader: 'thread-loader',
            options: {
              // 指定 worker 池的大小
              workers: os.cpus().length - 1, // 默认是 os.cpus().length
            },
          },
          'babel-loader',
        ],
        exclude: /node_modules/,
      },
      // ...其他规则
    ],
  },
  // ...其他配置
};
</code></pre>
<p>thread-loader 可以提高构建速度，但也可能会增加构建过程中的内存开销。在实际开发中，应该根据项目的具体情况和硬件资源，合理配置 worker 池的大小，避免过度占用系统资源。</p>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><h2 id>结束</h2>
<p>本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh?ref=localhost"> CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
<!--kg-card-end: markdown-->
    </section>

        <section class="article-comments gh-canvas">
        
        <script src="https://utteranc.es/client.js"
        repo="Zairesinatra/comments-by-utterances"
        issue-term="pathname"
        theme="photon-dark"
        crossorigin="anonymous"
        async>
        </script>
        
    </section>

</article>
</main>

    <section class="footer-cta outer">
        <div class="inner">
            <h2 class="footer-cta-title">Sign up for more like this.</h2>
            <a class="footer-cta-button" href="index.html#/portal" data-portal>
                <div class="footer-cta-input">Enter your email</div>
                <span>Subscribe</span>
            </a>
        </div>
    </section>




    </div>

    <div class="docsearchwrapper"><div id="docsearch"></div></div>
    <div class="arrowup">
      <svg
        version="1.1"
        id="Layer_1"
        xmlns="http://www.w3.org/2000/svg"
        xmlns:xlink="http://www.w3.org/1999/xlink"
        x="0px"
        y="0px"
        width="20px"
        height="20px"
        viewBox="0 0 122.883 122.882"
        enable-background="new 0 0 20 20"
        xml:space="preserve"
      >
        <g>
          <path
            d="M0,61.441L0,61.441h0.018c0,16.976,6.872,32.335,17.98,43.443c11.108,11.107,26.467,17.979,43.441,17.979v0.018h0.001 h0.001v-0.018c16.974,0,32.335-6.872,43.443-17.98s17.98-26.467,17.98-43.441h0.018v-0.001V61.44h-0.018 c0-16.975-6.873-32.334-17.98-43.443C93.775,6.89,78.418,0.018,61.443,0.018V0h-0.002l0,0v0.018 c-16.975,0-32.335,6.872-43.443,17.98C6.89,29.106,0.018,44.465,0.018,61.439H0V61.441L0,61.441z M42.48,71.7 c-1.962,1.908-5.101,1.865-7.009-0.098c-1.909-1.962-1.865-5.101,0.097-7.009l22.521-21.839l3.456,3.553l-3.46-3.569 c1.971-1.911,5.117-1.862,7.029,0.108c0.055,0.058,0.109,0.115,0.16,0.175L87.33,64.594c1.963,1.908,2.006,5.047,0.098,7.009 c-1.908,1.963-5.047,2.006-7.01,0.098L61.53,53.227L42.48,71.7L42.48,71.7z"
          />
        </g>
      </svg>
    </div>

    <footer class="site-footer outer">
        <div class="inner">
            <section class="copyright"><a href="../index.html">zairesinatra</a> &copy; 2023</section>
            <nav class="site-footer-nav">
                
            </nav>
            <div class="gh-powered-by"><a href="https://ghost.org/" target="_blank" rel="noopener">Powered by Ghost</a></div>
        </div>
    </footer>

</div>


<script
    src="https://code.jquery.com/jquery-3.5.1.min.js"
    integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0="
    crossorigin="anonymous">
</script>
<script src="../assets/built/casper.js%3Fv=5751b4c87c"></script>
<script>
$(document).ready(function () {
    // Mobile Menu Trigger
    $('.gh-burger').click(function () {
        $('body').toggleClass('gh-head-open');
    });
    // FitVids - Makes video embeds responsive
    $(".gh-content").fitVids();
});
</script>

<!-- searchinghost-easy -->
<!--
<script src="https://cdn.jsdelivr.net/gh/gmfmi/searchinghost-easy@latest/dist/searchinghost-easy-basic.js"></script>
<script>
    new SearchinGhostEasy({
        contentApiKey: 'e93d8b3520ae46be52c9a4b140'
    });
</script>
-->

<!-- Theme Mode -->
<script>
(function ThemeModeInit() {
  const html = document.documentElement;
  const toggle = document.querySelector(".toggle");
  const toc = document.querySelector(".toc");
  
  const switchTheme = function () {
    const storedTheme = localStorage.getItem("mode");
    const newTheme = storedTheme === "dark-mode" ? "light-mode" : "dark-mode";
    
    html.classList.toggle("dark-mode", newTheme === "dark-mode");
    toggle?.classList.toggle("active", newTheme === "dark-mode");
    toc?.classList.toggle("active", newTheme === "dark-mode");
    
    localStorage.setItem("mode", newTheme);
  };
  
  const applyTheme = function (theme) {
      const html = document.documentElement;
  const toggle = document.querySelector(".toggle");
  const toc = document.querySelector(".toc");
    console.log("...");
    html.classList.toggle("dark-mode", theme === "dark-mode");
    toggle?.classList.toggle("active", theme === "dark-mode");
    toc?.classList.toggle("active", theme === "dark-mode");
  };
  
  const initTheme = function () {
    const prefersDarkMode = window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches;
    const storedTheme = localStorage.getItem("mode");
    
    const followSys = (prefersDarkMode) => {
      const systemTheme = prefersDarkMode ? "dark-mode" : "light-mode";
      applyTheme(systemTheme);
      localStorage.setItem("mode", systemTheme);
    };
    
    if (storedTheme) {
      applyTheme(storedTheme);
    } else {
      followSys(prefersDarkMode);
    }
    
    const handleMediaChange = (e) => {
      followSys(e.matches);
    };
    
    const mediaQuery = window.matchMedia("(prefers-color-scheme: dark)");
    mediaQuery.addEventListener("change", handleMediaChange);
    
    window.addEventListener("beforeunload", () => {
      mediaQuery.removeEventListener("change", handleMediaChange);
    });
  };
  
  window.onload = () => {initTheme();}
  
  function handleButtonClick() {
    switchTheme();
    // 这里可以添加其他需要在点击事件中执行的代码
  }
  
  document.addEventListener("DOMContentLoaded", function () {
      const toggle = document.querySelector(".toggle");
    toggle.addEventListener("click", handleButtonClick);
  });
})();
</script>

<script defer>
/* Arrow up */
// 通过位置判断是否显示
function onLoadHandle() {
  let viewportPositionTop =
    window.pageYOffset || document.documentElement.scrollTop;
  if (viewportPositionTop >= 200) {
    if (!$(".arrowup")) {
      arrowup.style.display = "inherit";
    } else {
      $(".arrowup").css("display", "inherit");
    }
  }
}
if (typeof jQuery === "undefined") {
  // Native JS
  let arrowup = document.querySelector(".arrowup");
  // 如果滚动距离达到一定值，显示按钮
  window.addEventListener("scroll", () => {
    arrowup.style.display = window.scrollY >= 200 ? "inherit" : "none";
  });
  // 在页面加载完成后执行的代码
  window.onload = function () {
    onLoadHandle();
  };
  // Back To The Top
  arrowup.addEventListener("click", function () {
    window.scrollTo({
      top: 0,
      behavior: "smooth"
    });
  });
} else {
  // jQuery
  $(window).scroll(function () {
    $(".arrowup").css("display", $(window).scrollTop() > 200 ? "inherit" : "none");
  });

  $(".arrowup").click(function () {
    $("html,body").animate({ scrollTop: 0 }, "slow");
  });

  $(document).ready(function () {
    onLoadHandle();
  });
}
</script>

<!-- Algolia DocSearch -->
<style>
.docsearchwrapper{
  display: none;
}
.DocSearch-Container{
  z-index: 9999999;
}
</style>

<!-- docsearch -->
<script src="https://cdn.jsdelivr.net/npm/@docsearch/js@3"></script>
<script>
function docSearchFuncMobile(){
    const DocSearchElement = document.querySelector(".DocSearch");
    DocSearchElement.click();
  }
</script>

<script type="text/javascript">
  docsearch({
    appId: "722DYFSYDR",
    apiKey: "5b7d4a36b43ac3d135ca6b83ac715f7e",
    indexName: "zairesinatraio",
    container: document.querySelector("#docsearch"),
    debug: false // Set debug to true if you want to inspect the modal
  });
</script>

<!-- 2023 => prismjs -->
<script src="https://cdn.jsdelivr.net/gh/Zairesinatra/GhostCDN@1.0.0/prism.js"></script>
<!-- Patch: additional supported languages -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-vim.min.js" integrity="sha512-P1MRK1H11qw68MAfAYVyjumLuurOQKO4wwcx4S2Nbbae9CndG92dkIXq34lsOeMFlWZoT7nVPgsOy3gepk93Bg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<!-- Activate Line Numbers in PrismJS -->
<script>
	window.addEventListener('DOMContentLoaded', (event) => {      
		document.querySelectorAll('pre[class*=language-]').forEach(function(node) {
			node.classList.add('line-numbers');
            node.style.border = 'solid #FFFFFF 1px'
		});
		Prism.highlightAll();
	});
</script>

<script>
/* Chrome Lighihouse Optimization */
window.addEventListener("DOMContentLoaded", (event) => {
  if (typeof jQuery === "undefined") {
    const searchBtnsForProps = document.querySelectorAll(".gh-search.gh-icon-btn");
    searchBtnsForProps.forEach((btn, i) => {
      btn.setAttribute("id", `GhostSearch${i}`);
      btn.setAttribute("aria-label", "Ghost Blog Search");
    });

    document.querySelector("button.gh-burger")
      .setAttribute("aria-label", "Ghost Blog Nav Menu");

    const siteLogo = document.querySelector(".site-logo");
    siteLogo.setAttribute("width", "120px");
    siteLogo.setAttribute("height", "120px");
  } else {
    $(".site-logo").attr({ width: "120px", height: "120px" });

    $(".gh-search.gh-icon-btn").each(function (index) {
      $(this).attr("id", `GhostSearch${index + 1}`);
      $(this).attr("aria-label", "Ghost Blog Search");
    });
  }
});
</script>

<!-- TOC -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.18.2/tocbot.min.js"></script>
<script>
  tocbot.init({
    tocSelector: '.toc',
    contentSelector: '.gh-content',
    hasInnerContainers: true
  });
</script>
<script>
function tocHandle() {
  var tc = document.querySelector(".toc-container");
  var ah = document.querySelector(".article-header");
  
  if (tc && ah) {
    var tcch = tc.clientHeight;
    var ahch = ah.clientHeight;
    var isTocSticky = false;

    function handleScroll() {
      if (document.body.clientWidth > 1170) {
        var scrollY = window.pageYOffset || document.documentElement.scrollTop;
        var wih = window.innerHeight;

        if (scrollY >= wih + tcch + ahch && !isTocSticky) {
          tc.style.position = "sticky";
          tc.style.position = "-webkit-sticky";
          tc.style.top = "120px";
          tc.style.marginLeft = "800px";
          tc.style.minWidth = "260px";
          isTocSticky = true;
        }
        
        if (scrollY < tcch + ahch - 10 && isTocSticky) {
          tc.style.position = "";
          tc.style.top = "";
          tc.style.marginLeft = "";
          isTocSticky = false;
        }
      }
    }

    // 避免在每个滚动事件触发时都执行回调函数
    window.addEventListener("scroll", function () {
      requestAnimationFrame(handleScroll);
    });
  }
}

window.addEventListener("DOMContentLoaded", tocHandle);
</script>

</body>
</html>
